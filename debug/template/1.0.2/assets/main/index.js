System.register("chunks:///_virtual/action-chain.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "2d4e0WiNklLALhX9kc6T+IG", "action-chain", undefined);
      class ActionChain {
        constructor() {
          this._keys = new Set();
          this._actions = [];
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new ActionChain();
          }
          return this._instance;
        }
        addAction(key, action) {
          if (this._keys.has(key)) {
            return false;
          }
          this._keys.add(key);
          this._actions.push({
            key,
            action
          });
          if (this._keys.size === 1) {
            this.start();
          }
          return true;
        }
        start() {
          this._next();
        }
        _next() {
          const actionObj = this._actions.shift();
          if (actionObj) {
            const {
              key,
              action
            } = actionObj;
            action().then(() => {
              this._keys.delete(key);
              this._next();
            }).catch(error => {
              this._keys.delete(key);
              this._next();
            });
          }
        }
      }
      exports('ActionChain', ActionChain);
      ActionChain._instance = void 0;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ad-agent.ts", ['cc', './ui-manager.ts', './log-util.ts', './ui-config.ts', './connect-agent.ts', './audio-manager.ts'], function (exports) {
  var cclegacy, sys, UIManager, LogUtil, UIID, ConnectAgent, AudioManager;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      sys = module.sys;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      UIID = module.UIID;
    }, function (module) {
      ConnectAgent = module.ConnectAgent;
    }, function (module) {
      AudioManager = module.AudioManager;
    }],
    execute: function () {
      var _class;
      cclegacy._RF.push({}, "a2f71GncFhIs5/UeFAftUps", "ad-agent", undefined);
      class AdAgent {
        static resetVideoAdRequest() {
          this.currentVideoAdRequest.entry = "";
          this.currentVideoAdRequest.revenued = false;
          this.currentVideoAdRequest.callback = null;
          this.currentVideoAdRequest.retryCount = 0;
          this.currentVideoAdRequest.isStarted = false;
        }
        static resetInterstitialAdRequest() {
          this.currentInterstitialAdRequest.entry = "";
          this.currentInterstitialAdRequest.callback = null;
        }
        static openVideoAd(entry, callback) {
          LogUtil.log("AdAgent Open video ad", entry);
          this.resetVideoAdRequest();
          if (sys.isBrowser) {
            LogUtil.log("AdAgent Open video ad in browser", entry);
            UIManager.instance.open(UIID.Loading, {
              desc: "Loading...",
              displayTime: 3,
              onClose: () => {
                if (callback) {
                  callback(entry, true);
                }
              }
            });
          } else {
            // Open video ad
            LogUtil.log("AdAgent Open video ad native", entry);
            this.currentVideoAdRequest.entry = entry;
            this.currentVideoAdRequest.callback = callback;
            ConnectAgent.openVideoAd(entry);
          }
        }
        static openInterstitialAd(entry, callback) {
          console.log("AdAgent Open interstitial ad", entry);
          this.resetInterstitialAdRequest();
          if (sys.isBrowser) {
            console.log("AdAgent Open interstitial ad in browser", entry);
            UIManager.instance.showToast('Open Inter Ad');
          } else {
            // Open interstitial ad
            console.log("AdAgent Open interstitial ad native", entry);
            this.currentInterstitialAdRequest.entry = entry;
            this.currentInterstitialAdRequest.callback = callback;
            ConnectAgent.openInterstitialAd(entry);
          }
        }
      }
      exports('AdAgent', AdAgent);
      _class = AdAgent;
      AdAgent.currentVideoAdRequest = {
        entry: "",
        revenued: false,
        callback: null,
        isStarted: false,
        retryCount: 0
      };
      AdAgent.currentInterstitialAdRequest = {
        entry: "",
        callback: null
      };
      AdAgent.videoAd = {
        onVideoAdStart: param => {
          LogUtil.log("AdAgent onVideoAdStart", param);
          _class.currentVideoAdRequest.isStarted = true;
          AudioManager.instance.pauseAll();
        },
        onVideoClick: param => {
          LogUtil.log("AdAgent onVideoClick", param);
        },
        onVideoNotReady: param => {
          LogUtil.log("AdAgent onVideoNotReady", param);
          if (_class.currentVideoAdRequest.retryCount == 0) {
            console.log("onVideoNotReady this.currentVideoAdRequest.retryCount == 0");
            _class.currentVideoAdRequest.retryCount++;
            UIManager.instance.open(UIID.Loading, {
              desc: "Loading...",
              displayTime: 5,
              onClose: () => {
                // Handle ad close
                console.log("onVideoNotReady this.currentVideoAdRequest.isStarted: ", console.log("onVideoNotReady this.currentVideoAdRequest.isStarted"));
                if (_class.currentVideoAdRequest.isStarted) {
                  return;
                }
                const entry = _class.currentVideoAdRequest.entry;
                ConnectAgent.openVideoAd(entry);
              }
            });
          } else {
            const entry = _class.currentVideoAdRequest.entry;
            const callback = _class.currentVideoAdRequest.callback;
            if (callback) {
              callback(entry, false);
            }
            UIManager.instance.showToast("Ad loading failed.");
            _class.resetVideoAdRequest();
          }
        },
        onVideoClosed: param => {
          LogUtil.log("AdAgent onVideoClosed", param);
          AudioManager.instance.resumeAll();
          const entry = param.entry;
          const callback = _class.currentVideoAdRequest.callback;
          _class.resetVideoAdRequest();
          if (callback) {
            callback(entry, false);
          }
        },
        onVideoComplete: param => {
          LogUtil.log("AdAgent onVideoComplete", param);
          AudioManager.instance.resumeAll();
          const entry = param.entry;
          const callback = _class.currentVideoAdRequest.callback;
          _class.resetVideoAdRequest();
          if (callback) {
            LogUtil.log("AdAgent onVideoComplete callback", entry);
            callback(entry, true);
          }
        },
        onAdRevenue: param => {
          LogUtil.log("AdAgent onAdRevenue", param);
        }
      };
      AdAgent.interstitialAd = {
        onInterstitialStart: param => {
          LogUtil.log("AdAgent onInterstitialStart", param);
          AudioManager.instance.pauseAll();
        },
        onInterstitialNotReady: param => {
          LogUtil.log("AdAgent onInterstitialNotReady", param);
          const entry = _class.currentInterstitialAdRequest.entry;
          const callback = _class.currentInterstitialAdRequest.callback;
          if (callback) {
            callback(entry, true);
          }
          UIManager.instance.showToast("Ad loading failed.");
          _class.resetInterstitialAdRequest();
        },
        onInterstitialClick: param => {},
        onInterstitialClosed: param => {
          AudioManager.instance.resumeAll();
          LogUtil.log("AdAgent onInterstitialClosed", param);
          const entry = param.entry;
          const callback = _class.currentInterstitialAdRequest.callback;
          if (callback) {
            callback(entry, true);
          }
          _class.resetInterstitialAdRequest();
        }
      };
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ad-btn.ts", ['cc', './game-data-manager.ts', './reward-manager.ts'], function (exports) {
  var cclegacy, Component, _decorator, GameDataManager, RewardManager;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Component = module.Component;
      _decorator = module._decorator;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      RewardManager = module.RewardManager;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "a5051lqP9NKjJ18QQ99F0e0", "ad-btn", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let ad_btn = exports('ad_btn', (_dec = ccclass('ad_btn'), _dec(_class = class ad_btn extends Component {
        start() {
          let config = RewardManager.instance.getConfig();
          let freeTime = config ? config.ad.free_times : 0;
          let icon = this.node.getChildByPath('Layout/AdIcon');
          icon.active = GameDataManager.instance.data.showAdTimes > freeTime;
        }
      }) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ad-manager.ts", ['cc', './gm-manager.ts', './game-data-manager.ts', './reward-manager.ts', './ad-agent.ts', './log-util.ts', './game-constants.ts', './report-agent.ts'], function (exports) {
  var cclegacy, director, GmManager, GameDataManager, RewardManager, AdAgent, LogUtil, GameEvent, ReportAgent, CustomReportEvent;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
    }, function (module) {
      GmManager = module.GmManager;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      RewardManager = module.RewardManager;
    }, function (module) {
      AdAgent = module.AdAgent;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      GameEvent = module.GameEvent;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
    }],
    execute: function () {
      cclegacy._RF.push({}, "f468ab2mhJBbI8OTLWimk1Q", "ad-manager", undefined);
      class AdManager {
        constructor() {
          this.isCdPlay = false;
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new AdManager();
          }
          return this._instance;
        }
        openVideoAd(entry, callback) {
          if (GmManager.instance.isSkipAd) {
            director.emit(GameEvent.PLAY_VIDEO_AD, 1);
            callback && callback(entry, true);
            return;
          }
          if (++GameDataManager.instance.data.showAdTimes <= RewardManager.instance.getConfig().ad.free_times) {
            callback && callback(entry, true);
            return;
          }
          AdAgent.openVideoAd(entry, (entry, success) => {
            if (GameDataManager.instance.data.showAdTimes == 0) {
              ReportAgent.reportCustomEvent(CustomReportEvent.WWY_GAME_LIFE_KEY_NODE, {
                step: 'first_ad'
              });
            }
            console.log(`AdAgent.openVideoAd-success: ${success}`);
            success && director.emit(GameEvent.PLAY_VIDEO_AD, 1);
            callback && callback(entry, success);
          });
        }
        openInterstitialAd(entry, callback) {
          while (true) {
            console.log(`AdManager openInterstitialAd-isSkipAd: ${GmManager.instance.isSkipAd}, isCdPlay: ${this.isCdPlay}`);
            if (GmManager.instance.isSkipAd || this.isCdPlay) break;
            let gdMgr = GameDataManager.instance;
            let config = RewardManager.instance.getConfig().ad.inter;
            if (!config) {
              LogUtil.error("AdManager openInterstitialAd interAdConfig is null");
              break;
            }
            let idx = gdMgr.data.loginDayNum;
            let skipTime = gdMgr.data.skipInterAdTime;
            let weight = gdMgr.data.interAdWeight;
            let weightLimit = config.show_weights.length > idx ? config.show_weights[idx] : config.show_weights[config.show_weights.length - 1];
            let skipTimeLimit = config.skip_times.length > idx ? config.skip_times[idx] : config.skip_times[config.skip_times.length - 1];
            console.log(`AdManager openInterstitialAd-weight: ${weight}, weightLimit: ${weightLimit}`);
            console.log(`AdManager openInterstitialAd-skipTime: ${skipTime}, skipTimeLimit: ${skipTimeLimit}`);
            console.log(`AdManager openInterstitialAd-cdTime: ${config.cd_time}`);
            if (weight >= weightLimit) {
              gdMgr.data.interAdWeight = 0;
              if (skipTime < skipTimeLimit) {
                gdMgr.data.skipInterAdTime++;
                break;
              }
              console.log(`AdManager openInterstitial do open inter`);
              AdAgent.openInterstitialAd(entry, (entry, success) => {
                console.log(`AdManager openInterstitialAd-cdTime: ${config.cd_time}`);
                this.isCdPlay = true;
                setTimeout(() => {
                  console.log(`AdManager openInterstitialAd cd ended.`);
                  this.isCdPlay = false;
                }, config.cd_time * 1000);
                if (success) {
                  ReportAgent.reportCustomEvent(CustomReportEvent.INTER_VIDEO_SCENE, {
                    insertlocation: `inter_${entry}`,
                    insertaction: 'succ'
                  });
                } else {
                  ReportAgent.reportCustomEvent(CustomReportEvent.INTER_VIDEO_SCENE, {
                    insertlocation: `inter_${entry}`,
                    insertaction: 'fail'
                  });
                }
                callback && callback(entry, success);
              });
              return;
            } else {
              break;
            }
          }
          callback && callback(entry, true);
        }
      }
      exports('AdManager', AdManager);
      AdManager._instance = null;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AHGNGYYNSSRZ.ts", ['cc', './SVDMRMIFJDYHRX.ts', './AQKTRMDQJQQBTDC.ts', './PQBRALKRA.ts', './WBKIRV.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, AQKTRMDQJQQBTDC, PQBRALKRA, KOOVAFDJSB;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      PQBRALKRA = module.PQBRALKRA;
    }, function (module) {
      KOOVAFDJSB = module.KOOVAFDJSB;
    }],
    execute: function () {
      cclegacy._RF.push({}, "1c966iNX5ZO5bqFZHKa/EAX", "AHGNGYYNSSRZ", undefined);
      class AHGNGYYNSSRZ extends SVDMRMIFJDYHRX {
        TGQXAKDAHFFVG() {}
        QIZLFVUQ() {}
        SGSRFUYPNBYVAVKD() {
          if (PQBRALKRA.OTORTMMYVD) {
            return "xx_xx";
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().ZZASVTSP(KOOVAFDJSB.SGSRFUYPNBYVAVKD);
        }
        JVXAKJXPKZRFU() {
          if (PQBRALKRA.OTORTMMYVD) {
            return "xx";
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().ZZASVTSP(KOOVAFDJSB.JVXAKJXPKZRFU);
        }
        OEASROCHK() {
          if (PQBRALKRA.OTORTMMYVD) {
            return "xx";
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().ZZASVTSP(KOOVAFDJSB.OEASROCHK);
        }
        PICLUI() {
          if (PQBRALKRA.OTORTMMYVD) {
            return "xxx";
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().ZZASVTSP(KOOVAFDJSB.NHSMDBRFZHTIBM);
        }
        CNTHTMQOWSI() {
          if (PQBRALKRA.OTORTMMYVD) {
            return "xxx";
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().ZZASVTSP(KOOVAFDJSB.YMWMKBGRWOKXYJ);
        }
      }
      exports('AHGNGYYNSSRZ', AHGNGYYNSSRZ);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AKHOCOQOOYH.ts", ['cc', './SVDMRMIFJDYHRX.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }],
    execute: function () {
      var _class;
      cclegacy._RF.push({}, "79d6cwtNlhJH4C8bSyUKjdc", "AKHOCOQOOYH", undefined);
      class AKHOCOQOOYH extends SVDMRMIFJDYHRX {
        static MSCGDWEHBPVJEQE() {
          return this.PFLPPIAESW;
        }
        TGQXAKDAHFFVG() {}
        QIZLFVUQ() {}
        onGameMethodPost(BOGJPOSYD, RHLVBGSUFSPJXHQB) {
          this.GHPCRSLJB.PWJDNMU(BOGJPOSYD, RHLVBGSUFSPJXHQB);
        }
      }
      exports('AKHOCOQOOYH', AKHOCOQOOYH);
      _class = AKHOCOQOOYH;
      AKHOCOQOOYH.PFLPPIAESW = new _class();
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/animation-canvas.ts", ['cc', './game-res-manager.ts', './card.ts', './log-util.ts'], function (exports) {
  var cclegacy, Component, UITransform, Vec3, Tween, _decorator, GameResManager, Card, CardArea, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Component = module.Component;
      UITransform = module.UITransform;
      Vec3 = module.Vec3;
      Tween = module.Tween;
      _decorator = module._decorator;
    }, function (module) {
      GameResManager = module.GameResManager;
    }, function (module) {
      Card = module.Card;
      CardArea = module.CardArea;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "4e894KG/xZK87/6lIWp1qsF", "animation-canvas", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let AnimationCanvas = exports('AnimationCanvas', (_dec = ccclass('AnimationCanvas'), _dec(_class = class AnimationCanvas extends Component {
        getCloneAnimCard(originNode, name = "") {
          var card = this.getExistAnimCard(originNode, name);
          if (!card) {
            // LogUtil.log('getCloneAnimCard - create new anim card');
            card = GameResManager.instance.getCardNode();
            const suit = originNode.getComponent(Card).cardSuit;
            const point = originNode.getComponent(Card).cardPoint;
            card.name = name !== "" ? name : originNode.getComponent(Card).key;
            card.getComponent(Card).setCardData('anim', originNode.getComponent(Card).cardData);
            card.getComponent(Card).setArea(CardArea.ANIM_CANVAS);
            card.getComponent(Card).disableClick();
            card.position = this.getComponent(UITransform).convertToNodeSpaceAR(originNode.getComponent(UITransform).convertToWorldSpaceAR(new Vec3(0, 0, 0)));
            card.active = true;
            this.node.addChild(card);
          } else {
            LogUtil.log('getCloneAnimCard - getExistAnimCard', card.name, name);
            const currentPos = card.position.clone();
            Tween.stopAllByTarget(card);
            card.position = currentPos;
          }
          return card;
        }
        getExistAnimCard(originNode, name = "") {
          if (name === "") {
            name = originNode.getComponent(Card).key;
          }
          return this.node.getChildByName(name);
        }
      }) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/animation-util.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "a1055uq22tIe7mDT26BlgZe", "animation-util", undefined);
      class AnimtionUtil {}
      exports('AnimtionUtil', AnimtionUtil);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/AQKTRMDQJQQBTDC.ts", ['cc', './CIVTVAVXRORTVD.ts', './WBKIRV.ts', './PZCMUYBUB.ts'], function (exports) {
  var cclegacy, native, VERSION, CIVTVAVXRORTVD, KOOVAFDJSB, PZCMUYBUB;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      native = module.native;
      VERSION = module.VERSION;
    }, function (module) {
      CIVTVAVXRORTVD = module.CIVTVAVXRORTVD;
    }, function (module) {
      KOOVAFDJSB = module.KOOVAFDJSB;
    }, function (module) {
      PZCMUYBUB = module.PZCMUYBUB;
    }],
    execute: function () {
      var _class;
      cclegacy._RF.push({}, "3047aCGy35Im4a9FcEF+hzd", "AQKTRMDQJQQBTDC", undefined);
      class AQKTRMDQJQQBTDC {
        constructor() {
          this.TYAXQESPGDSRGBOS = "";
          this.UHTYUGBDSDM = "";
          this.WRAFJTHXGRDNODO = "";
          this.LTRYSYBPP = "";
          this.MDCTJFAPWXRIFON = 1;
          this.TYAXQESPGDSRGBOS = CIVTVAVXRORTVD.TYAXQESPGDSRGBOS;
          this.UHTYUGBDSDM = CIVTVAVXRORTVD.UHTYUGBDSDM;
          this.WRAFJTHXGRDNODO = CIVTVAVXRORTVD.WRAFJTHXGRDNODO;
          this.LTRYSYBPP = CIVTVAVXRORTVD.LTRYSYBPP;
          this.MDCTJFAPWXRIFON = CIVTVAVXRORTVD.MDCTJFAPWXRIFON;
        }
        JUZTNZHN(str) {
          let hash = 0;
          for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = hash * 31 + char | 0; // Use bitwise OR to coerce to 32 bits
          }

          return hash;
        }
        OFFOKOFJKQJKUV(pgName) {
          PZCMUYBUB.MSCGDWEHBPVJEQE().IYYWPVKZ(pgName);
          let pg = pgName;
          let v = this.TYAXQESPGDSRGBOS;
          let vParts = v.split('.');
          let targetPackageName = vParts.slice(0, -1).join('.');
          let newTargetClassName = "";
          const randomStr = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
          let seedHash = Math.abs(this.JUZTNZHN(pg));
          const classLen = seedHash % 6;
          for (let i = 0; i < classLen + 2; i++) {
            let c = randomStr[seedHash % randomStr.length];
            newTargetClassName = newTargetClassName + c;
            seedHash = Math.abs(this.JUZTNZHN(pg + newTargetClassName));
          }
          this.TYAXQESPGDSRGBOS = `${targetPackageName}.${newTargetClassName}`;
        }
        YFQWTUEZ(src) {
          return PZCMUYBUB.MSCGDWEHBPVJEQE().YFQWTUEZ(src);
        }
        static MSCGDWEHBPVJEQE() {
          return this.BPVANCXHADQJFIH;
        }

        /**
         * 后续统一使用一个方法
         * @param funcName
         * @param param
         */
        AOVABTCV(funcName, param) {
          return native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ("allOneMethod"), "(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;", funcName, param, this.UHTYUGBDSDM);
        }
        WTPEMNO(pg) {
          let initData = {
            "engine": "cocos",
            "engine_ver": VERSION,
            "sdk_ver": this.LTRYSYBPP,
            "sdk_ver_code": this.MDCTJFAPWXRIFON,
            "api_name": this.UHTYUGBDSDM,
            "api_method": this.WRAFJTHXGRDNODO
          };
          let jsonData = JSON.stringify(initData);
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.WTPEMNO), "(Ljava/lang/String;)V", jsonData);
        }
        IUVEANIFARSRGVJN(entry) {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.IUVEANIFARSRGVJN), "(Ljava/lang/String;)V", entry);
        }
        LHAKYKQVTTJC(entry) {
          return native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.LHAKYKQVTTJC), "(Ljava/lang/String;)Z", entry);
        }
        WUMMTYU(entry) {
          return native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.WUMMTYU), "(Ljava/lang/String;)Z", entry);
        }
        PYQUCSIIH(entry) {
          return native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.PYQUCSIIH), "(Ljava/lang/String;)Z", entry);
        }
        XOUECKSDJND(entry) {
          return native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.XOUECKSDJND), "(Ljava/lang/String;)Z", entry);
        }
        EBZYRKYXFPTJCTAV() {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.EBZYRKYXFPTJCTAV), "()V");
        }
        OASGKQN(data) {
          let jsonData = JSON.stringify(data);
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.OASGKQN), "(Ljava/lang/String;)V", jsonData);
        }
        PQGKDUTERGR(type, event, data) {
          let jsonData = JSON.stringify(data);
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.PQGKDUTERGR), "(ILjava/lang/String;Ljava/lang/String;)V", type, event, jsonData);
        }
        MRVQRTO(pg) {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.MRVQRTO), "(Ljava/lang/String;)V", pg);
        }
        COUYOLVIRRJBJ(url) {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.COUYOLVIRRJBJ), "(Ljava/lang/String;)V", url);
        }
        ZZASVTSP(key) {
          return native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.ZZASVTSP), "(Ljava/lang/String;)Ljava/lang/String;", key);
        }
        PYYQVT(debug) {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.SGBOHXNFGG), "(Z)V", debug);
        }
        XEULDAXPQAIRUU(key) {
          return native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.BJYHQFJF), "(Ljava/lang/String;)Ljava/lang/String;", key);
        }
        JLRWRON(type, gravity, margin) {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.JLRWRON), "(III)V", type, gravity, margin);
        }
        WCTLPPBLHMRT(type) {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.WCTLPPBLHMRT), "(I)V", type);
        }
        WBZHMHO() {
          return native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.WBZHMHO), "()Z");
        }
        UENVUHZR(entry) {
          return native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.UENVUHZR), "(Ljava/lang/String;)Z", entry);
        }
        RFFCNTYYDMN(msgId, EYAVKOOZUR, XCCJOIFFXZSMLHIV, QYAQVVYEJXYTTJBV) {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.RFFCNTYYDMN), "(ILjava/lang/String;Ljava/lang/String;Ljava/lang/String;)V", msgId, EYAVKOOZUR, XCCJOIFFXZSMLHIV, QYAQVVYEJXYTTJBV);
        }
        UZSJLDEBYEZI(placementId, width, height, left, top) {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.UZSJLDEBYEZI), "(Ljava/lang/String;IIII)V", placementId, width, height, left, top);
        }
        BLERBUWYZ(placementId) {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.BLERBUWYZ), "(Ljava/lang/String;)V", placementId);
        }

        // 支付相关
        GMKDDMWDSNPUI() {
          return native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.GMKDDMWDSNPUI), "()Z");
        }
        MSNKSNM(WFWKYY, HMESZBR = "") {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.MSNKSNM), "(Ljava/lang/String;Ljava/lang/String;)V", WFWKYY, HMESZBR);
        }
        VAUYGPMBKOFFKTU(WFWKYY, HMESZBR = "", ZMRFXFMBU, RKEKGN) {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.MSNKSNM), "(Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)V", WFWKYY, HMESZBR, ZMRFXFMBU, RKEKGN);
        }
        RRUWUVYQ(XNFWLZDKNEA) {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.RRUWUVYQ), "(Ljava/lang/String;)V", XNFWLZDKNEA);
        }
        NMZERFYOQXXOW() {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.NMZERFYOQXXOW), "()V");
        }
        QQCBWIIBSGJMZXXV() {
          native.reflection.callStaticMethod(this.TYAXQESPGDSRGBOS, this.YFQWTUEZ(KOOVAFDJSB.QQCBWIIBSGJMZXXV), "()V");
        }
      }
      exports('AQKTRMDQJQQBTDC', AQKTRMDQJQQBTDC);
      _class = AQKTRMDQJQQBTDC;
      AQKTRMDQJQQBTDC.BPVANCXHADQJFIH = new _class();
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/array-util.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "f0df3r4p5xMno0WZOtHPfhL", "array-util", undefined);
      class ArrayUtil {
        static mergeFrom(to, from) {
          if (to == null || from == null) {
            return;
          }
          for (var key in from) {
            let value = from[key];
            if (value == null) continue;
            if (typeof value == 'undefined') continue;
            if (value && to[key] && value instanceof Object && key in to) {
              this.mergeFrom(to[key], value);
            } else {
              to[key] = value;
            }
          }
        }
      }
      exports('ArrayUtil', ArrayUtil);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/audio-effect-pool.ts", ['cc', './res-loader.ts', './audio-effect.ts', './audio-manager.ts'], function (exports) {
  var cclegacy, NodePool, AudioClip, Node, resLoader, AudioEffect, AudioManager;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      NodePool = module.NodePool;
      AudioClip = module.AudioClip;
      Node = module.Node;
    }, function (module) {
      resLoader = module.resLoader;
    }, function (module) {
      AudioEffect = module.AudioEffect;
    }, function (module) {
      AudioManager = module.AudioManager;
    }],
    execute: function () {
      cclegacy._RF.push({}, "fa128D8ijlKX7t5BOCHJFV4", "audio-effect-pool", undefined);
      const AE_ID_MAX = 30000;

      /** 音效池 */
      class AudioEffectPool {
        constructor() {
          this._switch = true;
          this._volume = 1;
          /** 音效播放器对象池 */
          this.pool = new NodePool();
          this.maxPoolSize = 10;
          /** 对象池集合 */
          this.effects = new Map();
          /** 用过的音效资源记录 */
          this.res = new Map();
          this._aeId = 0;
        }
        /** 音效开关 */
        get switch() {
          return this._switch;
        }
        set switch(value) {
          this._switch = value;
          if (value) this.stop();
        }
        /** 所有音效音量 */
        get volume() {
          return this._volume;
        }
        set volume(value) {
          this._volume = value;
          this.effects.forEach(ae => {
            ae.volume = value;
          });
        }
        /** 获取请求唯一编号 */
        getAeId() {
          if (this._aeId == AE_ID_MAX) this._aeId = 1;
          this._aeId++;
          return this._aeId;
        }

        /**
         * 加载与播放音效
         * @param url                  音效资源地址与音效资源
         * @param bundleName           资源包名
         * @param onPlayComplete       播放完成回调
         * @returns 
         */
        async load(url, bundleName = resLoader.defaultBundleName, onPlayComplete) {
          return new Promise(async (resolve, reject) => {
            if (!this.switch) return resolve(-1);

            // 创建音效资源
            let clip;
            if (url instanceof AudioClip) {
              clip = url;
            } else {
              clip = resLoader.get(url, AudioClip, bundleName);
              if (!clip) {
                this.res.set(bundleName, url);
                clip = await resLoader.loadAsync(bundleName, url, AudioClip);
              }
            }

            // 资源已被释放
            if (!clip.isValid) {
              resolve(-1);
              return;
            }
            let aeid = this.getAeId();
            let key;
            if (url instanceof AudioClip) {
              key = url.uuid;
            } else {
              key = `${bundleName}_${url}`;
            }
            key += "_" + aeid;

            // 获取音效果播放器播放音乐
            let ae;
            let node = null;
            if (this.pool.size() == 0) {
              node = new Node();
              node.name = "AudioEffect";
              node.parent = AudioManager.instance.persist;
              ae = node.addComponent(AudioEffect);
            } else {
              node = this.pool.get();
              ae = node.getComponent(AudioEffect);
            }
            ae.onComplete = () => {
              this.put(aeid, url, bundleName); // 播放完回收对象
              onPlayComplete && onPlayComplete();
              // LogUtil.log(`【音效】回收，池中剩余音效播放器【${this.pool.size()}】`);
            };

            // 记录正在播放的音效播放器
            this.effects.set(key, ae);
            ae.volume = this.volume;
            ae.clip = clip;
            ae.play();
            resolve(aeid);
          });
        }

        /**
         * 回收音效播放器
         * @param aeid          播放器编号
         * @param url           音效路径
         * @param bundleName    资源包名
         */
        put(aeid, url, bundleName = resLoader.defaultBundleName) {
          let key;
          if (url instanceof AudioClip) {
            key = url.uuid;
          } else {
            key = `${bundleName}_${url}`;
          }
          key += "_" + aeid;
          let ae = this.effects.get(key);
          if (ae && ae.clip) {
            this.effects.delete(key);
            ae.stop();
            if (this.maxPoolSize < this.pool.size()) {
              ae.node.destroy();
            } else {
              this.pool.put(ae.node);
            }
          }
        }

        /** 释放所有音效资源与对象池中播放器 */
        release() {
          // 释放正在播放的音效
          this.effects.forEach(ae => {
            ae.node.destroy();
          });
          this.effects.clear();

          // 释放音效资源
          this.res.forEach((url, bundleName) => {
            resLoader.release(bundleName, url);
          });

          // 释放池中播放器
          this.pool.clear();
        }

        /** 停止播放所有音效 */
        stop() {
          this.effects.forEach(ae => {
            ae.stop();
          });
        }

        /** 恢复所有音效 */
        play() {
          if (!this.switch) return;
          this.effects.forEach(ae => {
            ae.play();
          });
        }

        /** 暂停所有音效 */
        pause() {
          if (!this.switch) return;
          this.effects.forEach(ae => {
            ae.pause();
          });
        }
      }
      exports('AudioEffectPool', AudioEffectPool);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/audio-effect.ts", ['cc'], function (exports) {
  var cclegacy, AudioSource, _decorator;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      AudioSource = module.AudioSource;
      _decorator = module._decorator;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "123ecDmta5FfqmLtpkj2FwD", "audio-effect", undefined);
      const {
        ccclass
      } = _decorator;

      /** 游戏音效 */
      let AudioEffect = exports('AudioEffect', (_dec = ccclass('AudioEffect'), _dec(_class = class AudioEffect extends AudioSource {
        constructor(...args) {
          super(...args);
          /** 背景音乐播放完成回调 */
          this.onComplete = null;
        }
        start() {
          this.node.on(AudioSource.EventType.ENDED, this.onAudioEnded, this);
        }
        onAudioEnded() {
          this.onComplete && this.onComplete();
        }
      }) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/audio-manager.ts", ['cc', './audio-music.ts', './audio-effect-pool.ts', './storage-manager.ts'], function (exports) {
  var cclegacy, Node, director, AudioMusic, AudioEffectPool, StorageManager;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      director = module.director;
    }, function (module) {
      AudioMusic = module.AudioMusic;
    }, function (module) {
      AudioEffectPool = module.AudioEffectPool;
    }, function (module) {
      StorageManager = module.StorageManager;
    }],
    execute: function () {
      cclegacy._RF.push({}, "5588bgHO91DrJ4w6aJ5dRBL", "audio-manager", undefined);
      const LOCAL_STORE_KEY = "game_audio";

      /*
      *   音频管理器
      *   
      *   2018-9-20
      */
      class AudioManager {
        constructor() {
          this.persist = null;
          this.music = null;
          this.effect = new AudioEffectPool();
          /** 音乐管理状态数据 */
          this.local_data = {};
          this._switchVibration = false;
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new AudioManager();
            this._instance.init();
          }
          return this._instance;
        }
        init() {
          this.persist = new Node("AudioPersistNode");
          director.addPersistRootNode(this.persist);
          this.load();
        }

        /**
         * 设置背景音乐播放完成回调
         * @param callback 背景音乐播放完成回调
         */
        setMusicComplete(callback = null) {
          this.music.onComplete = callback;
        }

        /**
         * 播放背景音乐
         * @param url        资源地址
         * @param callback   音乐播放完成事件
         * @param bundleName 资源包名
         */
        playMusic(url, callback, bundleName) {
          if (this.music.switch) {
            this.music.loop = false;
            this.music.load(url, callback, bundleName).then();
          }
        }

        /** 循环播放背景音乐 */
        playMusicLoop(url, bundleName) {
          if (this.music.switch) {
            this.music.loop = true;
            this.music.load(url, null, bundleName).then();
          }
        }

        /** 停止背景音乐播放 */
        stopMusic() {
          this.music.stop();
        }

        /**
         * 获取背景音乐播放进度
         */
        get progressMusic() {
          return this.music.progress;
        }

        /**
         * 设置背景乐播放进度
         * @param value     播放进度值
         */
        set progressMusic(value) {
          this.music.progress = value;
        }

        /**
         * 获取背景音乐音量
         */
        get volumeMusic() {
          return this.music.volume;
        }

        /**
         * 设置背景音乐音量
         * @param value     音乐音量值
         */
        set volumeMusic(value) {
          this.music.volume = value;
          this.save();
        }

        /**
         * 获取背景音乐开关值
         */
        get switchMusic() {
          return this.music.switch;
        }

        /**
         * 设置背景音乐开关值
         * @param value     开关值
         */
        set switchMusic(value) {
          this.music.switch = value;
          !value && this.music.stop();
          this.save();
        }

        /**
         * 播放音效
         * @param url        资源地址
         * @param callback   加载完成回调
         * @param bundleName 资源包名
         */
        playEffect(url, bundleName, onPlayComplete) {
          return this.effect.load(url, bundleName, onPlayComplete);
        }

        /** 回收音效播放器 */
        putEffect(aeid, url, bundleName) {
          this.effect.put(aeid, url, bundleName);
        }

        /** 获取音效音量 */
        get volumeEffect() {
          return this.effect.volume;
        }

        /**
         * 设置获取音效音量
         * @param value     音效音量值
         */
        set volumeEffect(value) {
          this.effect.volume = value;
          this.save();
        }

        /** 获取音效开关值 */
        get switchEffect() {
          return this.effect.switch;
        }

        /**
         * 设置音效开关值
         * @param value     音效开关值
         */
        set switchEffect(value) {
          this.effect.switch = value;
          if (!value) this.effect.stop();
          this.save();
        }
        set switchVibration(value) {
          this._switchVibration = value;
          this.save();
        }
        get switchVibration() {
          return this._switchVibration;
        }

        /** 恢复当前暂停的音乐与音效播放 */
        resumeAll() {
          if (this.music.switch) {
            if (!this.music.playing) this.music.play();
          }
          if (this.effect.switch) {
            this.effect.play();
          }
        }

        /** 暂停当前音乐与音效的播放 */
        pauseAll() {
          if (this.music.playing) this.music.pause();
          this.effect.pause();
        }

        /** 停止当前音乐与音效的播放 */
        stopAll() {
          this.music.stop();
          this.effect.stop();
        }

        /** 保存音乐音效的音量、开关配置数据到本地 */
        save() {
          this.local_data.volume_music = this.music.volume;
          this.local_data.volume_effect = this.effect.volume;
          this.local_data.switch_music = this.music.switch;
          this.local_data.switch_effect = this.effect.switch;
          this.local_data.switch_vibration = this._switchVibration;
          StorageManager.instance.set(LOCAL_STORE_KEY, this.local_data);
        }

        /** 本地加载音乐音效的音量、开关配置数据并设置到游戏中 */
        load() {
          var _this$persist, _this$persist2;
          this.music = ((_this$persist = this.persist) == null ? void 0 : _this$persist.getComponent(AudioMusic)) || ((_this$persist2 = this.persist) == null ? void 0 : _this$persist2.addComponent(AudioMusic));
          this.local_data = StorageManager.instance.getJson(LOCAL_STORE_KEY);
          if (this.local_data) {
            try {
              this.setState();
            } catch {
              this.setStateDefault();
            }
          } else {
            this.setStateDefault();
          }
        }
        setState() {
          this.music.volume = this.local_data.volume_music;
          this.effect.volume = this.local_data.volume_effect;
          this.music.switch = this.local_data.switch_music;
          this.effect.switch = this.local_data.switch_effect;
          this.switchVibration = this.local_data.switch_vibration;
        }
        setStateDefault() {
          this.local_data = {};
          this.music.volume = 1;
          this.effect.volume = 1;
          this.music.switch = true;
          this.effect.switch = true;
          this.switchVibration = true;
        }
      }
      exports('AudioManager', AudioManager);
      AudioManager._instance = void 0;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/audio-music.ts", ['cc', './res-loader.ts'], function (exports) {
  var cclegacy, AudioSource, AudioClip, _decorator, resLoader;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      AudioSource = module.AudioSource;
      AudioClip = module.AudioClip;
      _decorator = module._decorator;
    }, function (module) {
      resLoader = module.resLoader;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "9e83d5mi6lL/4JLcrqWl5B8", "audio-music", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let AudioMusic = exports('AudioMusic', (_dec = ccclass('AudioMusic'), _dec(_class = class AudioMusic extends AudioSource {
        constructor(...args) {
          super(...args);
          /** 背景音乐开关 */
          this.switch = true;
          /** 背景音乐播放完成回调 */
          this.onComplete = null;
          this._progress = 0;
          this._isLoading = false;
          this._nextBundleName = null;
          // 下一个音乐资源包
          this._nextUrl = null;
        }
        // 下一个播放音乐

        start() {
          // this.node.on(AudioSource.EventType.STARTED, this.onAudioStarted, this);
          this.node.on(AudioSource.EventType.ENDED, this.onAudioEnded, this);
        }

        // private onAudioStarted() { }

        onAudioEnded() {
          this.onComplete && this.onComplete();
        }

        /** 获取音乐播放进度 */
        get progress() {
          if (this.duration > 0) this._progress = this.currentTime / this.duration;
          return this._progress;
        }
        /**
         * 设置音乐当前播放进度
         * @param value     进度百分比0到1之间
         */
        set progress(value) {
          this._progress = value;
          this.currentTime = value * this.duration;
        }

        /**
         * 加载音乐并播放
         * @param url          音乐资源地址
         * @param callback     加载完成回调
         * @param bundleName   资源包名
         */
        async load(url, callback, bundleName = resLoader.defaultBundleName) {
          // 下一个加载的背景音乐资源
          if (this._isLoading) {
            this._nextBundleName = bundleName;
            this._nextUrl = url;
            return;
          }
          this._isLoading = true;
          var clip = await resLoader.loadAsync(bundleName, url, AudioClip);
          if (clip) {
            this._isLoading = false;

            // 处理等待加载的背景音乐
            if (this._nextUrl != null) {
              // 加载等待播放的背景音乐
              this.load(this._nextUrl, callback, this._nextBundleName);
              this._nextBundleName = this._nextUrl = null;
            } else {
              callback && callback();

              // 正在播放的时候先关闭
              if (this.playing) {
                this.stop();
              }

              // 删除当前正在播放的音乐
              this.release();

              // 播放背景音乐
              this.clip = clip;
              this.play();
            }
          }
        }

        /** 释放当前背景音乐资源 */
        release() {
          if (this.clip) {
            this.stop();
            this.clip.decRef();
            this.clip = null;
          }
        }
      }) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/bezier-util.ts", ['cc', './log-util.ts'], function (exports) {
  var cclegacy, Vec3, tween, Quat, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Vec3 = module.Vec3;
      tween = module.tween;
      Quat = module.Quat;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      cclegacy._RF.push({}, "beb34WNkXxD46+D4biG9aBO", "bezier-util", undefined);
      class BezierUtil {
        static calculateBezierLength(p0, p1, p2) {
          const segments = 300; // 分段数，越大越精确
          let length = 0;
          let previousPoint = p0;
          for (let i = 1; i <= segments; i++) {
            const t = i / segments;
            const currentPoint = this.calculateBezierPoint(p0, p1, p2, t);
            length += Vec3.distance(previousPoint, currentPoint);
            previousPoint = currentPoint;
          }
          return length;
        }
        static calculateBezierPoint(p0, p1, p2, t) {
          const x = (1 - t) * (1 - t) * p0.x + 2 * (1 - t) * t * p1.x + t * t * p2.x;
          const y = (1 - t) * (1 - t) * p0.y + 2 * (1 - t) * t * p1.y + t * t * p2.y;
          const z = (1 - t) * (1 - t) * p0.z + 2 * (1 - t) * t * p1.z + t * t * p2.z;
          return new Vec3(x, y, z);
        }
        static moveNodeAlongBezier(node, startPos, controlPos, endPos, speed, endScale, endRotation) {
          return new Promise((resolve, reject) => {
            const totalDistance = this.calculateBezierLength(startPos, controlPos, endPos);
            const totalTime = totalDistance / speed;
            const startScale = node.scale.clone();
            const startRotation = node.rotation.clone();
            let currentT = 0;
            tween({
              t: 0
            }).to(totalTime, {
              t: 1
            }, {
              onUpdate: target => {
                currentT = target.t;
                const pos = this.calculateBezierPoint(startPos, controlPos, endPos, currentT);
                node.position = pos;
                const newScaleX = startScale.x + (endScale.x - startScale.x) * currentT;
                const newScaleY = startScale.y + (endScale.y - startScale.y) * currentT;
                const newScaleZ = startScale.z + (endScale.z - startScale.z) * currentT;
                node.setScale(newScaleX, newScaleY, newScaleZ);
                const newRotation = new Quat();
                Quat.slerp(newRotation, startRotation, endRotation, currentT);
                node.setRotation(newRotation);
              },
              easing: "linear"
            }).call(() => {
              LogUtil.log("Movement completed");
              resolve();
            }).start();
          });
        }
      }
      exports('BezierUtil', BezierUtil);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/bg-adapter.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, _decorator, Component, Sprite, UITransform, view;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      _decorator = module._decorator;
      Component = module.Component;
      Sprite = module.Sprite;
      UITransform = module.UITransform;
      view = module.view;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "e1e0baOM2ZMoqkBG46fEABQ", "bg-adapter", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let BgAdapter = exports('BgAdapter', (_dec = ccclass('BgAdapter'), _dec2 = property(Node), _dec(_class = (_class2 = class BgAdapter extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "target", _descriptor, this);
        }
        updateSize() {
          let frame = this.node.getComponent(Sprite).spriteFrame;
          if (!frame) return;
          let texture = frame.texture;
          if (!texture) return;
          let w_t = texture.width;
          let h_t = texture.height;
          let height = this.target ? this.target.getComponent(UITransform).height + 20 : view.getVisibleSize().height;
          let width = this.target ? this.target.getComponent(UITransform).width + 20 : view.getVisibleSize().width;
          let aspectRatioheight = height / h_t;
          let aspectRatioWidth = width / w_t;
          let targetAspectRatio = Math.max(aspectRatioheight, aspectRatioWidth);
          let newwidth = Math.floor(targetAspectRatio * w_t);
          let newheight = Math.floor(targetAspectRatio * h_t);
          // this.node.getComponent(UITransform).setContentSize(w_n, height);

          this.node.getComponent(UITransform).setContentSize(newwidth, newheight);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "target", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/bridge-event.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "d60dbJoo8tDdom5emT251lj", "bridge-event", undefined);
      let BridgeEvent = exports('BridgeEvent', /*#__PURE__*/function (BridgeEvent) {
        BridgeEvent["on_vibrate"] = "on_vibrate";
        BridgeEvent["on_page_rc"] = "on_page_rc";
        BridgeEvent["on_native_info"] = "on_native_info";
        BridgeEvent["on_scene_ready"] = "on_scene_ready";
        BridgeEvent["on_send_mail"] = "on_send_mail";
        BridgeEvent["on_save_album"] = "on_save_album";
        BridgeEvent["on_save_album_result"] = "on_save_album_result";
        BridgeEvent["on_rating"] = "on_rating";
        BridgeEvent["on_connect_event"] = "on_connect_event";
        BridgeEvent["sdk_ad_reward"] = "sdk_ad_reward";
        BridgeEvent["sdk_ad_inters"] = "sdk_ad_inters";
        BridgeEvent["sdk_report_data"] = "sdk_report_data";
        BridgeEvent["sdk_init"] = "sdk_init";
        BridgeEvent["sdk_ad_debug"] = "sdk_ad_debug";
        return BridgeEvent;
      }({}));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/bridge-manager.ts", ['cc', './bridge-event.ts', './config.ts', './log-util.ts', './connect-agent.ts'], function (exports) {
  var cclegacy, native, BridgeEvent, Config, LogUtil, ConnectAgent;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      native = module.native;
    }, function (module) {
      BridgeEvent = module.BridgeEvent;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      ConnectAgent = module.ConnectAgent;
    }],
    execute: function () {
      cclegacy._RF.push({}, "4ef0fxQINBHOokY1IY/jh0U", "bridge-manager", undefined);
      class BridgeManager {
        constructor() {
          this.saveToAlbumCallback = void 0;
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new BridgeManager();
          }
          return this._instance;
        }
        setSaveToAlbumCallback(callback) {
          this.saveToAlbumCallback = callback;
        }
        setupNativeEventListner(onNativeBindedCallback) {
          if (native && native.jsbBridgeWrapper) {
            native.jsbBridgeWrapper.addNativeEventListener("on_native_info", args => {
              this.onNativeInfo(args);
              onNativeBindedCallback && onNativeBindedCallback();
            });
            native.jsbBridgeWrapper.addNativeEventListener("on_connect_event", args => this.onNativeConnectEvent(args));
            native.jsbBridgeWrapper.addNativeEventListener("on_save_album_result", args => this.onNativeSaveAlbumResult(args));
            native.jsbBridgeWrapper.dispatchEventToNative(BridgeEvent.on_scene_ready);
          } else {
            console.error("native.jsbBridgeWrapper is null");
            onNativeBindedCallback && onNativeBindedCallback();
          }
        }
        onNativeInfo(args) {
          LogUtil.log("beyond2 onNativeInfo", args);
          const data = JSON.parse(args);
          Config.MEM = data.mem;
          Config.DEBUG = data.debug;
          Config.GAME_VERSION = data.version;
          Config.LANG_CODE = data.lang;
          Config.COUNTRY_CODE = data.country;
          Config.GAME_UUID = data.game_uuid;
          Config.PACKAGE = data.package;
          Config.API_URL = data.api_host;
          // Config.SG_GRAPH_HOST = .sg_graph_host;
        }

        onNativeConnectEvent(args) {
          LogUtil.log("onNativeConnectEvent", args);
          ConnectAgent.onConnectEvent(args);
        }
        onNativeSaveAlbumResult(args) {
          LogUtil.log("onNativeSaveAlbumResult", args);
          this.saveToAlbumCallback && this.saveToAlbumCallback(args === "true");
        }

        // setupNativeEventListner(onNativeBindedCallback: () => void) {
        //     if (native && native.bridge) {
        //         native.bridge.onNative = function (arg0: string, arg1: string) {
        //             if (arg0 === BridgeEvent.on_page_rc) {
        //                 MountManager.instance.notify(MountPoint.NativeNotifyPageRc, arg1);
        //             } else if (arg0 === BridgeEvent.on_native_info) {
        //                 // 
        //                 LogUtil.log("on_native_info", arg1);
        //                 const data = JSON.parse(arg1);
        //                 Config.MEM = data.mem;
        //                 Config.DEBUG = data.debug;
        //                 Config.GAME_VERSION = data.version;
        //                 Config.LANG_CODE = data.lang;
        //                 Config.COUNTRY_CODE = data.country;
        //                 Config.GAME_UUID = data.game_uuid;
        //                 Config.PACKAGE = data.package;
        //                 Config.API_URL = data.api_host;
        //                 // Config.SG_GRAPH_HOST = .sg_graph_host;
        //                 onNativeBindedCallback && onNativeBindedCallback();
        //             } else if (arg0 === BridgeEvent.on_save_album_result) {
        //                 BridgeManager.instance.saveToAlbumCallback && BridgeManager.instance.saveToAlbumCallback(arg1 === "true");
        //             } else if (arg0 === BridgeEvent.on_connect_event) {
        //                 // 
        //                 LogUtil.log("on_connect_event", arg1);
        //                 ConnectAgent.onConnectEvent(arg1);
        //             }
        //         };

        //         native.bridge.sendToNative(BridgeEvent.on_scene_ready);
        //     } else {
        //         console.error("native.bridge is null");
        //         onNativeBindedCallback && onNativeBindedCallback();
        //     }
        // }
      }
      exports('BridgeManager', BridgeManager);
      BridgeManager._instance = void 0;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/bridge-util.ts", ['cc', './audio-manager.ts', './bridge-event.ts', './graph-manager.ts', './bridge-manager.ts', './game-data-manager.ts', './game-data-type-define.ts', './native-agent.ts'], function (exports) {
  var cclegacy, native, sys, AudioManager, BridgeEvent, GraphManager, BridgeManager, GameDataManager, SgState, NativeAgent;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      native = module.native;
      sys = module.sys;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      BridgeEvent = module.BridgeEvent;
    }, function (module) {
      GraphManager = module.GraphManager;
    }, function (module) {
      BridgeManager = module.BridgeManager;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      SgState = module.SgState;
    }, function (module) {
      NativeAgent = module.NativeAgent;
    }],
    execute: function () {
      cclegacy._RF.push({}, "fa7efx5gDpLmqMTl5Pe9mwm", "bridge-util", undefined);
      let VibrationEffect = exports('VibrationEffect', /*#__PURE__*/function (VibrationEffect) {
        VibrationEffect[VibrationEffect["DEFAULT"] = -1] = "DEFAULT";
        VibrationEffect[VibrationEffect["TICK"] = 2] = "TICK";
        VibrationEffect[VibrationEffect["CLICK"] = 0] = "CLICK";
        VibrationEffect[VibrationEffect["DOUBLE_CLICK"] = 1] = "DOUBLE_CLICK";
        VibrationEffect[VibrationEffect["HEAVY_CLICK"] = 5] = "HEAVY_CLICK";
        return VibrationEffect;
      }({}));
      class BridgeUtil {
        static vibrate(duration, effect) {
          if (!AudioManager.instance.switchVibration) return;
          if (native && native.bridge) {
            const param = {
              d: duration,
              e: effect
            };
            NativeAgent.dispatchEventToNative(BridgeEvent.on_vibrate, JSON.stringify(param));
          }
        }
        static sendMail(to, subject, body) {
          if (native && native.bridge) {
            const param = {
              to: to,
              subject: subject,
              body: body
            };
            NativeAgent.dispatchEventToNative(BridgeEvent.on_send_mail, JSON.stringify(param));
          }
        }
        static saveToAlbum(url) {
          if (!sys.isNative) {
            return Promise.resolve(false);
          }
          if (GameDataManager.instance.sg.state === SgState.Started) {
            return new Promise(resolve => {
              // start download graph
              GraphManager.instance.loadGraphToBase64(url).then(base64 => {
                if (!base64) {
                  console.log('saveToAlbum base64 is null');
                  resolve(false);
                  return;
                }
                BridgeManager.instance.setSaveToAlbumCallback(success => {
                  resolve(success);
                });
                NativeAgent.dispatchEventToNative(BridgeEvent.on_save_album, base64);
              });
            });
          }
        }
        static openRating() {
          if (native && native.bridge) {
            NativeAgent.dispatchEventToNative(BridgeEvent.on_rating, "");
          }
        }
      }
      exports('BridgeUtil', BridgeUtil);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/BSCTBWK.ts", ['cc', './TTINOQH.ts'], function (exports) {
  var cclegacy, TTINOQH;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      TTINOQH = module.TTINOQH;
    }],
    execute: function () {
      cclegacy._RF.push({}, "37490v5PmNK0qXjgXg0qf14", "BSCTBWK", undefined);
      class BSCTBWK extends TTINOQH {
        constructor(...args) {
          super(...args);
          // private _Instance: BaseDispatcher = null;
          // get Instance(): BaseDispatcher{
          //     if (this._Instance == null){
          //         return BaseDispatcher.getInstance<BaseDispatcher>();
          //     }
          //     return this._Instance;
          // }
          this.JQBGMLNYVEHDZOJG = {};
          this.GGDZQSH = {};
          this.CVJWQRGOLJZNTLAK = {};
        }
        EZQUCJJML(XVSNOCBCOJNRWBV, POECMOEQKKRKI, ACBAGLVXUJUP, UUAVTEAAUSKOAMC) {
          if (null != XVSNOCBCOJNRWBV[POECMOEQKKRKI]) {
            XVSNOCBCOJNRWBV[POECMOEQKKRKI].push(new MsgFuc(UUAVTEAAUSKOAMC, ACBAGLVXUJUP));
          } else {
            XVSNOCBCOJNRWBV[POECMOEQKKRKI] = [];
            XVSNOCBCOJNRWBV[POECMOEQKKRKI].push(new MsgFuc(UUAVTEAAUSKOAMC, ACBAGLVXUJUP));
          }
        }
        CMWIFZOA(XVSNOCBCOJNRWBV, POECMOEQKKRKI, ACBAGLVXUJUP, UUAVTEAAUSKOAMC) {
          if (null != XVSNOCBCOJNRWBV[POECMOEQKKRKI] && XVSNOCBCOJNRWBV[POECMOEQKKRKI].length > 0) {
            // 移除事件
            // 找出当前事件
            let needDelMsg = null;
            for (let i = 0; i < XVSNOCBCOJNRWBV[POECMOEQKKRKI].length; i++) {
              if (XVSNOCBCOJNRWBV[POECMOEQKKRKI][i].ACBAGLVXUJUP == ACBAGLVXUJUP && XVSNOCBCOJNRWBV[POECMOEQKKRKI][i].UUAVTEAAUSKOAMC == UUAVTEAAUSKOAMC) {
                needDelMsg = XVSNOCBCOJNRWBV[POECMOEQKKRKI][i];
                break;
              }
            }
            let index = XVSNOCBCOJNRWBV[POECMOEQKKRKI].indexOf(needDelMsg);
            if (index > -1) {
              XVSNOCBCOJNRWBV[POECMOEQKKRKI].splice(index, 1);
            }
            if (null != XVSNOCBCOJNRWBV[POECMOEQKKRKI] && XVSNOCBCOJNRWBV[POECMOEQKKRKI].length == 0) {
              // 没有消息了，删除内存
              delete XVSNOCBCOJNRWBV[POECMOEQKKRKI];
            }
          }
        }
        EIJMLQLRH(XVSNOCBCOJNRWBV, POECMOEQKKRKI, XAXDRWWUDVKG) {
          if (XVSNOCBCOJNRWBV[POECMOEQKKRKI] == null) {
            return;
          }

          // 遍历消息
          XVSNOCBCOJNRWBV[POECMOEQKKRKI].forEach(QTSNULELKCF => {
            QTSNULELKCF.ACBAGLVXUJUP.call(QTSNULELKCF.UUAVTEAAUSKOAMC, XAXDRWWUDVKG);
          });
        }
        TGQXAKDAHFFVG(POECMOEQKKRKI, ACBAGLVXUJUP, UUAVTEAAUSKOAMC) {
          this.EZQUCJJML(this.JQBGMLNYVEHDZOJG, POECMOEQKKRKI, ACBAGLVXUJUP, UUAVTEAAUSKOAMC);
        }
        CJZWUD(POECMOEQKKRKI, ACBAGLVXUJUP, UUAVTEAAUSKOAMC) {
          this.CMWIFZOA(this.JQBGMLNYVEHDZOJG, POECMOEQKKRKI, ACBAGLVXUJUP, UUAVTEAAUSKOAMC);
        }
        VATMRFOEE(POECMOEQKKRKI, ACBAGLVXUJUP, UUAVTEAAUSKOAMC) {
          this.EZQUCJJML(this.GGDZQSH, POECMOEQKKRKI, ACBAGLVXUJUP, UUAVTEAAUSKOAMC);
        }
        XQCUFOSQBT(POECMOEQKKRKI, ACBAGLVXUJUP_, UUAVTEAAUSKOAMC) {
          this.CMWIFZOA(this.GGDZQSH, POECMOEQKKRKI, ACBAGLVXUJUP_, UUAVTEAAUSKOAMC);
        }
        GTQSNS(POECMOEQKKRKI_, ACBAGLVXUJUP, UUAVTEAAUSKOAMC) {
          this.EZQUCJJML(this.CVJWQRGOLJZNTLAK, POECMOEQKKRKI_, ACBAGLVXUJUP, UUAVTEAAUSKOAMC);
        }
        QVRPKLY(POECMOEQKKRKI, ACBAGLVXUJUP, UUAVTEAAUSKOAMC) {
          this.CMWIFZOA(this.CVJWQRGOLJZNTLAK, POECMOEQKKRKI, ACBAGLVXUJUP, UUAVTEAAUSKOAMC);
        }
        PWJDNMU(POECMOEQKKRKI, XAXDRWWUDVKG) {
          this.EIJMLQLRH(this.GGDZQSH, POECMOEQKKRKI, XAXDRWWUDVKG);
          this.EIJMLQLRH(this.JQBGMLNYVEHDZOJG, POECMOEQKKRKI, XAXDRWWUDVKG);
          this.EIJMLQLRH(this.CVJWQRGOLJZNTLAK, POECMOEQKKRKI, XAXDRWWUDVKG);
        }
      }
      exports('BSCTBWK', BSCTBWK);
      class MsgFuc {
        constructor(UUAVTEAAUSKOAMC, ACBAGLVXUJUP) {
          this.UUAVTEAAUSKOAMC = void 0;
          this.ACBAGLVXUJUP = void 0;
          this.UUAVTEAAUSKOAMC = UUAVTEAAUSKOAMC;
          this.ACBAGLVXUJUP = ACBAGLVXUJUP;
          this.ACBAGLVXUJUP.bind(UUAVTEAAUSKOAMC);
        }
      }
      exports('MsgFuc', MsgFuc);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/btn-effect.ts", ['cc'], function (exports) {
  var cclegacy, Component, Animation, macro, _decorator;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Component = module.Component;
      Animation = module.Animation;
      macro = module.macro;
      _decorator = module._decorator;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "37f76rloX9EWJsKA9Lnm+6o", "btn-effect", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let BtnEffect = exports('BtnEffect', (_dec = ccclass('BtnEffect'), _dec(_class = class BtnEffect extends Component {
        constructor(...args) {
          super(...args);
          this.anim = null;
          this.dur = 5;
        }
        onLoad() {
          this.anim = this.getComponent(Animation);
        }
        onEnable() {
          this.schedule(() => {
            this.playAnim();
          }, this.dur, macro.REPEAT_FOREVER);
        }
        onDisable() {
          this.anim.stop();
          this.unschedule(this.playAnim);
        }
        playAnim() {
          this.anim.play();
        }
      }) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/bundle-conifg.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "910453OHGhGu5EjbbZgDdlP", "bundle-conifg", undefined);
      let BundleName = exports('BundleName', /*#__PURE__*/function (BundleName) {
        BundleName["Store"] = "bundle-store";
        BundleName["Sg"] = "bundle-sg";
        return BundleName;
      }({}));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/card-constants.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "3a6318pdUJBFoVZURZMx6vT", "card-constants", undefined);
      let CardSuit = exports('CardSuit', /*#__PURE__*/function (CardSuit) {
        CardSuit["None"] = "none";
        CardSuit["Spade"] = "spade";
        CardSuit["Club"] = "club";
        CardSuit["Diamond"] = "diamond";
        CardSuit["Heart"] = "heart";
        return CardSuit;
      }({}));
      let CardPoint = exports('CardPoint', /*#__PURE__*/function (CardPoint) {
        CardPoint[CardPoint["None"] = 0] = "None";
        CardPoint[CardPoint["Ace"] = 1] = "Ace";
        CardPoint[CardPoint["Two"] = 2] = "Two";
        CardPoint[CardPoint["Three"] = 3] = "Three";
        CardPoint[CardPoint["Four"] = 4] = "Four";
        CardPoint[CardPoint["Five"] = 5] = "Five";
        CardPoint[CardPoint["Six"] = 6] = "Six";
        CardPoint[CardPoint["Seven"] = 7] = "Seven";
        CardPoint[CardPoint["Eight"] = 8] = "Eight";
        CardPoint[CardPoint["Nine"] = 9] = "Nine";
        CardPoint[CardPoint["Ten"] = 10] = "Ten";
        CardPoint[CardPoint["Jack"] = 11] = "Jack";
        CardPoint[CardPoint["Queen"] = 12] = "Queen";
        CardPoint[CardPoint["King"] = 13] = "King";
        return CardPoint;
      }({}));
      class CardConstants {}
      exports('CardConstants', CardConstants);
      CardConstants.CardHeight = 204;
      CardConstants.CardWidth = 136;
      CardConstants.CardTopOffsetCovered = 42;
      CardConstants.CardTopOffsetUnCovered = 64;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/card-data.ts", ['cc', './card-constants.ts'], function (exports) {
  var cclegacy, CardSuit, CardPoint;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      CardSuit = module.CardSuit;
      CardPoint = module.CardPoint;
    }],
    execute: function () {
      cclegacy._RF.push({}, "bb476BKGh9PL7oRb2COlhgq", "card-data", undefined);
      class CardData {
        constructor(suit, point, isCovered = true) {
          this._suit = CardSuit.None;
          this._point = CardPoint.None;
          this._isCovered = true;
          this._isSpecialMinor = false;
          this._isSpecialMajor = false;
          this._suit = suit;
          this._point = point;
          this._isCovered = isCovered;
        }
        get suit() {
          return this._suit;
        }
        get point() {
          return this._point;
        }
        get isCovered() {
          return this._isCovered;
        }
        get isSpecialMinor() {
          return this._isSpecialMinor;
        }
        setSpecialMinor(value) {
          this._isSpecialMinor = value;
        }
        get isSpecialMajor() {
          return this._isSpecialMajor;
        }
        setSpecialMajor(value) {
          this._isSpecialMajor = value;
        }
        setCovered(value) {
          this._isCovered = value;
        }
        get code() {
          let code = "";
          if (this._suit == CardSuit.Spade || this._suit == CardSuit.Club) {
            code = "B";
          } else {
            code = "R";
          }
          return code;
        }
        equals(other) {
          return this._suit === other.suit && this._point === other.point;
        }
        matchGreaterThan(data) {
          return this.code != data.code && this._point - 1 === data.point;
        }
        matchLessThan(data) {
          return this.code != data.code && this._point + 1 === data.point;
        }
      }
      exports('CardData', CardData);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/card-dealer.ts", ['cc', './log-util.ts', './random-util.ts', './card-constants.ts', './card-data.ts', './game-res-manager.ts'], function (exports) {
  var cclegacy, LogUtil, RandomUtil, CardSuit, CardData, GameResManager;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      RandomUtil = module.RandomUtil;
    }, function (module) {
      CardSuit = module.CardSuit;
    }, function (module) {
      CardData = module.CardData;
    }, function (module) {
      GameResManager = module.GameResManager;
    }],
    execute: function () {
      cclegacy._RF.push({}, "823357T9IlO0Z2DMMA+owvN", "card-dealer", undefined);
      class CardDealer {
        constructor() {
          this._stocks = [];
          this._tableaus = [];
        }
        get stocks() {
          return this._stocks;
        }
        get tableaus() {
          return this._tableaus;
        }
        shuffle(index) {
          LogUtil.log('dealer shuffle:', index);
          const raw = GameResManager.instance.getStageRawData(index);
          // LogUtil.log('dealer shuffle raw:', JSON.stringify(raw));
          this._stocks = [];
          this._tableaus = [];
          let leftSpecial = RandomUtil.random(2, 4);
          const suits = [CardSuit.Club, CardSuit.Diamond, CardSuit.Spade, CardSuit.Heart];

          // 原始数据是从后往前，按照横排从左到右发牌，依次向下发牌
          let copyRaw = Array.from(raw);
          for (let i = 0; i < 7; i++) {
            for (let j = i; j < 7; j++) {
              const rawCard = copyRaw.pop();
              const card = new CardData(suits[rawCard[0]], rawCard[1]);
              if (!this._tableaus[j]) {
                this._tableaus[j] = [];
              }
              this._tableaus[j].push(card);
            }
          }
          copyRaw = RandomUtil.shuffle(copyRaw);
          for (let i = 0; i < copyRaw.length; i++) {
            const rawCard = copyRaw[i];
            const card = new CardData(suits[rawCard[0]], rawCard[1]);
            this._stocks.push(card);
          }

          // special minor cards 只出现在stock中
          // RandomUtil.random(this._stocks, leftSpecial).forEach(card => {
          //     card.setSpecialMinor(true);
          // });

          // special major cards 只出现在tableau中
          const temps = this._tableaus.slice(2);
          const specialMajor = 1;
          RandomUtil.random(temps, specialMajor).forEach(cardsInLayout => {
            const index = RandomUtil.random(1, cardsInLayout.length - 2);
            cardsInLayout[index].setSpecialMajor(true);
          });
        }
      }
      exports('CardDealer', CardDealer);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/card-render.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './card-constants.ts', './game-res-manager.ts', './game-data-manager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Sprite, Node, _decorator, Component, Widget, CardPoint, CardSuit, GameResManager, GameDataManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Sprite = module.Sprite;
      Node = module.Node;
      _decorator = module._decorator;
      Component = module.Component;
      Widget = module.Widget;
    }, function (module) {
      CardPoint = module.CardPoint;
      CardSuit = module.CardSuit;
    }, function (module) {
      GameResManager = module.GameResManager;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8;
      cclegacy._RF.push({}, "7d1a00+vfBNqKnGfjinCHaZ", "card-render", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let CardRender = exports('CardRender', (_dec = ccclass('CardRender'), _dec2 = property(Sprite), _dec3 = property(Node), _dec4 = property(Node), _dec5 = property(Node), _dec6 = property(Node), _dec7 = property(Node), _dec8 = property(Node), _dec9 = property(Node), _dec(_class = (_class2 = class CardRender extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "sprintPoint", _descriptor, this);
          _initializerDefineProperty(this, "suitMinor", _descriptor2, this);
          _initializerDefineProperty(this, "suitMajorNumber", _descriptor3, this);
          _initializerDefineProperty(this, "suitMajorFace", _descriptor4, this);
          _initializerDefineProperty(this, "coverNormal", _descriptor5, this);
          _initializerDefineProperty(this, "coverSpecial", _descriptor6, this);
          _initializerDefineProperty(this, "hintSpecial", _descriptor7, this);
          _initializerDefineProperty(this, "coverSpecialMajor", _descriptor8, this);
          this._cardData = null;
          this.frontThemeId = 0;
          this.backThemeId = 0;
        }
        start() {}
        update(deltaTime) {}
        getNameByPoint(point) {
          switch (point) {
            case CardPoint.Ace:
              return 'A';
            case CardPoint.Two:
              return '2';
            case CardPoint.Three:
              return '3';
            case CardPoint.Four:
              return '4';
            case CardPoint.Five:
              return '5';
            case CardPoint.Six:
              return '6';
            case CardPoint.Seven:
              return '7';
            case CardPoint.Eight:
              return '8';
            case CardPoint.Nine:
              return '9';
            case CardPoint.Ten:
              return '10';
            case CardPoint.Jack:
              return 'J';
            case CardPoint.Queen:
              return 'Q';
            case CardPoint.King:
              return 'K';
          }
        }
        renderCard(data) {
          if (!data) {
            data = this._cardData;
          } else {
            this._cardData = data;
          }
          const point = data.point;
          const suit = data.suit;
          let frame = GameResManager.instance.getSpriteFrame('card_blank');
          if (!frame) {
            frame = GameResManager.instance.getSpriteFrame('common_blank');
          }
          this.getComponent(Sprite).spriteFrame = frame;
          const pointImageName = ([CardSuit.Club, CardSuit.Spade].indexOf(suit) != -1 ? 'b' : 'r') + `${point}`;
          if (GameDataManager.instance.data.cardFrontThemeId == 5) {
            this.sprintPoint.spriteFrame = GameResManager.instance.getSpriteFrame(`${point}`);
          } else {
            this.sprintPoint.spriteFrame = GameResManager.instance.getSpriteFrame(pointImageName);
          }
          this.sprintPoint.node.active = true;
          this.sprintPoint.getComponent(Widget).updateAlignment();
          this.suitMinor.active = true;
          this.suitMinor.getComponent(Sprite).spriteFrame = GameResManager.instance.getSpriteFrame(`${suit}_s`);
          if (point > 10) {
            const faceValueMap = {
              [CardPoint.Jack]: 'j',
              [CardPoint.Queen]: 'q',
              [CardPoint.King]: 'k'
            };
            const faceSuitMap = {
              [CardSuit.Club]: 'black',
              [CardSuit.Spade]: 'black',
              [CardSuit.Diamond]: 'red',
              [CardSuit.Heart]: 'red'
            };
            this.suitMajorNumber.active = false;
            this.suitMajorFace.active = true;
            if (GameDataManager.instance.data.cardFrontThemeId == 5) {
              this.suitMajorFace.getComponent(Sprite).spriteFrame = GameResManager.instance.getSpriteFrame(`${faceValueMap[point]}`);
            } else {
              this.suitMajorFace.getComponent(Sprite).spriteFrame = GameResManager.instance.getSpriteFrame(`${faceSuitMap[suit]}_${faceValueMap[point]}`);
            }
          } else {
            this.suitMajorNumber.active = true;
            this.suitMajorFace.active = false;
            this.suitMajorNumber.getComponent(Sprite).spriteFrame = GameResManager.instance.getSpriteFrame(`${suit}_b`);
          }
          this.coverNormal.getComponent(Sprite).spriteFrame = GameResManager.instance.getSpriteFrame(`cover_normal`);
          this.coverNormal.active = data.isCovered && !data.isSpecialMinor;
          this.coverSpecial.active = data.isCovered && data.isSpecialMinor;
          this.hintSpecial.active = !data.isCovered && data.isSpecialMinor;
          this.coverSpecialMajor.active = data.isCovered && data.isSpecialMajor;
          if (data.isSpecialMajor) {
            const type = GameDataManager.instance.getMajorTokenType();
            this.coverSpecialMajor.getChildByName('sp').getComponent(Sprite).spriteFrame = GameResManager.instance.getSpriteFrame(`sp_${type}`);
          }
        }
        setCovered(coverd) {
          if (!!this._cardData) {
            this._cardData.setCovered(coverd);
            this.coverNormal.active = coverd && !this._cardData.isSpecialMinor;
            this.coverSpecial.active = coverd && this._cardData.isSpecialMinor;
            this.hintSpecial.active = !coverd && this._cardData.isSpecialMinor;
            this.coverSpecialMajor.active = coverd && this._cardData.isSpecialMajor;
          }
        }
        setSpecialMinor(special) {
          if (!!this._cardData) {
            this._cardData.setSpecialMinor(special);
            this.coverSpecial.active = this._cardData.isCovered && this._cardData.isSpecialMinor;
            this.hintSpecial.active = !this._cardData.isCovered && this._cardData.isSpecialMinor;
          }
        }
        setSpecialMajor(special) {
          this.coverSpecialMajor.active = special;
          if (special) {
            const type = GameDataManager.instance.getMajorTokenType();
            this.coverSpecialMajor.getChildByName('sp').getComponent(Sprite).spriteFrame = GameResManager.instance.getSpriteFrame(`sp_${type}`);
          }
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "sprintPoint", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "suitMinor", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "suitMajorNumber", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "suitMajorFace", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "coverNormal", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "coverSpecial", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "hintSpecial", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "coverSpecialMajor", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/card-theme-item.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Sprite, SpriteFrame, Node, Label, _decorator, Component;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Sprite = module.Sprite;
      SpriteFrame = module.SpriteFrame;
      Node = module.Node;
      Label = module.Label;
      _decorator = module._decorator;
      Component = module.Component;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7;
      cclegacy._RF.push({}, "25bc94Bl21PjZa0LS0T5Jg+", "card-theme-item", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let CardThemeState = exports('CardThemeState', /*#__PURE__*/function (CardThemeState) {
        CardThemeState[CardThemeState["InUse"] = 0] = "InUse";
        CardThemeState[CardThemeState["Unused"] = 1] = "Unused";
        CardThemeState[CardThemeState["Locked"] = 2] = "Locked";
        return CardThemeState;
      }({}));
      let CardThemeItem = exports('CardThemeItem', (_dec = ccclass('CardThemeItem'), _dec2 = property(Sprite), _dec3 = property([SpriteFrame]), _dec4 = property(Node), _dec5 = property([SpriteFrame]), _dec6 = property(Label), _dec7 = property(Node), _dec8 = property(Label), _dec(_class = (_class2 = class CardThemeItem extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "sprtCard", _descriptor, this);
          _initializerDefineProperty(this, "sprtCardFrames", _descriptor2, this);
          _initializerDefineProperty(this, "btnUse", _descriptor3, this);
          _initializerDefineProperty(this, "btnUseFrames", _descriptor4, this);
          _initializerDefineProperty(this, "lblBtnUse", _descriptor5, this);
          _initializerDefineProperty(this, "btnBuy", _descriptor6, this);
          _initializerDefineProperty(this, "lblBtnBuy", _descriptor7, this);
        }
        set isFront(val) {
          this.sprtCard.spriteFrame = this.sprtCardFrames[val ? 0 : 1];
        }
        set state(val) {
          this.btnBuy.active = val === CardThemeState.Locked;
          this.btnUse.active = !this.btnBuy.active;
          let spr = this.btnUse.getComponent(Sprite);
          if (this.btnUse.active) {
            switch (val) {
              case CardThemeState.InUse:
                spr && (spr.spriteFrame = this.btnUseFrames[0]);
                this.lblBtnUse.string = 'In Use';
                break;
              case CardThemeState.Unused:
                spr && (spr.spriteFrame = this.btnUseFrames[1]);
                this.lblBtnUse.string = 'Use';
                break;
            }
          }
        }
        set price(val) {
          this.lblBtnBuy.string = val.toString();
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "sprtCard", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "sprtCardFrames", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "btnUse", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "btnUseFrames", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "lblBtnUse", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "btnBuy", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "lblBtnBuy", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/card-theme-view.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './card-theme-item.ts', './game-data-manager.ts', './ui-manager.ts', './audio-manager.ts', './game-constants.ts', './reward-manager.ts', './game-res-manager.ts', './bridge-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Sprite, SpriteFrame, Node, Label, _decorator, director, Color, UIView, CardThemeItem, CardThemeState, GameDataManager, UIManager, AudioManager, AudioUrl, GameEvent, RewardManager, GameResManager, BridgeUtil, VibrationEffect;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Sprite = module.Sprite;
      SpriteFrame = module.SpriteFrame;
      Node = module.Node;
      Label = module.Label;
      _decorator = module._decorator;
      director = module.director;
      Color = module.Color;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      CardThemeItem = module.CardThemeItem;
      CardThemeState = module.CardThemeState;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      AudioUrl = module.AudioUrl;
      GameEvent = module.GameEvent;
    }, function (module) {
      RewardManager = module.RewardManager;
    }, function (module) {
      GameResManager = module.GameResManager;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11;
      cclegacy._RF.push({}, "03270ShPaFPD7n+Vj7Lz2wY", "card-theme-view", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      const TabTextColor = [`#FFCD1F`, `#9BCFFF`];
      let CardThemeView = exports('CardThemeView', (_dec = ccclass('CardThemeView'), _dec2 = property(Sprite), _dec3 = property([SpriteFrame]), _dec4 = property([SpriteFrame]), _dec5 = property(Sprite), _dec6 = property([SpriteFrame]), _dec7 = property(Sprite), _dec8 = property(Sprite), _dec9 = property([SpriteFrame]), _dec10 = property(Node), _dec11 = property(Label), _dec12 = property(Label), _dec(_class = (_class2 = class CardThemeView extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "sprtCard", _descriptor, this);
          _initializerDefineProperty(this, "sprtFrontFrames", _descriptor2, this);
          _initializerDefineProperty(this, "sprtBackFrames", _descriptor3, this);
          _initializerDefineProperty(this, "sprtBg", _descriptor4, this);
          _initializerDefineProperty(this, "sprtBgFrame", _descriptor5, this);
          _initializerDefineProperty(this, "sprtTabFront", _descriptor6, this);
          _initializerDefineProperty(this, "sprtTabBack", _descriptor7, this);
          _initializerDefineProperty(this, "sprtTabFrames", _descriptor8, this);
          _initializerDefineProperty(this, "itemContainer", _descriptor9, this);
          _initializerDefineProperty(this, "lblTabFront", _descriptor10, this);
          _initializerDefineProperty(this, "lblTabBack", _descriptor11, this);
          this.itemList = [];
          this.isFront = true;
          this.curThemeId = void 0;
        }
        onOpen(fromUI, ...args) {
          let accountLayout = director.getScene().getChildByPath('Canvas/midLayer/LayoutTokenAccount');
          if (accountLayout) {
            accountLayout.active = false;
          }
          for (let i = 0; i < this.itemContainer.children.length; i++) {
            let node = this.itemContainer.getChildByName(`item${i}`);
            let comp = node.getComponent(CardThemeItem);
            this.itemList.push(comp);
          }
          this.setIsFront(true);
          this.setCurThemeId(GameDataManager.instance.data.cardFrontThemeId);
        }
        onClose() {
          let accountLayout = director.getScene().getChildByPath('Canvas/midLayer/LayoutTokenAccount');
          if (accountLayout) {
            accountLayout.active = true;
          }
          GameDataManager.instance.saveData(true);
        }
        setIsFront(val) {
          this.isFront = val;

          // card
          if (this.isFront) {
            let id = GameDataManager.instance.data.cardFrontThemeId;
            this.sprtCard.spriteFrame = this.sprtFrontFrames[id];
            Color.fromHEX(this.lblTabFront.color, TabTextColor[0]);
            this.lblTabFront.updateRenderData(true);
            Color.fromHEX(this.lblTabBack.color, TabTextColor[1]);
            this.lblTabBack.updateRenderData(true);
          } else {
            let id = GameDataManager.instance.data.cardBackThemeId;
            this.sprtCard.spriteFrame = this.sprtBackFrames[id];
            Color.fromHEX(this.lblTabFront.color, TabTextColor[1]);
            this.lblTabFront.updateRenderData(true);
            Color.fromHEX(this.lblTabBack.color, TabTextColor[0]);
            this.lblTabBack.updateRenderData(true);
          }

          // items
          let config = RewardManager.instance.getConfig();
          for (let i = 0; i < this.itemList.length; i++) {
            let item = this.itemList[i];
            item.isFront = val;
            if (i > 0) {
              item.price = this.isFront ? config.theme.front_prices[i - 1] : config.theme.back_prices[i - 1];
            }
          }

          // tabs
          this.sprtTabFront.spriteFrame = this.sprtTabFrames[val ? 0 : 1];
          this.sprtTabFront.node.setSiblingIndex(val ? 1 : 0);
          this.sprtTabBack.spriteFrame = this.sprtTabFrames[val ? 1 : 0];
          this.sprtTabBack.node.setSiblingIndex(val ? 0 : 1);
        }
        setCurThemeId(id) {
          if (this.curThemeId === id) {
            return;
          }
          if (id < 0 || id > this.itemList.length - 1) {
            return;
          }

          // card
          this.sprtCard.spriteFrame = this.isFront ? this.sprtFrontFrames[id] : this.sprtBackFrames[id];

          // items
          let gdMgr = GameDataManager.instance;
          let list = this.isFront ? gdMgr.data.themesFrontUnlocked : gdMgr.data.themesBackUnlocked;
          for (let i = 0; i < this.itemList.length; i++) {
            let item = this.itemList[i];
            let idx = list.indexOf(i);
            if (i === id) {
              item.state = CardThemeState.InUse;
            } else if (idx < 0) {
              item.state = CardThemeState.Locked;
            } else {
              item.state = CardThemeState.Unused;
            }
          }
          if (!this.isFront) {
            this.sprtBg.spriteFrame = this.sprtBgFrame[id];
          }
          this.curThemeId = id;
        }
        onTabBtn(event, data) {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          let gdMgr = GameDataManager.instance;
          switch (data) {
            case '0':
              if (!this.isFront) {
                this.setIsFront(true);
                this.setCurThemeId(gdMgr.data.cardFrontThemeId);
              }
              break;
            case '1':
              if (this.isFront) {
                this.setIsFront(false);
                this.setCurThemeId(gdMgr.data.cardBackThemeId);
              }
              break;
          }
        }
        onUseBtn(event, data) {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          let id = parseInt(data);
          if (this.curThemeId === id) {
            UIManager.instance.showToast(`Currently in use.`);
            return;
          }
          let gdMgr = GameDataManager.instance;
          if (this.isFront) {
            gdMgr.data.cardFrontThemeId = id;
          } else {
            gdMgr.data.cardBackThemeId = id;
          }
          this.setCurThemeId(id);
          UIManager.instance.showToast(`Usage successful.`);
        }
        onBuyBtn(event, data) {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          let gdMgr = GameDataManager.instance;
          let id = parseInt(data);
          let rewardMgr = RewardManager.instance;
          let price = this.isFront ? rewardMgr.getConfig().theme.front_prices[id - 1] : rewardMgr.getConfig().theme.back_prices[id - 1] || 0;
          console.log('price:', price);
          let minorToken = gdMgr.getMinorToken();
          console.log('id:', id, 'minorToken:', minorToken);
          if (minorToken < price) {
            UIManager.instance.showToast(`Not enough Coins`);
            return;
          }
          gdMgr.addMinorToken(0 - price);
          let list = this.isFront ? gdMgr.data.themesFrontUnlocked : gdMgr.data.themesBackUnlocked;
          list.push(id);
          if (this.isFront) {
            gdMgr.data.cardFrontThemeId = id;
          } else {
            gdMgr.data.cardBackThemeId = id;
          }
          this.setCurThemeId(id);
          UIManager.instance.showToast(`Purchase successful, already used.`);
        }
        async onBackBtn() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          await GameResManager.instance.preloadSpriteFrames();
          director.emit(GameEvent.CHANGE_CARD_THEME);
          UIManager.instance.close(this);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "sprtCard", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "sprtFrontFrames", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "sprtBackFrames", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "sprtBg", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "sprtBgFrame", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "sprtTabFront", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "sprtTabBack", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "sprtTabFrames", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "itemContainer", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "lblTabFront", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "lblTabBack", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/card.ts", ['cc', './card-render.ts', './card-constants.ts', './ui-util.ts', './card-data.ts', './log-util.ts'], function (exports) {
  var cclegacy, Event, Component, Vec3, UIOpacity, Node, Tween, UITransform, Vec2, tween, v3, _decorator, CardRender, CardSuit, CardPoint, UIUtil, CardData, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Event = module.Event;
      Component = module.Component;
      Vec3 = module.Vec3;
      UIOpacity = module.UIOpacity;
      Node = module.Node;
      Tween = module.Tween;
      UITransform = module.UITransform;
      Vec2 = module.Vec2;
      tween = module.tween;
      v3 = module.v3;
      _decorator = module._decorator;
    }, function (module) {
      CardRender = module.CardRender;
    }, function (module) {
      CardSuit = module.CardSuit;
      CardPoint = module.CardPoint;
    }, function (module) {
      UIUtil = module.UIUtil;
    }, function (module) {
      CardData = module.CardData;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      var _dec, _class2;
      cclegacy._RF.push({}, "3890bArohRMx51QlGOBjTLC", "card", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      class CardEvent extends Event {
        constructor(name, bubbles, detail) {
          super(name, bubbles);
          this.detail = null;
          this.detail = detail;
        }
      }
      exports('CardEvent', CardEvent);
      CardEvent.enum = {
        CARD_TOUCH_START: 'card_touch_start',
        CARD_TOUCH_CANCEL: 'card_touch_cancel',
        CARD_DRAG_START: 'card_drag_start',
        CARD_DRAG_MOVE: 'card_drag_move',
        CARD_DRAG_END: 'card_drag_end',
        CARD_CLICK: 'card_click'
      };
      let CardArea = exports('CardArea', /*#__PURE__*/function (CardArea) {
        CardArea["NONE"] = "NONE";
        CardArea["STOCK_COVERD"] = "STOCK_COVERD";
        CardArea["STOCK_FLIPED"] = "STOCK_FLIPED";
        CardArea["TABLEAU"] = "TABLEAU";
        CardArea["FOUNDATION"] = "FOUNDATION";
        CardArea["ANIM_CANVAS"] = "ANIM_CANVAS";
        return CardArea;
      }({}));
      let Card = exports('Card', (_dec = ccclass('Card'), _dec(_class2 = class Card extends Component {
        constructor(...args) {
          super(...args);
          this._key = '';
          this._originPos = null;
          this._originParent = null;
          this._dragStartDistance = 20;
          this._isDraging = false;
          this._deltaFromOrigin = null;
          this._tag = '';
          this._area = CardArea.NONE;
          this._cardData = new CardData(CardSuit.None, CardPoint.None);
          this._enableClick = true;
          this._shakeTween = null;
          this._s = 0;
        }
        get canDrag() {
          return (this._area == CardArea.TABLEAU || this._area == CardArea.STOCK_FLIPED || this.area == CardArea.FOUNDATION) && this._enableClick && !this.isCovered;
        }
        get canClick() {
          return (this._area == CardArea.TABLEAU || this._area == CardArea.STOCK_FLIPED || this.area == CardArea.FOUNDATION) && this._enableClick && !this.isCovered;
        }
        get needTouchAffect() {
          return (this._area == CardArea.TABLEAU || this._area == CardArea.STOCK_FLIPED || this.area == CardArea.FOUNDATION) && this._enableClick;
        }
        reset() {
          this.name = 'card';
          this._key = '';
          this._cardData = new CardData(CardSuit.None, CardPoint.None);
          this._tag = '';
          this._area = CardArea.NONE;
          this.node.active = true;
          this._originPos = null;
          this._originParent = null;
          this._isDraging = false;
          this._deltaFromOrigin = null;
          this.node.position = new Vec3(0, 0, 0);
          this.node.scale = new Vec3(1, 1, 1);
          this.node.getComponent(UIOpacity).opacity = 255;
          this.node.off(Node.EventType.TOUCH_START, this.onTouchStart, this);
          this.node.off(Node.EventType.TOUCH_MOVE, this.onTouchMove, this);
          this.node.off(Node.EventType.TOUCH_END, this.onTouchEnd, this);
          this.node.off(Node.EventType.TOUCH_CANCEL, this.onTouchCancel, this);
          Tween.stopAllByTarget(this.node);
        }
        get key() {
          return this._key;
        }
        setTag(tag) {
          this._tag = tag;
        }
        get tag() {
          return this._tag;
        }
        setArea(area) {
          this._area = area;
        }
        get area() {
          return this._area;
        }
        get cardData() {
          return this._cardData;
        }
        get cardSuit() {
          return this._cardData.suit;
        }
        get cardPoint() {
          return this._cardData.point;
        }
        get isCovered() {
          return this._cardData.isCovered;
        }
        get isSpecialMinor() {
          return this._cardData.isSpecialMinor;
        }
        get isSpecialMajor() {
          return this._cardData.isSpecialMajor;
        }
        start() {
          this.refreshOrigin(this.node.position.clone(), this.node.parent);
        }
        refreshOrigin(originPos, originParent) {
          this._originPos = originPos;
          this._originParent = originParent;
        }
        onEnable() {
          // LogUtil.log('onEnable', this._key);
          this.node.on(Node.EventType.TOUCH_START, this.onTouchStart, this);
          this.node.on(Node.EventType.TOUCH_MOVE, this.onTouchMove, this);
          this.node.on(Node.EventType.TOUCH_END, this.onTouchEnd, this);
          this.node.on(Node.EventType.TOUCH_CANCEL, this.onTouchCancel, this);
        }
        onDisable() {
          // LogUtil.log('onDisable', this._key);
          this.node.off(Node.EventType.TOUCH_START, this.onTouchStart, this);
          this.node.off(Node.EventType.TOUCH_MOVE, this.onTouchMove, this);
          this.node.off(Node.EventType.TOUCH_END, this.onTouchEnd, this);
          this.node.off(Node.EventType.TOUCH_CANCEL, this.onTouchCancel, this);
        }
        update(deltaTime) {
          // !!!attention!!!
          // movement must consider this logic to avoid unexpected behavior
          if (this._isDraging && this._deltaFromOrigin) {
            this._s += 1;
            if (this._s % 1000 == 0) ;
            var targetPos = this.getOriginPosInParent();
            targetPos = targetPos.add(this._deltaFromOrigin.toVec3());
            const currentPos = this.node.position.clone();
            if (Vec3.equals(currentPos, targetPos)) {
              return;
            }
            const distance = Vec3.distance(currentPos, targetPos);
            const dynamicSpeed = Math.min(0.1 + distance * 0.1, 0.3);
            const newPos = currentPos.lerp(targetPos, dynamicSpeed);
            this.node.position = newPos;
          }
        }
        getOriginPosInParent() {
          var targetPos = this._originParent.getComponent(UITransform).convertToWorldSpaceAR(this._originPos);
          targetPos = this.node.parent.getComponent(UITransform).convertToNodeSpaceAR(targetPos);
          return targetPos.clone();
        }
        setCardData(key, data) {
          this._key = key;
          this._cardData = data;
          this.node.getComponent(CardRender).renderCard(data);
        }
        setupCard() {}
        onDestroy() {
          LogUtil.log('onDestroy', this._key);
        }
        setDraging(draging) {
          this._isDraging = draging;
        }
        onTouchStart(event, customEventData) {
          if (this.canClick || this.canDrag) {
            const cardEvent = new CardEvent(CardEvent.enum.CARD_TOUCH_START, true, {
              key: this._key,
              handled: false
            });
            this.node.dispatchEvent(cardEvent);
          }
        }
        onTouchMove(event, customEventData) {
          if (this.isCovered) {
            return;
          }
          if (this.canClick || this.canDrag) {
            if (!this._isDraging) {
              const offset = event.getStartLocation().subtract(event.getLocation());
              if (offset.length() > this._dragStartDistance) {
                const cardEvent = new CardEvent(CardEvent.enum.CARD_DRAG_START, true, {
                  key: this._key,
                  handled: false
                });
                this.node.dispatchEvent(cardEvent);
              }
            }
          }
          const delta = event.getUIDelta();
          const cardEvent = new CardEvent(CardEvent.enum.CARD_DRAG_MOVE, true, {
            key: this._key,
            delta: delta,
            handled: false
          });
          this.node.dispatchEvent(cardEvent);
        }
        onTouchEnd(event, customEventData) {
          if (!this._isDraging) {
            this._isDraging = false;
            this._deltaFromOrigin = null;
            this.onCardClicked();
            return;
          }
          const cardEvent = new CardEvent(CardEvent.enum.CARD_DRAG_END, true, {
            key: this._key,
            position: event.getUILocation().clone(),
            handled: false
          });
          this.node.dispatchEvent(cardEvent);
          if (!cardEvent.detail.handled) ;
          this._isDraging = false;
          this._deltaFromOrigin = null;
        }
        onTouchCancel(event, customEventData) {
          LogUtil.log('onCardTouchCancel', this._key);
          if (this.isCovered) {
            return;
          }
          const cardEvent = new CardEvent(CardEvent.enum.CARD_TOUCH_CANCEL, true, {
            key: this._key,
            handled: false
          });
          this.node.dispatchEvent(cardEvent);
          this._isDraging = false;
          this._deltaFromOrigin = null;
        }
        onCardClicked() {
          if (!this.canClick) {
            LogUtil.log('onCardClicked', this._key, 'cannot click', " area is:", this.area, " this._isDraging", this._isDraging, "this._isEnableClick", this._enableClick);
            return;
          }
          const cardEvent = new CardEvent(CardEvent.enum.CARD_CLICK, true, {
            key: this._key,
            handled: false
          });
          this.node.dispatchEvent(cardEvent);
        }
        actionTouchStart() {
          this._deltaFromOrigin = new Vec2(0, 0);
          this.setTouchAffect();
        }
        actionTouchCancel() {
          this._deltaFromOrigin = null;
          if (this._isDraging) {
            this._isDraging = false;
            this.enableClick();
            this.stopShake();
            this.backToSuzerain();
          } else {
            this.clearTouchAffect();
          }
        }
        actionDragStart() {
          this._isDraging = true;
          this.disableClick();
          this.stopShake();
        }
        actionDragMove(delta) {
          LogUtil.log('actionDragMove 1');
          if (!this._deltaFromOrigin) {
            return;
          }
          this._deltaFromOrigin.add(delta);
        }
        actionDragEnd() {
          LogUtil.log('actionDragEnd', this._key);
          this._isDraging = false;
          this._deltaFromOrigin = null;
          this.enableClick();
        }
        backToSuzerain() {
          LogUtil.log('backToSuzerain', this._key);
          UIUtil.moveCardToParent(this.node, this._originParent, this._area, this._originPos);
          this.node.scale = new Vec3(1, 1, 1);
          this._isDraging = false;
        }
        disableClick() {
          this._enableClick = false;
        }
        enableClick() {
          this._enableClick = true;
        }
        getAnimCanvas() {
          var parent = this.node.parent;
          while (parent) {
            if (parent.name === 'game_desk') {
              return parent.getChildByName('anim_canvas');
            }
            parent = parent.parent;
          }
          return null;
        }
        setTouchAffect() {
          if (!this.needTouchAffect) {
            return;
          }
          this.node.setScale(1.08, 1.08, 1);
        }
        clearTouchAffect() {
          LogUtil.log('clearTouchAffect', this._key);
          if (!this.needTouchAffect) {
            return;
          }
          const pos = this.node.position.clone();
          this.shake(this.node, pos);
        }
        stopShake() {
          if (this._shakeTween) {
            this._shakeTween.stop();
            this._shakeTween = null;
          }
          this.node.setScale(1, 1, 1);
        }
        shake(node, pos) {
          const initialShake = 10; // 初始幅度
          const initialScale = 1.08; // 初始缩放
          const decayFactor = 0.8; //
          const durationBase = 0.12; // 初始持续时间

          if (this._shakeTween) {
            this._shakeTween.stop();
            this._shakeTween = null;
          }

          // 创建动画链
          const tweenChain = tween(node);
          this._shakeTween = tweenChain;
          let currentShake = initialShake;
          let currentScale = initialScale;
          let currentDuration = durationBase;

          // 循环生成衰减动画阶段
          for (let i = 0; i < 4; i++) {
            // 4次衰减阶段足够表现冲击感
            const direction = i % 2 === 0 ? -1 : 1; // 左右交替方向
            tweenChain.to(currentDuration, {
              position: v3(direction * currentShake, pos.y, 0),
              scale: new Vec3(currentScale, currentScale, 1)
            }, {
              easing: i === 0 ? 'expoOut' : 'quadOut'
            }); // 首阶段用陡峭缓动

            // 参数衰减
            currentShake *= decayFactor;
            currentScale -= (initialScale - 1) * (1 - decayFactor); // 缩放按比例衰减
            currentDuration *= 0.7; // 持续时间指数级缩短
          }

          // 最终复位
          tweenChain.to(0.08, {
            position: v3(0, pos.y, 0),
            scale: new Vec3(1, 1, 1)
          }, {
            easing: 'sineIn'
          }).start();
        }
        setCovered(coverd) {
          this._cardData.setCovered(coverd);
          this.node.getComponent(CardRender).setCovered(coverd);
        }
        setSpecialMinor(special) {
          this._cardData.setSpecialMinor(special);
          this.node.getComponent(CardRender).setSpecialMinor(special);
        }
        setSpecialMajor(special) {
          this._cardData.setSpecialMajor(special);
          this.node.getComponent(CardRender).setSpecialMajor(special);
        }
        flip(toCover = false) {
          this._cardData.setCovered(toCover);
          return new Promise((resolve, reject) => {
            this.disableClick();
            const initialScale = this.node.scale.clone();
            const targetScale = new Vec3(0, initialScale.y * 1.1, initialScale.z);
            tween(this.node).to(0.1, {
              scale: targetScale
            }).call(() => {
              this.setCovered(toCover);
            }).to(0.1, {
              scale: initialScale
            }).call(() => {
              this.enableClick();
              resolve();
            }).start();
          });

          // return new Promise((resolve, reject) => {
          //     if (this.isCovered !== toCover) {
          //         this.disableClick();
          //         const initialScale = this.node.scale.clone();
          //         const targetScale = new Vec3(0, initialScale.y * 1.1, initialScale.z);
          //         tween(this.node).to(0.1, { scale: targetScale }).call(() => {
          //             this.setCovered(toCover);
          //         }).to(0.1, { scale: initialScale }).call(() => {
          //             this.enableClick();
          //             resolve();
          //         }).start();
          //     } else {
          //         resolve();
          //     }

          // });
        }
      }) || _class2));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/CCIOERS.ts", ['cc', './PQBRALKRA.ts', './AKHOCOQOOYH.ts', './SDYSTNCVGG.ts', './WBKIRV.ts', './RHNDXTSQQCUFJ.ts', './AHGNGYYNSSRZ.ts', './YJPHBDNICBXPNH.ts', './VBWBHDOLKCQNA.ts', './TAMEBDDEGGUCY.ts', './AQKTRMDQJQQBTDC.ts', './OULQSMFSYRNMXWT.ts', './MNQRQYTLR.ts', './TBGHTYXGU.ts', './MYKRDT.ts', './LIGHOZ.ts', './CJXOHZKFR.ts', './MEMINEFUZFGAOP.ts', './RTONERXYWGCD.ts', './QLHROXRCFBPYKY.ts', './KENOHXMVJJSH.ts'], function (exports) {
  var cclegacy, PQBRALKRA, AKHOCOQOOYH, SDYSTNCVGG, PDWTAEXGRLKYCOL, RHNDXTSQQCUFJ, AHGNGYYNSSRZ, YJPHBDNICBXPNH, VBWBHDOLKCQNA, TAMEBDDEGGUCY, AQKTRMDQJQQBTDC, OULQSMFSYRNMXWT, MNQRQYTLR, TBGHTYXGU, MYKRDT, LIGHOZ, CJXOHZKFR, MEMINEFUZFGAOP, RTONERXYWGCD, QLHROXRCFBPYKY, KENOHXMVJJSH;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      PQBRALKRA = module.PQBRALKRA;
    }, function (module) {
      AKHOCOQOOYH = module.AKHOCOQOOYH;
    }, function (module) {
      SDYSTNCVGG = module.SDYSTNCVGG;
    }, function (module) {
      PDWTAEXGRLKYCOL = module.PDWTAEXGRLKYCOL;
    }, function (module) {
      RHNDXTSQQCUFJ = module.RHNDXTSQQCUFJ;
    }, function (module) {
      AHGNGYYNSSRZ = module.AHGNGYYNSSRZ;
    }, function (module) {
      YJPHBDNICBXPNH = module.YJPHBDNICBXPNH;
    }, function (module) {
      VBWBHDOLKCQNA = module.VBWBHDOLKCQNA;
    }, function (module) {
      TAMEBDDEGGUCY = module.TAMEBDDEGGUCY;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      OULQSMFSYRNMXWT = module.OULQSMFSYRNMXWT;
    }, function (module) {
      MNQRQYTLR = module.MNQRQYTLR;
    }, function (module) {
      TBGHTYXGU = module.TBGHTYXGU;
    }, function (module) {
      MYKRDT = module.MYKRDT;
    }, function (module) {
      LIGHOZ = module.LIGHOZ;
    }, function (module) {
      CJXOHZKFR = module.CJXOHZKFR;
    }, function (module) {
      MEMINEFUZFGAOP = module.MEMINEFUZFGAOP;
    }, function (module) {
      RTONERXYWGCD = module.RTONERXYWGCD;
    }, function (module) {
      QLHROXRCFBPYKY = module.QLHROXRCFBPYKY;
    }, function (module) {
      KENOHXMVJJSH = module.KENOHXMVJJSH;
    }],
    execute: function () {
      var _class;
      cclegacy._RF.push({}, "7aad8CWUx5Md66qfs5Cd/Nd", "CCIOERS", undefined);
      class CCIOERS {
        constructor() {
          this.XNLLTXPPIDZMAKWW = false;
          this.UTCWHNSSLM = {};
        }
        static MSCGDWEHBPVJEQE() {
          return this.BPVANCXHADQJFIH;
        }
        FRTZJETVAAWTCK(IWKKWOKORYUHWP) {
          let ctrl = this.UTCWHNSSLM[IWKKWOKORYUHWP];
          if (null == ctrl) {
            switch (IWKKWOKORYUHWP) {
              case PDWTAEXGRLKYCOL.LQOPZECGDFETBH:
                ctrl = AKHOCOQOOYH.MSCGDWEHBPVJEQE();
                break;
              case PDWTAEXGRLKYCOL.EBRVJXLSPJUZ:
                ctrl = new SDYSTNCVGG();
                break;
              case PDWTAEXGRLKYCOL.QAWGKUNMWHJHXKY:
                ctrl = new RHNDXTSQQCUFJ();
                break;
              case PDWTAEXGRLKYCOL.CZLGMGUCADMLDG:
                ctrl = new AHGNGYYNSSRZ();
                break;
              case PDWTAEXGRLKYCOL.JEKILZGLT:
                ctrl = new YJPHBDNICBXPNH();
                break;
              case PDWTAEXGRLKYCOL.QQUEEYIFYIE:
                ctrl = new VBWBHDOLKCQNA();
                break;
              case PDWTAEXGRLKYCOL.CEZHDRFCMQDJNJEA:
                ctrl = new TAMEBDDEGGUCY();
                break;
              case PDWTAEXGRLKYCOL.XMJPJJJEHC:
                ctrl = new TBGHTYXGU();
                break;
              case PDWTAEXGRLKYCOL.AQSQVVWGMOVHR:
                ctrl = new MYKRDT();
                break;
              case PDWTAEXGRLKYCOL.NOVARZNASXIXIL:
                ctrl = new OULQSMFSYRNMXWT();
                break;
              case PDWTAEXGRLKYCOL.NFEEMYOAWPHOKYKV:
                ctrl = new MNQRQYTLR();
                break;
              case PDWTAEXGRLKYCOL.JDWTMRORCA:
                ctrl = new LIGHOZ();
                break;
              case PDWTAEXGRLKYCOL.XFPIWEXSB:
                ctrl = new MEMINEFUZFGAOP();
                break;
              case PDWTAEXGRLKYCOL.QGCJSY:
                ctrl = new RTONERXYWGCD();
                break;
              case PDWTAEXGRLKYCOL.YHMSAUTGPWRWUI:
                ctrl = new QLHROXRCFBPYKY();
                break;
              case PDWTAEXGRLKYCOL.ZVTVOUVPFTQBZVBN:
                ctrl = new KENOHXMVJJSH();
                break;
            }
          }
          if (ctrl != null) {
            ctrl.IWKKWOKORYUHWP = IWKKWOKORYUHWP;
            this.UTCWHNSSLM[IWKKWOKORYUHWP] = ctrl;
          }
          return ctrl;
        }
        UPBJPLZNBTKDE(IWKKWOKORYUHWP) {
          let ctrl = this.UTCWHNSSLM[IWKKWOKORYUHWP];
          if (null == ctrl) {
            return this.FRTZJETVAAWTCK(IWKKWOKORYUHWP);
          }
          return ctrl;
        }
        SDFLIQOQYBBXD(AFCDCGSWUQHRUY) {
          if (!this.XNLLTXPPIDZMAKWW) {
            this.WTPEMNO(AFCDCGSWUQHRUY);
          }
          return CCIOERS.MSCGDWEHBPVJEQE().JEKILZGLT().SDFLIQOQYBBXD(AFCDCGSWUQHRUY);
        }
        WTPEMNO(AFCDCGSWUQHRUY) {
          if (this.XNLLTXPPIDZMAKWW) {
            return;
          }
          PQBRALKRA.WTPEMNO();
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().OFFOKOFJKQJKUV(AFCDCGSWUQHRUY);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.LQOPZECGDFETBH);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.EBRVJXLSPJUZ);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.QAWGKUNMWHJHXKY);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.CZLGMGUCADMLDG);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.JEKILZGLT);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.QQUEEYIFYIE);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.CEZHDRFCMQDJNJEA);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.ZVTVOUVPFTQBZVBN);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.XMJPJJJEHC);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.AQSQVVWGMOVHR);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.NOVARZNASXIXIL);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.NFEEMYOAWPHOKYKV);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.JDWTMRORCA);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.XFPIWEXSB);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.QGCJSY);
          this.FRTZJETVAAWTCK(PDWTAEXGRLKYCOL.YHMSAUTGPWRWUI);

          // @ts-ignore
          for (let m_key in this.UTCWHNSSLM) {
            this.UTCWHNSSLM[m_key].CRNHYR();
          }
          if (!PQBRALKRA.OTORTMMYVD) {
            AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().WTPEMNO(AFCDCGSWUQHRUY);
          }
          CJXOHZKFR.IBZTRH();
          this.XNLLTXPPIDZMAKWW = true;
        }
        EBRVJXLSPJUZ() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.EBRVJXLSPJUZ);
        }
        QAWGKUNMWHJHXKY() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.QAWGKUNMWHJHXKY);
        }
        CZLGMGUCADMLDG() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.CZLGMGUCADMLDG);
        }
        JEKILZGLT() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.JEKILZGLT);
        }
        QQUEEYIFYIE() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.QQUEEYIFYIE);
        }
        CEZHDRFCMQDJNJEA() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.CEZHDRFCMQDJNJEA);
        }
        XMJPJJJEHC() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.XMJPJJJEHC);
        }
        AQSQVVWGMOVHR() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.AQSQVVWGMOVHR);
        }
        NOVARZNASXIXIL() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.NOVARZNASXIXIL);
        }
        NFEEMYOAWPHOKYKV() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.NFEEMYOAWPHOKYKV);
        }
        DHLOALGFTSBMQN() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.JDWTMRORCA);
        }
        XFPIWEXSB() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.XFPIWEXSB);
        }
        QGCJSY() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.QGCJSY);
        }
        WONSAGFRQLJ() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.YHMSAUTGPWRWUI);
        }
        ZVTVOUVPFTQBZVBN() {
          return this.UPBJPLZNBTKDE(PDWTAEXGRLKYCOL.ZVTVOUVPFTQBZVBN);
        }
      }
      exports('CCIOERS', CCIOERS);
      _class = CCIOERS;
      CCIOERS.BPVANCXHADQJFIH = new _class();
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/celebrate-agent.ts", ['cc', './svg-util.ts', './game-res-manager.ts', './card.ts', './card-constants.ts', './card-data.ts', './card-render.ts', './random-util.ts', './log-util.ts'], function (exports) {
  var cclegacy, director, UITransform, Vec3, SvgUtil, GameResManager, Card, CardPoint, CardData, CardRender, RandomUtil, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
      UITransform = module.UITransform;
      Vec3 = module.Vec3;
    }, function (module) {
      SvgUtil = module.SvgUtil;
    }, function (module) {
      GameResManager = module.GameResManager;
    }, function (module) {
      Card = module.Card;
    }, function (module) {
      CardPoint = module.CardPoint;
    }, function (module) {
      CardData = module.CardData;
    }, function (module) {
      CardRender = module.CardRender;
    }, function (module) {
      RandomUtil = module.RandomUtil;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      cclegacy._RF.push({}, "81b734B7XNA2qEmQaN7U2ZE", "celebrate-agent", undefined);
      class CelebrateAgent {
        constructor(desk) {
          this._desk = null;
          this._originPaths = [SvgUtil.svgPathClub, SvgUtil.svgPathDiamond, SvgUtil.svgPathHeart, SvgUtil.svgPathSpade];
          this._usingPaths = [];
          this._desk = desk;
        }
        getNextPath() {
          if (this._usingPaths.length === 0) {
            this._usingPaths = Array.from(this._originPaths);
            this._usingPaths = RandomUtil.shuffle(this._usingPaths);
          }
          return this._usingPaths.shift();
        }
        excute() {
          // let cardNodes = GameResManager.instance.getAllLiteCardNodes();
          let cardNodes = [];
          this.prepare(cardNodes);
          return this.celebrate(cardNodes);
        }
        prepare(cardNodes) {
          const desk = this._desk;
          const uiCanvas = director.getScene().getChildByPath('Canvas/uiCanvas');
          const splash = uiCanvas.getChildByName('splash');
          splash.active = true;
          const soltsInFoundation = desk.layoutFoundation.children;
          for (const slot of soltsInFoundation) {
            const lastCard = desk.getLastCardInFoundationSlot(slot);
            if (lastCard === null) {
              continue;
            }
            const suit = lastCard.getComponent(Card).cardSuit;
            for (let i = CardPoint.Ace; i <= CardPoint.King; i++) {
              const point = i;
              const cardData = new CardData(suit, point, false);
              const liteNode = GameResManager.instance.getLiteCardNode();
              liteNode.getComponent(CardRender).renderCard(cardData);
              cardNodes.push(liteNode);
              let pos = slot.getComponent(UITransform).convertToWorldSpaceAR(new Vec3(0, 0, 0));
              pos = uiCanvas.getComponent(UITransform).convertToNodeSpaceAR(pos);
              liteNode.position = pos;
              liteNode.active = true;
              uiCanvas.addChild(liteNode);
            }
          }
          desk.clearDesk();
        }
        cleanUp(cardNodes) {
          const uiCanvas = director.getScene().getChildByPath('Canvas/uiCanvas');
          const splash = uiCanvas.getChildByName('splash');
          splash.active = false;
          this._desk.unscheduleAllCallbacks();
          cardNodes.forEach(cardNode => {
            GameResManager.instance.putLiteCardNode(cardNode);
          });
        }

        /**
         * 让卡牌沿 Hearts 型路径流动
         * @param desk 游戏桌面
         * @param cardNodes 卡牌节点数组
         * @returns Promise<void>
         */
        celebrate(cardNodes) {
          if (cardNodes.length === 0) {
            return Promise.resolve();
          }
          const desk = this._desk;
          return new Promise(resolve => {
            LogUtil.log("Celebrating...");
            const uiCanvas = director.getScene().getChildByPath('Canvas/uiCanvas');
            const uiTransform = uiCanvas.getComponent(UITransform);
            const svgPath = this.getNextPath();
            const points = SvgUtil.samplePointsFromSvgPath(svgPath, cardNodes.length, uiTransform.width - 300);
            this.flowCardsAlongPath(desk, cardNodes, points);
            setTimeout(() => {
              LogUtil.log("Celebration complete!");
              this.cleanUp(cardNodes);
              resolve();
            }, 4000);
          });
        }
        secheduIndexMove(cardStates, totalPoints) {
          cardStates.forEach(state => {
            state.currentIndex = (state.currentIndex + 1) % totalPoints;
          });
        }
        scheduleNodeDelayStartMove(state) {
          if (state.node.isValid) {
            const parent = state.node.getParent();
            if (parent === null) {
              return;
            }
            state.node.removeFromParent();
            parent.addChild(state.node);
            state.canMove = true;
          }
        }
        scheduleNodeMove(cardStates, pathPoints) {
          cardStates.forEach(state => {
            const {
              node,
              currentIndex,
              canMove
            } = state;
            if (!canMove) {
              return;
            }
            // 获取当前路径点和下一个路径点
            const currentPoint = state.node.position.clone();
            const targetPoint = pathPoints[currentIndex].clone();
            const distance = Vec3.distance(currentPoint, targetPoint);

            // const dynamicSpeed = Math.min(0.2 + distance * 0.1, 0.4);

            // LogUtil.log("dynamicSpeed is:", dynamicSpeed);
            const dynamicSpeed = 0.3;
            const newPos = currentPoint.lerp(targetPoint, dynamicSpeed);
            node.setPosition(newPos);
          });
        }
        flowCardsAlongPath(desk, cardNodes, pathPoints) {
          const totalPoints = pathPoints.length;
          // 为每张卡牌初始化状态
          const cardStates = cardNodes.map((cardNode, cardIndex) => ({
            node: cardNode,
            currentIndex: cardIndex % totalPoints,
            // 当前路径点索引
            canMove: false
          }));

          // desk.schedule(() => {
          //     LogUtil.log("flowCardsAlongPath...schedule...111");
          //     cardStates.forEach((state) => {
          //         state.currentIndex = (state.currentIndex + 1) % totalPoints;
          //     });
          // }, 0.1);
          desk.schedule(this.secheduIndexMove.bind(this, cardStates, totalPoints), 0.05);
          const cardCount = cardStates.length;
          cardStates.forEach((state, index) => {
            desk.scheduleOnce(this.scheduleNodeDelayStartMove.bind(this, state), (cardCount - index) * 0.05);
          });
          desk.schedule(this.scheduleNodeMove.bind(this, cardStates, pathPoints), 0);
        }
      }
      exports('CelebrateAgent', CelebrateAgent);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/circular-mask.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, _decorator, Component, Graphics, Color, tween;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      _decorator = module._decorator;
      Component = module.Component;
      Graphics = module.Graphics;
      Color = module.Color;
      tween = module.tween;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "65461EBTRBJKamUJVEr2Xng", "circular-mask", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let CircularMask = exports('CircularMask', (_dec = ccclass('CircularMask'), _dec2 = property(Node), _dec(_class = (_class2 = class CircularMask extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "maskNode", _descriptor, this);
          // 遮罩节点
          this.initialRadius = 1080;
          // 初始圆形半径
          this.finalRadius = 320;
          // 最终圆形半径
          this.graphics = null;
        }
        onLoad() {
          // 获取 Graphics 组件
          this.graphics = this.maskNode.getComponent(Graphics);
        }
        drawCircle(radius) {
          this.graphics.clear(); // 清除之前的绘制
          this.graphics.fillColor = Color.BLACK; // 设置填充颜色为黑色
          this.graphics.circle(0, 40, radius); // 绘制圆形
          this.graphics.fill(); // 填充圆形
        }

        animate2Final(duration) {
          tween({
            radius: this.initialRadius
          }).to(duration, {
            radius: this.finalRadius
          }, {
            onUpdate: target => {
              this.drawCircle(target.radius); // 动态更新圆形半径
            }
          }).start();
        }
        animate2Initial(duration) {
          tween({
            radius: this.finalRadius
          }).to(duration, {
            radius: this.initialRadius
          }, {
            onUpdate: target => {
              this.drawCircle(target.radius); // 动态更新圆形半径
            }
          }).start();
        }
      }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "maskNode", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/CIVTVAVXRORTVD.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "72182nTjfRA+YlKN1iDsUE9", "CIVTVAVXRORTVD", undefined);
      /**
       * @author : jinshui
       * @date   : 2024/06/03 0022 22:10
       */
      class CIVTVAVXRORTVD {}
      exports('CIVTVAVXRORTVD', CIVTVAVXRORTVD);
      /**
       * sdk 版本
       */
      CIVTVAVXRORTVD.LTRYSYBPP = "1.1.1";
      CIVTVAVXRORTVD.MDCTJFAPWXRIFON = 4;
      CIVTVAVXRORTVD.TYAXQESPGDSRGBOS = "com.snap.adkit.AdKitAdapter";
      CIVTVAVXRORTVD.UHTYUGBDSDM = "OBGMYUHSPZ";
      CIVTVAVXRORTVD.WRAFJTHXGRDNODO = "QFGQDPW";
      CIVTVAVXRORTVD.OPQJAPSE = ['allOneMethod', 'init', 'videoTouchAction', 'isReadyVideoAd', 'openVideoAd', 'isReadyInterstitialAd', 'openInterstitialAd', 'openBannerAd', 'closeBannerAd', 'isReadyAppOpenAd', 'openAppOpenAd', 'showMediationDebugger', 'commonEventReport', 'logThirdEvent', 'openAppInGp', 'openWebOnBrowser', 'queryCommonData', "setLogcatEnable", "getCpConfig", "isBillingInitSuccess", "launchBillingFlow", "consumeBillingIapPurchase", "requestHttp", "showNewbyearIconAd", "hideNewbyearIconAd", "contactService", "getFaqUrl"];
      /**
       * 文档配置
       */
      CIVTVAVXRORTVD.UPNVTHPQOSZT = {
        "cocos": [{
          "pg_start": "org.cocos",
          "title": "cocos 2.2+ activity",
          "version": "s1_220"
        }, {
          "pg_start": "org.cocos",
          "title": "cocos 3.+ activity",
          "version": "s1_300"
        }, {
          "pg_start": "org",
          "title": "application",
          "version": "s1_app"
        }]
      };
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/CJXOHZKFR.ts", ['cc', './CCIOERS.ts'], function (exports) {
  var cclegacy, CCIOERS;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      CCIOERS = module.CCIOERS;
    }],
    execute: function () {
      cclegacy._RF.push({}, "d53a8FELWhOuZmhsy4YH4ug", "CJXOHZKFR", undefined);

      /**
       * @author : jinshui
       * @date   : 2024/9/27 0027 11:53
       *
       * // pp卡步骤
       "stuff_homepage":             pp卡卡槽展示
       "stuff_impression":           pp卡弹窗展示
       "stuff_click":                pp卡点击领取
       "stuff_get_success":          pp卡领取成功
       "stuff_impression_free":      pp卡免费奖励展示
       "stuff_click_free":           pp卡免费奖励点击
       "stuff_get_success_free":     pp卡免费奖励领取成功
       */
      class CJXOHZKFR {
        static IGXFCDIINLIFOQLM() {
          let eventName = "sdk_theme_stuff";
          let property = {
            "step": "stuff_homepage"
          };
          CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN(eventName, property);
        }
        static WDYXWDHX() {
          let eventName = "sdk_theme_stuff";
          let property = {
            "step": "stuff_impression"
          };
          CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN(eventName, property);
        }
        static XMGYNYKGAGOLMDW() {
          let eventName = "sdk_theme_stuff";
          let property = {
            "step": "stuff_click"
          };
          CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN(eventName, property);
        }
        static DIZUYVYWXWFRKAXH() {
          let eventName = "sdk_theme_stuff";
          let property = {
            "step": "stuff_get_success"
          };
          CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN(eventName, property);
        }
        static ARYHPYJLVTXGU() {
          let eventName = "sdk_theme_stuff";
          let property = {
            "step": "stuff_impression_free"
          };
          CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN(eventName, property);
        }
        static BZLOZQPQE() {
          let eventName = "sdk_theme_stuff";
          let property = {
            "step": "stuff_click_free"
          };
          CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN(eventName, property);
        }
        static JGEXBWTYOHB() {
          let eventName = "sdk_theme_stuff";
          let property = {
            "step": "stuff_get_success_free"
          };
          CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN(eventName, property);
        }
        static IBZTRH() {
          let eventName = "user_launcher_step";
          let property = {
            "step": "engine_initialized"
          };
          CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN(eventName, property);
        }
        static VFTLWTDIPJAH() {
          let eventName = "user_launcher_step";
          let property = {
            "step": "engine_invite_code"
          };
          CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN(eventName, property);
        }
        static WZIUVV(XPQDBGOMWCUIFIW = null) {
          CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN("game_life_key_node", XPQDBGOMWCUIFIW);
        }
        static UCVHOJDVSTUTMOX() {
          let eventName = "user_launcher_step";
          let property = {
            "step": "engine_show"
          };
          CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN(eventName, property);
        }
      }
      exports('CJXOHZKFR', CJXOHZKFR);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/common-util.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "94d26RIGOhF1Y/BHyLx/EOV", "common-util", undefined);
      class CommonUtil {
        static delay(ms) {
          return new Promise(resolve => setTimeout(resolve, ms));
        }
      }
      exports('CommonUtil', CommonUtil);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/config-agent.ts", ['cc', './config.ts', './request-manager.ts', './log-util.ts', './storage-manager.ts'], function (exports) {
  var cclegacy, Config, ReqeustManager, LogUtil, StorageManager;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      ReqeustManager = module.ReqeustManager;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      StorageManager = module.StorageManager;
    }],
    execute: function () {
      cclegacy._RF.push({}, "b703ajnGABM64wfSnkttSmi", "config-agent", undefined);
      let ConfigType = exports('ConfigType', /*#__PURE__*/function (ConfigType) {
        ConfigType["Base"] = "base";
        ConfigType["Main"] = "main";
        ConfigType["Store"] = "store";
        ConfigType["Web"] = "web";
        return ConfigType;
      }({}));
      class ConfigAgent {
        static fetchConfig() {
          return new Promise((resolve, reject) => {
            //Config.GAME_UUID
            LogUtil.log('fetchConfig:', Config.GAME_UUID, Config.API_URL, Config.GAME_VERSION);
            ReqeustManager.instance.post(`/${Config.GAME_UUID}/fetch/preset`, {
              code: Config.GAME_CODE,
              version: Config.GAME_VERSION
            }).then(data => {
              LogUtil.log('fetchConfig data welcome:', data);
              const payload = data['data']['payload'];
              if (Array.isArray(payload) && payload.length > 0) {
                for (const item of payload) {
                  const category = item['category'];
                  const config = item;
                  ConfigAgent.saveRawConfig(category, config);
                }
              }
              resolve();
            }).catch(error => {
              console.error('error fetchConfig:', error);
              // reject(error);
              resolve();
            });
          });
        }
        static getConfig(category) {
          const key = `config_${category}`;
          const obj = StorageManager.instance.getJson(key);
          if (!obj) {
            return null;
          }
          try {
            return JSON.parse(obj.content);
          } catch (err) {
            console.error(err);
          }
          return null;
        }
        getHash(category) {
          const key = `config_${category}`;
          const obj = StorageManager.instance.getJson(key);
          if (!obj) {
            return null;
          }
          return obj.contentHash;
        }
        static saveRawConfig(category, value) {
          const key = `config_${category}`;
          LogUtil.log('config agent saveRawConfig:', key, JSON.stringify(value));
          StorageManager.instance.set(key, JSON.stringify(value));
        }
      }
      exports('ConfigAgent', ConfigAgent);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/config.ts", ['cc', './gm-manager.ts', './game-data-manager.ts', './report-agent.ts'], function (exports) {
  var cclegacy, sys, director, GmManager, GameDataManager, ReportAgent, CustomReportEvent;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      sys = module.sys;
      director = module.director;
    }, function (module) {
      GmManager = module.GmManager;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
    }],
    execute: function () {
      cclegacy._RF.push({}, "f022azPwIxNHrdahBxaHnFf", "config", undefined);
      let ConfigEvent = exports('ConfigEvent', /*#__PURE__*/function (ConfigEvent) {
        ConfigEvent["FLAG_CHANGED"] = "flag_changed";
        return ConfigEvent;
      }({}));
      class Config {
        static get GAME_CODE() {
          switch (sys.platform) {
            case sys.Platform.ANDROID:
              return "gpsgdesota";
            case sys.Platform.IOS:
              return "sgsota";
            default:
              return "sgsota";
          }
        }
        static get ENABLE_WEB() {
          // const no_web_version = RewardManager.instance.getConfig().no_web_version || [];
          // return no_web_version.indexOf(this.GAME_VERSION) < 0 && this.getRFlag();
          return false;
        }
        static get FULL_MODE() {
          // return Config.INIT_FETCH_DATA && (this.R_FLAG || GameDataManager.instance.localData.lastRFlag || GmManager.instance.isStoreShow) && MountManager.instance.has(MountPoint.HasStore);
          return false;
        }
        static setRFlag(val) {
          if (this.firstSetFlagTime > 0 && val) {
            this.flagChangeDuration = Math.floor((Date.now() - this.firstSetFlagTime) / 1000);
          }
          this.isFlagChanged = true;
          this.R_FLAG = val;
          if (val) {
            ReportAgent.reportCustomEvent(CustomReportEvent.SDK_THEME_STUFF, {
              step: 'game_on'
            });
          } else {
            ReportAgent.reportCustomEvent(CustomReportEvent.SDK_THEME_STUFF, {
              step: 'game_off'
            });
          }
          GameDataManager.instance.localData.lastRFlag = val;
          GameDataManager.instance.saveData();
          director.emit(ConfigEvent.FLAG_CHANGED);
        }
        static getRFlag() {
          console.log(`getRFlag: gm-${GmManager.instance.RFlag} || R_FLAG-${this.R_FLAG} || last-${GameDataManager.instance.localData.lastRFlag}`);
          return GmManager.instance.RFlag || this.R_FLAG || GameDataManager.instance.localData.lastRFlag;
        }
      }
      exports('Config', Config);
      //注意：native 请在 game.config.json中配置，然后由native回传
      Config.API_URL = 'https://beta-boost.mix-fun.com';
      Config.GAME_UUID = "B102536CFFFF46409AA5BCB521AD6BB8";
      Config.PACKAGE = "com.homepage.quickly.crystal";
      Config.SG_GRAPH_HOST = "https://static2.sotapubs.net";
      Config.GAME_VERSION = "1.0.0";
      Config.MAIL = "arnulfo@tjca.us";
      Config.DEBUG = true;
      Config.MEM = 0;
      // GM
      Config.LANG_CODE = 'en';
      Config.COUNTRY_CODE = 'US';
      Config.R_FLAG = false;
      Config.INIT_FETCH_DATA = false;
      Config.firstSetFlagTime = 0;
      Config.isFlagChanged = false;
      Config.flagChangeDuration = 0;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/connect-agent.ts", ['cc', './config.ts', './ad-agent.ts', './game-data-manager.ts', './CCIOERS.ts', './bridge-event.ts', './log-util.ts', './native-agent.ts'], function (exports) {
  var cclegacy, sys, Config, AdAgent, GameDataManager, CCIOERS, BridgeEvent, LogUtil, NativeAgent;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      sys = module.sys;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      AdAgent = module.AdAgent;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      CCIOERS = module.CCIOERS;
    }, function (module) {
      BridgeEvent = module.BridgeEvent;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      NativeAgent = module.NativeAgent;
    }],
    execute: function () {
      cclegacy._RF.push({}, "ae554v9pNRH568sn44Tu3dE", "connect-agent", undefined);
      // import { GameSDKCore } from "./sdk/RoundPro/GameSDKCore";
      // import { ReferralCodeListener } from "./sdk/RoundPro/GameplayFeature/ReferralPanel";
      // import { PaletteObserver } from "./sdk/RoundPro/GameplayFeature/StylePanel";
      // import { MediaListener } from "./sdk/RoundPro/GameplayFeature/MediaPanel";
      // import { InterstitialNotifier } from "./sdk/RoundPro/GameplayFeature/FullScreenManager";

      class ConnectAgent {
        static init() {
          console.log('Connect init doc begin, ', 'is debug:', Config.DEBUG, 'Package:', Config.PACKAGE);
          console.log('Connect init doc begin, ', 'sys.isBrowser:' + sys.isBrowser, 'sys.isNative:', sys.isNative, 'sys.os:', sys.os, 'sys.os === sys.OS.ANDROID:', sys.os === sys.OS.ANDROID);
          // if (sys.isBrowser && !sys.isNative) {
          //     let doc = KQRJDXUHNQK.PZARRBJXQOQGWWN().MAZAISSKZ(Config._PACKAGE.prod);  
          //     console.log('doc:', doc);  
          // }

          if (!sys.isBrowser) {
            this.steupListener();
            switch (sys.os) {
              case sys.OS.IOS:
                {
                  console.log('Connect init iOS');
                  NativeAgent.dispatchEventToNative(BridgeEvent.sdk_init);
                }
                break;
              case sys.OS.ANDROID:
                {
                  console.log('Connect init Android111');
                  CCIOERS.MSCGDWEHBPVJEQE().WTPEMNO(Config.PACKAGE);
                  console.log('Connect init Android222');
                }
                break;
            }
          } else {
            let doc = CCIOERS.MSCGDWEHBPVJEQE().SDFLIQOQYBBXD('com.card.stress.need');
            console.log('doc:', doc);
          }
        }
        static steupListener() {
          if (sys.isBrowser) {
            return;
          }
          switch (sys.os) {
            case sys.OS.ANDROID:
              {
                // 用户邀请码
                CCIOERS.MSCGDWEHBPVJEQE().NOVARZNASXIXIL().OOAMLKPOOJQXYVF(new MyInviteCodeListener());

                //兑换开关
                CCIOERS.MSCGDWEHBPVJEQE().NFEEMYOAWPHOKYKV().OQBJDNV(new MyThemeListener());

                //横幅广告
                CCIOERS.MSCGDWEHBPVJEQE().XMJPJJJEHC().RQAVMUZF(new MyBannerListener());

                //设置视频广告监听
                CCIOERS.MSCGDWEHBPVJEQE().EBRVJXLSPJUZ().ZPJDWIDCHI(new MyVideoAdListener());

                //插屏广告
                CCIOERS.MSCGDWEHBPVJEQE().QAWGKUNMWHJHXKY().QQHBFNGENLK(new MyInterstitialAdListener());
              }
              break;
          }
        }
        static openTestAd() {
          if (sys.os == sys.OS.ANDROID) {
            CCIOERS.MSCGDWEHBPVJEQE().JEKILZGLT().EBZYRKYXFPTJCTAV();
          } else if (sys.os == sys.OS.IOS) {
            NativeAgent.dispatchEventToNative(BridgeEvent.sdk_ad_debug);
          }
        }
        static openVideoAd(entry) {
          console.error('addd openVideoAd entry:', entry);
          // return GameSDKCore.initializeInstance().movieClip().displayImmediateMediaAd(entry);

          if (sys.isBrowser) {
            return true;
          }
          switch (sys.os) {
            case sys.OS.ANDROID:
              {
                let hasVideo = CCIOERS.MSCGDWEHBPVJEQE().EBRVJXLSPJUZ().LHAKYKQVTTJC(entry);
                let showVideo = false;
                if (hasVideo) {
                  showVideo = CCIOERS.MSCGDWEHBPVJEQE().EBRVJXLSPJUZ().WUMMTYU(entry);
                }
                if (showVideo) {
                  console.log('adagent show Video:', showVideo);
                  return showVideo;
                } else {
                  AdAgent.videoAd.onVideoNotReady({
                    entry: entry
                  });
                }
              }
              break;
            case sys.OS.IOS:
              {
                NativeAgent.dispatchEventToNative(BridgeEvent.sdk_ad_reward);
              }
              break;
          }
          return false;
        }
        static openInterstitialAd(entry) {
          console.error('addd openInterstitialAd entry:', entry);
          if (sys.isBrowser) {
            return true;
          }
          switch (sys.os) {
            case sys.OS.ANDROID:
              {
                // 查询是否有插屏广告
                let showInterstitial = false;
                let isReady = CCIOERS.MSCGDWEHBPVJEQE().QAWGKUNMWHJHXKY().PYQUCSIIH(entry);
                if (isReady) {
                  console.log('adagent show Interstitial:', isReady);
                  showInterstitial = CCIOERS.MSCGDWEHBPVJEQE().QAWGKUNMWHJHXKY().XOUECKSDJND(entry);
                }
                if (showInterstitial) {
                  console.log('adagent show Interstitial:', showInterstitial);
                  return showInterstitial;
                } else {
                  AdAgent.interstitialAd.onInterstitialNotReady({
                    entry: entry
                  });
                }
              }
              break;
            case sys.OS.IOS:
              {
                NativeAgent.dispatchEventToNative(BridgeEvent.sdk_ad_inters);
              }
              break;
          }
          return false;
        }
        static onConnectEvent(event) {
          LogUtil.log("onConnectEvent", event);
          const data = JSON.parse(event);
          if (data.type === "reward") {
            switch (data.param) {
              case "display":
                AdAgent.videoAd.onVideoAdStart({
                  entry: ""
                });
                break;
              case "not_ready":
                AdAgent.videoAd.onVideoNotReady({
                  entry: ""
                });
                break;
              case "close":
                AdAgent.videoAd.onVideoClosed({
                  entry: ""
                });
                break;
              case "rewarded":
                AdAgent.videoAd.onVideoComplete({
                  entry: ""
                });
                break;
            }
          } else if (data.type === "invite_code") {
            const code = data.param;
            GameDataManager.instance.setPlayerInviteCode(code);
          } else if (data.type === "theme") {
            const theme = data.param;
            Config.setRFlag(theme);
          } else if (data.type === "inters") {
            switch (data.param) {
              case "display":
                AdAgent.interstitialAd.onInterstitialStart({
                  entry: ""
                });
                break;
              case "not_ready":
                AdAgent.interstitialAd.onInterstitialNotReady({
                  entry: ""
                });
                break;
              case "close":
                AdAgent.interstitialAd.onInterstitialClosed({
                  entry: ""
                });
                break;
            }
          }
        }
        static reportCustomEvent(event, params) {
          if (sys.isBrowser) {
            return;
          }
          if (sys.os == sys.OS.ANDROID) {
            CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN(event, params);
          } else if (sys.os == sys.OS.IOS) {
            NativeAgent.dispatchEventToNative(BridgeEvent.sdk_report_data, JSON.stringify({
              event: event,
              params: params
            }));
          }
        }
        static reportThemeEvent(event, params) {}
      }
      exports('ConnectAgent', ConnectAgent);
      class MyInviteCodeListener {
        TRCAMWXHVKVILMO(code) {
          // 这里可以获取到需要的邀请码
          console.log('MyInviteCodeListener:', code);
          GameDataManager.instance.setPlayerInviteCode(code);
        }
      }
      class MyThemeListener {
        GGOEUNELMFVB(newTheme) {
          // AppsFlyerDemo.INSTANCE.logPrint("[Listener] newTheme: " + newTheme);
          console.log('MyThemeListener newTheme:', newTheme);
          Config.setRFlag(newTheme);
        }
      }
      class MyBannerListener {
        XXGFAIDUZP(ad) {
          // 横幅广告展示回调
        }
        WXLRAMSMF(ad) {
          // 横幅广告点击回调
        }
        UVFJIQCIL(ad) {
          // 横幅广告关闭回调
        }
      }
      class MyVideoAdListener {
        HGGNPG(par_ad_par) {
          AdAgent.videoAd.onVideoAdStart({
            entry: par_ad_par.entry
          });
        }
        WASOVBLBVPPJBHMG(par_ad_par) {
          AdAgent.videoAd.onVideoClick({
            entry: par_ad_par.entry
          });
        }
        NUVJWDOUNYDWG(par_ad_par) {
          AdAgent.videoAd.onVideoClosed({
            entry: par_ad_par.entry
          });
        }
        GKDTHXPMZJTYHU(par_ad_par) {
          AdAgent.videoAd.onVideoComplete({
            entry: par_ad_par.entry
          });
        }
        XWFUQTQPSCVLJYL(par_ad_par) {
          AdAgent.videoAd.onAdRevenue({
            entry: par_ad_par.entry
          });
        }
      }
      class MyInterstitialAdListener {
        TGDSIXDAK(par_ad_par) {
          AdAgent.interstitialAd.onInterstitialStart({
            entry: par_ad_par.entry
          });
        }
        NQRUAAO(par_ad_par) {
          AdAgent.interstitialAd.onInterstitialClick({
            entry: par_ad_par.entry
          });
        }
        ZORHXXXEEY(par_ad_par) {
          AdAgent.interstitialAd.onInterstitialClosed({
            entry: par_ad_par.entry
          });
        }
        XWFUQTQPSCVLJYL(par_ad_par) {
          AdAgent.interstitialAd.onAdRevenue({
            entry: par_ad_par.entry
          });
        }
      }
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/CryptoES.js", ['./cjs-loader.mjs'], function (exports, module) {
  var loader;
  return {
    setters: [function (module) {
      loader = module.default;
    }],
    execute: function () {
      exports('default', void 0);
      let _cjsExports;
      const __cjsMetaURL = exports('__cjsMetaURL', module.meta.url);
      loader.define(__cjsMetaURL, function (exports$1, require, module, __filename, __dirname) {
        (function (root, factory) {
          if (typeof exports$1 === "object") {
            // CommonJS
            module.exports = exports$1 = factory();
          } else if (typeof define === "function" && define.amd) {
            // AMD
            define([], factory);
          } else {
            // Global (browser)
            root.CryptoJS = factory();
          }
        })(this, function () {
          /**
           * CryptoJS core components.
           */
          var CryptoJS = CryptoJS || function (Math, undefined$1) {
            /*
             * Local polyfil of Object.create
             */
            var create = Object.create || function () {
              function F() {}
              return function (obj) {
                var subtype;
                F.prototype = obj;
                subtype = new F();
                F.prototype = null;
                return subtype;
              };
            }();

            /**
             * CryptoJS namespace.
             */
            var C = {};

            /**
             * Library namespace.
             */
            var C_lib = C.lib = {};

            /**
             * Base object for prototypal inheritance.
             */
            var Base = C_lib.Base = function () {
              return {
                /**
                 * Creates a new object that inherits from this object.
                 *
                 * @param {Object} overrides Properties to copy into the new object.
                 *
                 * @return {Object} The new object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var MyType = CryptoJS.lib.Base.extend({
                 *         field: 'value',
                 *
                 *         method: function () {
                 *         }
                 *     });
                 */
                extend: function (overrides) {
                  // Spawn
                  var subtype = create(this);

                  // Augment
                  if (overrides) {
                    subtype.mixIn(overrides);
                  }

                  // Create default initializer
                  if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
                    subtype.init = function () {
                      subtype.$super.init.apply(this, arguments);
                    };
                  }

                  // Initializer's prototype is the subtype object
                  subtype.init.prototype = subtype;

                  // Reference supertype
                  subtype.$super = this;
                  return subtype;
                },
                /**
                 * Extends this object and runs the init method.
                 * Arguments to create() will be passed to init().
                 *
                 * @return {Object} The new object.
                 *
                 * @static
                 *
                 * @example
                 *
                 *     var instance = MyType.create();
                 */
                create: function () {
                  var instance = this.extend();
                  instance.init.apply(instance, arguments);
                  return instance;
                },
                /**
                 * Initializes a newly created object.
                 * Override this method to add some logic when your objects are created.
                 *
                 * @example
                 *
                 *     var MyType = CryptoJS.lib.Base.extend({
                 *         init: function () {
                 *             // ...
                 *         }
                 *     });
                 */
                init: function () {},
                /**
                 * Copies properties into this object.
                 *
                 * @param {Object} properties The properties to mix in.
                 *
                 * @example
                 *
                 *     MyType.mixIn({
                 *         field: 'value'
                 *     });
                 */
                mixIn: function (properties) {
                  for (var propertyName in properties) {
                    if (properties.hasOwnProperty(propertyName)) {
                      this[propertyName] = properties[propertyName];
                    }
                  }

                  // IE won't copy toString using the loop above
                  if (properties.hasOwnProperty('toString')) {
                    this.toString = properties.toString;
                  }
                },
                /**
                 * Creates a copy of this object.
                 *
                 * @return {Object} The clone.
                 *
                 * @example
                 *
                 *     var clone = instance.clone();
                 */
                clone: function () {
                  return this.init.prototype.extend(this);
                }
              };
            }();

            /**
             * An array of 32-bit words.
             *
             * @property {Array} words The array of 32-bit words.
             * @property {number} sigBytes The number of significant bytes in this word array.
             */
            var WordArray = C_lib.WordArray = Base.extend({
              /**
               * Initializes a newly created word array.
               *
               * @param {Array} words (Optional) An array of 32-bit words.
               * @param {number} sigBytes (Optional) The number of significant bytes in the words.
               *
               * @example
               *
               *     var wordArray = CryptoJS.lib.WordArray.create();
               *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
               *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
               */
              init: function (words, sigBytes) {
                words = this.words = words || [];
                if (sigBytes != undefined$1) {
                  this.sigBytes = sigBytes;
                } else {
                  this.sigBytes = words.length * 4;
                }
              },
              /**
               * Converts this word array to a string.
               *
               * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
               *
               * @return {string} The stringified word array.
               *
               * @example
               *
               *     var string = wordArray + '';
               *     var string = wordArray.toString();
               *     var string = wordArray.toString(CryptoJS.enc.Utf8);
               */
              toString: function (encoder) {
                return (encoder || Hex).stringify(this);
              },
              /**
               * Concatenates a word array to this word array.
               *
               * @param {WordArray} wordArray The word array to append.
               *
               * @return {WordArray} This word array.
               *
               * @example
               *
               *     wordArray1.concat(wordArray2);
               */
              concat: function (wordArray) {
                // Shortcuts
                var thisWords = this.words;
                var thatWords = wordArray.words;
                var thisSigBytes = this.sigBytes;
                var thatSigBytes = wordArray.sigBytes;

                // Clamp excess bits
                this.clamp();

                // Concat
                if (thisSigBytes % 4) {
                  // Copy one byte at a time
                  for (var i = 0; i < thatSigBytes; i++) {
                    var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                    thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
                  }
                } else {
                  // Copy one word at a time
                  for (var i = 0; i < thatSigBytes; i += 4) {
                    thisWords[thisSigBytes + i >>> 2] = thatWords[i >>> 2];
                  }
                }
                this.sigBytes += thatSigBytes;

                // Chainable
                return this;
              },
              /**
               * Removes insignificant bits.
               *
               * @example
               *
               *     wordArray.clamp();
               */
              clamp: function () {
                // Shortcuts
                var words = this.words;
                var sigBytes = this.sigBytes;

                // Clamp
                words[sigBytes >>> 2] &= 0xffffffff << 32 - sigBytes % 4 * 8;
                words.length = Math.ceil(sigBytes / 4);
              },
              /**
               * Creates a copy of this word array.
               *
               * @return {WordArray} The clone.
               *
               * @example
               *
               *     var clone = wordArray.clone();
               */
              clone: function () {
                var clone = Base.clone.call(this);
                clone.words = this.words.slice(0);
                return clone;
              },
              /**
               * Creates a word array filled with random bytes.
               *
               * @param {number} nBytes The number of random bytes to generate.
               *
               * @return {WordArray} The random word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.lib.WordArray.random(16);
               */
              random: function (nBytes) {
                var words = [];
                var r = function (m_w) {
                  var m_w = m_w;
                  var m_z = 0x3ade68b1;
                  var mask = 0xffffffff;
                  return function () {
                    m_z = 0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10) & mask;
                    m_w = 0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10) & mask;
                    var result = (m_z << 0x10) + m_w & mask;
                    result /= 0x100000000;
                    result += 0.5;
                    return result * (Math.random() > .5 ? 1 : -1);
                  };
                };
                for (var i = 0, rcache; i < nBytes; i += 4) {
                  var _r = r((rcache || Math.random()) * 0x100000000);
                  rcache = _r() * 0x3ade67b7;
                  words.push(_r() * 0x100000000 | 0);
                }
                return new WordArray.init(words, nBytes);
              }
            });

            /**
             * Encoder namespace.
             */
            var C_enc = C.enc = {};

            /**
             * Hex encoding strategy.
             */
            var Hex = C_enc.Hex = {
              /**
               * Converts a word array to a hex string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The hex string.
               *
               * @static
               *
               * @example
               *
               *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
               */
              stringify: function (wordArray) {
                // Shortcuts
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;

                // Convert
                var hexChars = [];
                for (var i = 0; i < sigBytes; i++) {
                  var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                  hexChars.push((bite >>> 4).toString(16));
                  hexChars.push((bite & 0x0f).toString(16));
                }
                return hexChars.join('');
              },
              /**
               * Converts a hex string to a word array.
               *
               * @param {string} hexStr The hex string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
               */
              parse: function (hexStr) {
                // Shortcut
                var hexStrLength = hexStr.length;

                // Convert
                var words = [];
                for (var i = 0; i < hexStrLength; i += 2) {
                  words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
                }
                return new WordArray.init(words, hexStrLength / 2);
              }
            };

            /**
             * Latin1 encoding strategy.
             */
            var Latin1 = C_enc.Latin1 = {
              /**
               * Converts a word array to a Latin1 string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The Latin1 string.
               *
               * @static
               *
               * @example
               *
               *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
               */
              stringify: function (wordArray) {
                // Shortcuts
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;

                // Convert
                var latin1Chars = [];
                for (var i = 0; i < sigBytes; i++) {
                  var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                  latin1Chars.push(String.fromCharCode(bite));
                }
                return latin1Chars.join('');
              },
              /**
               * Converts a Latin1 string to a word array.
               *
               * @param {string} latin1Str The Latin1 string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
               */
              parse: function (latin1Str) {
                // Shortcut
                var latin1StrLength = latin1Str.length;

                // Convert
                var words = [];
                for (var i = 0; i < latin1StrLength; i++) {
                  words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << 24 - i % 4 * 8;
                }
                return new WordArray.init(words, latin1StrLength);
              }
            };

            /**
             * UTF-8 encoding strategy.
             */
            var Utf8 = C_enc.Utf8 = {
              /**
               * Converts a word array to a UTF-8 string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The UTF-8 string.
               *
               * @static
               *
               * @example
               *
               *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
               */
              stringify: function (wordArray) {
                try {
                  return decodeURIComponent(escape(Latin1.stringify(wordArray)));
                } catch (e) {
                  throw new Error('Malformed UTF-8 data');
                }
              },
              /**
               * Converts a UTF-8 string to a word array.
               *
               * @param {string} utf8Str The UTF-8 string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
               */
              parse: function (utf8Str) {
                return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
              }
            };

            /**
             * Abstract buffered block algorithm template.
             *
             * The property blockSize must be implemented in a concrete subtype.
             *
             * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
             */
            var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
              /**
               * Resets this block algorithm's data buffer to its initial state.
               *
               * @example
               *
               *     bufferedBlockAlgorithm.reset();
               */
              reset: function () {
                // Initial values
                this._data = new WordArray.init();
                this._nDataBytes = 0;
              },
              /**
               * Adds new data to this block algorithm's buffer.
               *
               * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
               *
               * @example
               *
               *     bufferedBlockAlgorithm._append('data');
               *     bufferedBlockAlgorithm._append(wordArray);
               */
              _append: function (data) {
                // Convert string to WordArray, else assume WordArray already
                if (typeof data == 'string') {
                  data = Utf8.parse(data);
                }

                // Append
                this._data.concat(data);
                this._nDataBytes += data.sigBytes;
              },
              /**
               * Processes available data blocks.
               *
               * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
               *
               * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
               *
               * @return {WordArray} The processed data.
               *
               * @example
               *
               *     var processedData = bufferedBlockAlgorithm._process();
               *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
               */
              _process: function (doFlush) {
                // Shortcuts
                var data = this._data;
                var dataWords = data.words;
                var dataSigBytes = data.sigBytes;
                var blockSize = this.blockSize;
                var blockSizeBytes = blockSize * 4;

                // Count blocks ready
                var nBlocksReady = dataSigBytes / blockSizeBytes;
                if (doFlush) {
                  // Round up to include partial blocks
                  nBlocksReady = Math.ceil(nBlocksReady);
                } else {
                  // Round down to include only full blocks,
                  // less the number of blocks that must remain in the buffer
                  nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
                }

                // Count words ready
                var nWordsReady = nBlocksReady * blockSize;

                // Count bytes ready
                var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

                // Process blocks
                if (nWordsReady) {
                  for (var offset = 0; offset < nWordsReady; offset += blockSize) {
                    // Perform concrete-algorithm logic
                    this._doProcessBlock(dataWords, offset);
                  }

                  // Remove processed words
                  var processedWords = dataWords.splice(0, nWordsReady);
                  data.sigBytes -= nBytesReady;
                }

                // Return processed words
                return new WordArray.init(processedWords, nBytesReady);
              },
              /**
               * Creates a copy of this object.
               *
               * @return {Object} The clone.
               *
               * @example
               *
               *     var clone = bufferedBlockAlgorithm.clone();
               */
              clone: function () {
                var clone = Base.clone.call(this);
                clone._data = this._data.clone();
                return clone;
              },
              _minBufferSize: 0
            });

            /**
             * Abstract hasher template.
             *
             * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
             */
            var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
              /**
               * Configuration options.
               */
              cfg: Base.extend(),
              /**
               * Initializes a newly created hasher.
               *
               * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
               *
               * @example
               *
               *     var hasher = CryptoJS.algo.SHA256.create();
               */
              init: function (cfg) {
                // Apply config defaults
                this.cfg = this.cfg.extend(cfg);

                // Set initial values
                this.reset();
              },
              /**
               * Resets this hasher to its initial state.
               *
               * @example
               *
               *     hasher.reset();
               */
              reset: function () {
                // Reset data buffer
                BufferedBlockAlgorithm.reset.call(this);

                // Perform concrete-hasher logic
                this._doReset();
              },
              /**
               * Updates this hasher with a message.
               *
               * @param {WordArray|string} messageUpdate The message to append.
               *
               * @return {Hasher} This hasher.
               *
               * @example
               *
               *     hasher.update('message');
               *     hasher.update(wordArray);
               */
              update: function (messageUpdate) {
                // Append
                this._append(messageUpdate);

                // Update the hash
                this._process();

                // Chainable
                return this;
              },
              /**
               * Finalizes the hash computation.
               * Note that the finalize operation is effectively a destructive, read-once operation.
               *
               * @param {WordArray|string} messageUpdate (Optional) A final message update.
               *
               * @return {WordArray} The hash.
               *
               * @example
               *
               *     var hash = hasher.finalize();
               *     var hash = hasher.finalize('message');
               *     var hash = hasher.finalize(wordArray);
               */
              finalize: function (messageUpdate) {
                // Final message update
                if (messageUpdate) {
                  this._append(messageUpdate);
                }

                // Perform concrete-hasher logic
                var hash = this._doFinalize();
                return hash;
              },
              blockSize: 512 / 32,
              /**
               * Creates a shortcut function to a hasher's object interface.
               *
               * @param {Hasher} hasher The hasher to create a helper for.
               *
               * @return {Function} The shortcut function.
               *
               * @static
               *
               * @example
               *
               *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
               */
              _createHelper: function (hasher) {
                return function (message, cfg) {
                  return new hasher.init(cfg).finalize(message);
                };
              },
              /**
               * Creates a shortcut function to the HMAC's object interface.
               *
               * @param {Hasher} hasher The hasher to use in this HMAC helper.
               *
               * @return {Function} The shortcut function.
               *
               * @static
               *
               * @example
               *
               *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
               */
              _createHmacHelper: function (hasher) {
                return function (message, key) {
                  return new C_algo.HMAC.init(hasher, key).finalize(message);
                };
              }
            });

            /**
             * Algorithm namespace.
             */
            var C_algo = C.algo = {};
            return C;
          }(Math);
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var C_enc = C.enc;

            /**
             * Base64 encoding strategy.
             */
            var Base64 = C_enc.Base64 = {
              /**
               * Converts a word array to a Base64 string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The Base64 string.
               *
               * @static
               *
               * @example
               *
               *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);
               */
              stringify: function (wordArray) {
                // Shortcuts
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;
                var map = this._map;

                // Clamp excess bits
                wordArray.clamp();

                // Convert
                var base64Chars = [];
                for (var i = 0; i < sigBytes; i += 3) {
                  var byte1 = words[i >>> 2] >>> 24 - i % 4 * 8 & 0xff;
                  var byte2 = words[i + 1 >>> 2] >>> 24 - (i + 1) % 4 * 8 & 0xff;
                  var byte3 = words[i + 2 >>> 2] >>> 24 - (i + 2) % 4 * 8 & 0xff;
                  var triplet = byte1 << 16 | byte2 << 8 | byte3;
                  for (var j = 0; j < 4 && i + j * 0.75 < sigBytes; j++) {
                    base64Chars.push(map.charAt(triplet >>> 6 * (3 - j) & 0x3f));
                  }
                }

                // Add padding
                var paddingChar = map.charAt(64);
                if (paddingChar) {
                  while (base64Chars.length % 4) {
                    base64Chars.push(paddingChar);
                  }
                }
                return base64Chars.join('');
              },
              /**
               * Converts a Base64 string to a word array.
               *
               * @param {string} base64Str The Base64 string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Base64.parse(base64String);
               */
              parse: function (base64Str) {
                // Shortcuts
                var base64StrLength = base64Str.length;
                var map = this._map;
                var reverseMap = this._reverseMap;
                if (!reverseMap) {
                  reverseMap = this._reverseMap = [];
                  for (var j = 0; j < map.length; j++) {
                    reverseMap[map.charCodeAt(j)] = j;
                  }
                }

                // Ignore padding
                var paddingChar = map.charAt(64);
                if (paddingChar) {
                  var paddingIndex = base64Str.indexOf(paddingChar);
                  if (paddingIndex !== -1) {
                    base64StrLength = paddingIndex;
                  }
                }

                // Convert
                return parseLoop(base64Str, base64StrLength, reverseMap);
              },
              _map: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
            };
            function parseLoop(base64Str, base64StrLength, reverseMap) {
              var words = [];
              var nBytes = 0;
              for (var i = 0; i < base64StrLength; i++) {
                if (i % 4) {
                  var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << i % 4 * 2;
                  var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> 6 - i % 4 * 2;
                  words[nBytes >>> 2] |= (bits1 | bits2) << 24 - nBytes % 4 * 8;
                  nBytes++;
                }
              }
              return WordArray.create(words, nBytes);
            }
          })();
          (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;

            // Constants table
            var T = [];

            // Compute constants
            (function () {
              for (var i = 0; i < 64; i++) {
                T[i] = Math.abs(Math.sin(i + 1)) * 0x100000000 | 0;
              }
            })();

            /**
             * MD5 hash algorithm.
             */
            var MD5 = C_algo.MD5 = Hasher.extend({
              _doReset: function () {
                this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]);
              },
              _doProcessBlock: function (M, offset) {
                // Swap endian
                for (var i = 0; i < 16; i++) {
                  // Shortcuts
                  var offset_i = offset + i;
                  var M_offset_i = M[offset_i];
                  M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;
                }

                // Shortcuts
                var H = this._hash.words;
                var M_offset_0 = M[offset + 0];
                var M_offset_1 = M[offset + 1];
                var M_offset_2 = M[offset + 2];
                var M_offset_3 = M[offset + 3];
                var M_offset_4 = M[offset + 4];
                var M_offset_5 = M[offset + 5];
                var M_offset_6 = M[offset + 6];
                var M_offset_7 = M[offset + 7];
                var M_offset_8 = M[offset + 8];
                var M_offset_9 = M[offset + 9];
                var M_offset_10 = M[offset + 10];
                var M_offset_11 = M[offset + 11];
                var M_offset_12 = M[offset + 12];
                var M_offset_13 = M[offset + 13];
                var M_offset_14 = M[offset + 14];
                var M_offset_15 = M[offset + 15];

                // Working varialbes
                var a = H[0];
                var b = H[1];
                var c = H[2];
                var d = H[3];

                // Computation
                a = FF(a, b, c, d, M_offset_0, 7, T[0]);
                d = FF(d, a, b, c, M_offset_1, 12, T[1]);
                c = FF(c, d, a, b, M_offset_2, 17, T[2]);
                b = FF(b, c, d, a, M_offset_3, 22, T[3]);
                a = FF(a, b, c, d, M_offset_4, 7, T[4]);
                d = FF(d, a, b, c, M_offset_5, 12, T[5]);
                c = FF(c, d, a, b, M_offset_6, 17, T[6]);
                b = FF(b, c, d, a, M_offset_7, 22, T[7]);
                a = FF(a, b, c, d, M_offset_8, 7, T[8]);
                d = FF(d, a, b, c, M_offset_9, 12, T[9]);
                c = FF(c, d, a, b, M_offset_10, 17, T[10]);
                b = FF(b, c, d, a, M_offset_11, 22, T[11]);
                a = FF(a, b, c, d, M_offset_12, 7, T[12]);
                d = FF(d, a, b, c, M_offset_13, 12, T[13]);
                c = FF(c, d, a, b, M_offset_14, 17, T[14]);
                b = FF(b, c, d, a, M_offset_15, 22, T[15]);
                a = GG(a, b, c, d, M_offset_1, 5, T[16]);
                d = GG(d, a, b, c, M_offset_6, 9, T[17]);
                c = GG(c, d, a, b, M_offset_11, 14, T[18]);
                b = GG(b, c, d, a, M_offset_0, 20, T[19]);
                a = GG(a, b, c, d, M_offset_5, 5, T[20]);
                d = GG(d, a, b, c, M_offset_10, 9, T[21]);
                c = GG(c, d, a, b, M_offset_15, 14, T[22]);
                b = GG(b, c, d, a, M_offset_4, 20, T[23]);
                a = GG(a, b, c, d, M_offset_9, 5, T[24]);
                d = GG(d, a, b, c, M_offset_14, 9, T[25]);
                c = GG(c, d, a, b, M_offset_3, 14, T[26]);
                b = GG(b, c, d, a, M_offset_8, 20, T[27]);
                a = GG(a, b, c, d, M_offset_13, 5, T[28]);
                d = GG(d, a, b, c, M_offset_2, 9, T[29]);
                c = GG(c, d, a, b, M_offset_7, 14, T[30]);
                b = GG(b, c, d, a, M_offset_12, 20, T[31]);
                a = HH(a, b, c, d, M_offset_5, 4, T[32]);
                d = HH(d, a, b, c, M_offset_8, 11, T[33]);
                c = HH(c, d, a, b, M_offset_11, 16, T[34]);
                b = HH(b, c, d, a, M_offset_14, 23, T[35]);
                a = HH(a, b, c, d, M_offset_1, 4, T[36]);
                d = HH(d, a, b, c, M_offset_4, 11, T[37]);
                c = HH(c, d, a, b, M_offset_7, 16, T[38]);
                b = HH(b, c, d, a, M_offset_10, 23, T[39]);
                a = HH(a, b, c, d, M_offset_13, 4, T[40]);
                d = HH(d, a, b, c, M_offset_0, 11, T[41]);
                c = HH(c, d, a, b, M_offset_3, 16, T[42]);
                b = HH(b, c, d, a, M_offset_6, 23, T[43]);
                a = HH(a, b, c, d, M_offset_9, 4, T[44]);
                d = HH(d, a, b, c, M_offset_12, 11, T[45]);
                c = HH(c, d, a, b, M_offset_15, 16, T[46]);
                b = HH(b, c, d, a, M_offset_2, 23, T[47]);
                a = II(a, b, c, d, M_offset_0, 6, T[48]);
                d = II(d, a, b, c, M_offset_7, 10, T[49]);
                c = II(c, d, a, b, M_offset_14, 15, T[50]);
                b = II(b, c, d, a, M_offset_5, 21, T[51]);
                a = II(a, b, c, d, M_offset_12, 6, T[52]);
                d = II(d, a, b, c, M_offset_3, 10, T[53]);
                c = II(c, d, a, b, M_offset_10, 15, T[54]);
                b = II(b, c, d, a, M_offset_1, 21, T[55]);
                a = II(a, b, c, d, M_offset_8, 6, T[56]);
                d = II(d, a, b, c, M_offset_15, 10, T[57]);
                c = II(c, d, a, b, M_offset_6, 15, T[58]);
                b = II(b, c, d, a, M_offset_13, 21, T[59]);
                a = II(a, b, c, d, M_offset_4, 6, T[60]);
                d = II(d, a, b, c, M_offset_11, 10, T[61]);
                c = II(c, d, a, b, M_offset_2, 15, T[62]);
                b = II(b, c, d, a, M_offset_9, 21, T[63]);

                // Intermediate hash value
                H[0] = H[0] + a | 0;
                H[1] = H[1] + b | 0;
                H[2] = H[2] + c | 0;
                H[3] = H[3] + d | 0;
              },
              _doFinalize: function () {
                // Shortcuts
                var data = this._data;
                var dataWords = data.words;
                var nBitsTotal = this._nDataBytes * 8;
                var nBitsLeft = data.sigBytes * 8;

                // Add padding
                dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
                var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
                var nBitsTotalL = nBitsTotal;
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = (nBitsTotalH << 8 | nBitsTotalH >>> 24) & 0x00ff00ff | (nBitsTotalH << 24 | nBitsTotalH >>> 8) & 0xff00ff00;
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotalL << 8 | nBitsTotalL >>> 24) & 0x00ff00ff | (nBitsTotalL << 24 | nBitsTotalL >>> 8) & 0xff00ff00;
                data.sigBytes = (dataWords.length + 1) * 4;

                // Hash final blocks
                this._process();

                // Shortcuts
                var hash = this._hash;
                var H = hash.words;

                // Swap endian
                for (var i = 0; i < 4; i++) {
                  // Shortcut
                  var H_i = H[i];
                  H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;
                }

                // Return final computed hash
                return hash;
              },
              clone: function () {
                var clone = Hasher.clone.call(this);
                clone._hash = this._hash.clone();
                return clone;
              }
            });
            function FF(a, b, c, d, x, s, t) {
              var n = a + (b & c | ~b & d) + x + t;
              return (n << s | n >>> 32 - s) + b;
            }
            function GG(a, b, c, d, x, s, t) {
              var n = a + (b & d | c & ~d) + x + t;
              return (n << s | n >>> 32 - s) + b;
            }
            function HH(a, b, c, d, x, s, t) {
              var n = a + (b ^ c ^ d) + x + t;
              return (n << s | n >>> 32 - s) + b;
            }
            function II(a, b, c, d, x, s, t) {
              var n = a + (c ^ (b | ~d)) + x + t;
              return (n << s | n >>> 32 - s) + b;
            }

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.MD5('message');
             *     var hash = CryptoJS.MD5(wordArray);
             */
            C.MD5 = Hasher._createHelper(MD5);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacMD5(message, key);
             */
            C.HmacMD5 = Hasher._createHmacHelper(MD5);
          })(Math);
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;

            // Reusable object
            var W = [];

            /**
             * SHA-1 hash algorithm.
             */
            var SHA1 = C_algo.SHA1 = Hasher.extend({
              _doReset: function () {
                this._hash = new WordArray.init([0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0]);
              },
              _doProcessBlock: function (M, offset) {
                // Shortcut
                var H = this._hash.words;

                // Working variables
                var a = H[0];
                var b = H[1];
                var c = H[2];
                var d = H[3];
                var e = H[4];

                // Computation
                for (var i = 0; i < 80; i++) {
                  if (i < 16) {
                    W[i] = M[offset + i] | 0;
                  } else {
                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];
                    W[i] = n << 1 | n >>> 31;
                  }
                  var t = (a << 5 | a >>> 27) + e + W[i];
                  if (i < 20) {
                    t += (b & c | ~b & d) + 0x5a827999;
                  } else if (i < 40) {
                    t += (b ^ c ^ d) + 0x6ed9eba1;
                  } else if (i < 60) {
                    t += (b & c | b & d | c & d) - 0x70e44324;
                  } else /* if (i < 80) */{
                      t += (b ^ c ^ d) - 0x359d3e2a;
                    }
                  e = d;
                  d = c;
                  c = b << 30 | b >>> 2;
                  b = a;
                  a = t;
                }

                // Intermediate hash value
                H[0] = H[0] + a | 0;
                H[1] = H[1] + b | 0;
                H[2] = H[2] + c | 0;
                H[3] = H[3] + d | 0;
                H[4] = H[4] + e | 0;
              },
              _doFinalize: function () {
                // Shortcuts
                var data = this._data;
                var dataWords = data.words;
                var nBitsTotal = this._nDataBytes * 8;
                var nBitsLeft = data.sigBytes * 8;

                // Add padding
                dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                data.sigBytes = dataWords.length * 4;

                // Hash final blocks
                this._process();

                // Return final computed hash
                return this._hash;
              },
              clone: function () {
                var clone = Hasher.clone.call(this);
                clone._hash = this._hash.clone();
                return clone;
              }
            });

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA1('message');
             *     var hash = CryptoJS.SHA1(wordArray);
             */
            C.SHA1 = Hasher._createHelper(SHA1);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA1(message, key);
             */
            C.HmacSHA1 = Hasher._createHmacHelper(SHA1);
          })();
          (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;

            // Initialization and round constants tables
            var H = [];
            var K = [];

            // Compute constants
            (function () {
              function isPrime(n) {
                var sqrtN = Math.sqrt(n);
                for (var factor = 2; factor <= sqrtN; factor++) {
                  if (!(n % factor)) {
                    return false;
                  }
                }
                return true;
              }
              function getFractionalBits(n) {
                return (n - (n | 0)) * 0x100000000 | 0;
              }
              var n = 2;
              var nPrime = 0;
              while (nPrime < 64) {
                if (isPrime(n)) {
                  if (nPrime < 8) {
                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));
                  }
                  K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));
                  nPrime++;
                }
                n++;
              }
            })();

            // Reusable object
            var W = [];

            /**
             * SHA-256 hash algorithm.
             */
            var SHA256 = C_algo.SHA256 = Hasher.extend({
              _doReset: function () {
                this._hash = new WordArray.init(H.slice(0));
              },
              _doProcessBlock: function (M, offset) {
                // Shortcut
                var H = this._hash.words;

                // Working variables
                var a = H[0];
                var b = H[1];
                var c = H[2];
                var d = H[3];
                var e = H[4];
                var f = H[5];
                var g = H[6];
                var h = H[7];

                // Computation
                for (var i = 0; i < 64; i++) {
                  if (i < 16) {
                    W[i] = M[offset + i] | 0;
                  } else {
                    var gamma0x = W[i - 15];
                    var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                    var gamma1x = W[i - 2];
                    var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
                  }
                  var ch = e & f ^ ~e & g;
                  var maj = a & b ^ a & c ^ b & c;
                  var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
                  var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
                  var t1 = h + sigma1 + ch + K[i] + W[i];
                  var t2 = sigma0 + maj;
                  h = g;
                  g = f;
                  f = e;
                  e = d + t1 | 0;
                  d = c;
                  c = b;
                  b = a;
                  a = t1 + t2 | 0;
                }

                // Intermediate hash value
                H[0] = H[0] + a | 0;
                H[1] = H[1] + b | 0;
                H[2] = H[2] + c | 0;
                H[3] = H[3] + d | 0;
                H[4] = H[4] + e | 0;
                H[5] = H[5] + f | 0;
                H[6] = H[6] + g | 0;
                H[7] = H[7] + h | 0;
              },
              _doFinalize: function () {
                // Shortcuts
                var data = this._data;
                var dataWords = data.words;
                var nBitsTotal = this._nDataBytes * 8;
                var nBitsLeft = data.sigBytes * 8;

                // Add padding
                dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
                data.sigBytes = dataWords.length * 4;

                // Hash final blocks
                this._process();

                // Return final computed hash
                return this._hash;
              },
              clone: function () {
                var clone = Hasher.clone.call(this);
                clone._hash = this._hash.clone();
                return clone;
              }
            });

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA256('message');
             *     var hash = CryptoJS.SHA256(wordArray);
             */
            C.SHA256 = Hasher._createHelper(SHA256);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA256(message, key);
             */
            C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
          })(Math);
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var C_enc = C.enc;

            /**
             * UTF-16 BE encoding strategy.
             */
            var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {
              /**
               * Converts a word array to a UTF-16 BE string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The UTF-16 BE string.
               *
               * @static
               *
               * @example
               *
               *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);
               */
              stringify: function (wordArray) {
                // Shortcuts
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;

                // Convert
                var utf16Chars = [];
                for (var i = 0; i < sigBytes; i += 2) {
                  var codePoint = words[i >>> 2] >>> 16 - i % 4 * 8 & 0xffff;
                  utf16Chars.push(String.fromCharCode(codePoint));
                }
                return utf16Chars.join('');
              },
              /**
               * Converts a UTF-16 BE string to a word array.
               *
               * @param {string} utf16Str The UTF-16 BE string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);
               */
              parse: function (utf16Str) {
                // Shortcut
                var utf16StrLength = utf16Str.length;

                // Convert
                var words = [];
                for (var i = 0; i < utf16StrLength; i++) {
                  words[i >>> 1] |= utf16Str.charCodeAt(i) << 16 - i % 2 * 16;
                }
                return WordArray.create(words, utf16StrLength * 2);
              }
            };

            /**
             * UTF-16 LE encoding strategy.
             */
            C_enc.Utf16LE = {
              /**
               * Converts a word array to a UTF-16 LE string.
               *
               * @param {WordArray} wordArray The word array.
               *
               * @return {string} The UTF-16 LE string.
               *
               * @static
               *
               * @example
               *
               *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);
               */
              stringify: function (wordArray) {
                // Shortcuts
                var words = wordArray.words;
                var sigBytes = wordArray.sigBytes;

                // Convert
                var utf16Chars = [];
                for (var i = 0; i < sigBytes; i += 2) {
                  var codePoint = swapEndian(words[i >>> 2] >>> 16 - i % 4 * 8 & 0xffff);
                  utf16Chars.push(String.fromCharCode(codePoint));
                }
                return utf16Chars.join('');
              },
              /**
               * Converts a UTF-16 LE string to a word array.
               *
               * @param {string} utf16Str The UTF-16 LE string.
               *
               * @return {WordArray} The word array.
               *
               * @static
               *
               * @example
               *
               *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);
               */
              parse: function (utf16Str) {
                // Shortcut
                var utf16StrLength = utf16Str.length;

                // Convert
                var words = [];
                for (var i = 0; i < utf16StrLength; i++) {
                  words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << 16 - i % 2 * 16);
                }
                return WordArray.create(words, utf16StrLength * 2);
              }
            };
            function swapEndian(word) {
              return word << 8 & 0xff00ff00 | word >>> 8 & 0x00ff00ff;
            }
          })();
          (function () {
            // Check if typed arrays are supported
            if (typeof ArrayBuffer != 'function') {
              return;
            }

            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;

            // Reference original init
            var superInit = WordArray.init;

            // Augment WordArray.init to handle typed arrays
            var subInit = WordArray.WTPEMNO = function (typedArray) {
              // Convert buffers to uint8
              if (typedArray instanceof ArrayBuffer) {
                typedArray = new Uint8Array(typedArray);
              }

              // Convert other array views to uint8
              if (typedArray instanceof Int8Array || typeof Uint8ClampedArray !== "undefined" && typedArray instanceof Uint8ClampedArray || typedArray instanceof Int16Array || typedArray instanceof Uint16Array || typedArray instanceof Int32Array || typedArray instanceof Uint32Array || typedArray instanceof Float32Array || typedArray instanceof Float64Array) {
                typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);
              }

              // Handle Uint8Array
              if (typedArray instanceof Uint8Array) {
                // Shortcut
                var typedArrayByteLength = typedArray.byteLength;

                // Extract bytes
                var words = [];
                for (var i = 0; i < typedArrayByteLength; i++) {
                  words[i >>> 2] |= typedArray[i] << 24 - i % 4 * 8;
                }

                // Initialize this word array
                superInit.call(this, words, typedArrayByteLength);
              } else {
                // Else call normal init
                superInit.apply(this, arguments);
              }
            };
            subInit.prototype = WordArray;
          })();

          /** @preserve
          (c) 2012 by Cédric Mesnil. All rights reserved.
          	Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
          	    - Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
              - Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
          	THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
          */

          (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_algo = C.algo;

            // Constants table
            var _zl = WordArray.create([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8, 3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12, 1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2, 4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13]);
            var _zr = WordArray.create([5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12, 6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2, 15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13, 8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14, 12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11]);
            var _sl = WordArray.create([11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8, 7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12, 11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5, 11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12, 9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6]);
            var _sr = WordArray.create([8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6, 9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11, 9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5, 15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8, 8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11]);
            var _hl = WordArray.create([0x00000000, 0x5A827999, 0x6ED9EBA1, 0x8F1BBCDC, 0xA953FD4E]);
            var _hr = WordArray.create([0x50A28BE6, 0x5C4DD124, 0x6D703EF3, 0x7A6D76E9, 0x00000000]);

            /**
             * RIPEMD160 hash algorithm.
             */
            var RIPEMD160 = C_algo.RIPEMD160 = Hasher.extend({
              _doReset: function () {
                this._hash = WordArray.create([0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0]);
              },
              _doProcessBlock: function (M, offset) {
                // Swap endian
                for (var i = 0; i < 16; i++) {
                  // Shortcuts
                  var offset_i = offset + i;
                  var M_offset_i = M[offset_i];

                  // Swap
                  M[offset_i] = (M_offset_i << 8 | M_offset_i >>> 24) & 0x00ff00ff | (M_offset_i << 24 | M_offset_i >>> 8) & 0xff00ff00;
                }
                // Shortcut
                var H = this._hash.words;
                var hl = _hl.words;
                var hr = _hr.words;
                var zl = _zl.words;
                var zr = _zr.words;
                var sl = _sl.words;
                var sr = _sr.words;

                // Working variables
                var al, bl, cl, dl, el;
                var ar, br, cr, dr, er;
                ar = al = H[0];
                br = bl = H[1];
                cr = cl = H[2];
                dr = dl = H[3];
                er = el = H[4];
                // Computation
                var t;
                for (var i = 0; i < 80; i += 1) {
                  t = al + M[offset + zl[i]] | 0;
                  if (i < 16) {
                    t += f1(bl, cl, dl) + hl[0];
                  } else if (i < 32) {
                    t += f2(bl, cl, dl) + hl[1];
                  } else if (i < 48) {
                    t += f3(bl, cl, dl) + hl[2];
                  } else if (i < 64) {
                    t += f4(bl, cl, dl) + hl[3];
                  } else {
                    // if (i<80) {
                    t += f5(bl, cl, dl) + hl[4];
                  }
                  t = t | 0;
                  t = rotl(t, sl[i]);
                  t = t + el | 0;
                  al = el;
                  el = dl;
                  dl = rotl(cl, 10);
                  cl = bl;
                  bl = t;
                  t = ar + M[offset + zr[i]] | 0;
                  if (i < 16) {
                    t += f5(br, cr, dr) + hr[0];
                  } else if (i < 32) {
                    t += f4(br, cr, dr) + hr[1];
                  } else if (i < 48) {
                    t += f3(br, cr, dr) + hr[2];
                  } else if (i < 64) {
                    t += f2(br, cr, dr) + hr[3];
                  } else {
                    // if (i<80) {
                    t += f1(br, cr, dr) + hr[4];
                  }
                  t = t | 0;
                  t = rotl(t, sr[i]);
                  t = t + er | 0;
                  ar = er;
                  er = dr;
                  dr = rotl(cr, 10);
                  cr = br;
                  br = t;
                }
                // Intermediate hash value
                t = H[1] + cl + dr | 0;
                H[1] = H[2] + dl + er | 0;
                H[2] = H[3] + el + ar | 0;
                H[3] = H[4] + al + br | 0;
                H[4] = H[0] + bl + cr | 0;
                H[0] = t;
              },
              _doFinalize: function () {
                // Shortcuts
                var data = this._data;
                var dataWords = data.words;
                var nBitsTotal = this._nDataBytes * 8;
                var nBitsLeft = data.sigBytes * 8;

                // Add padding
                dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
                dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = (nBitsTotal << 8 | nBitsTotal >>> 24) & 0x00ff00ff | (nBitsTotal << 24 | nBitsTotal >>> 8) & 0xff00ff00;
                data.sigBytes = (dataWords.length + 1) * 4;

                // Hash final blocks
                this._process();

                // Shortcuts
                var hash = this._hash;
                var H = hash.words;

                // Swap endian
                for (var i = 0; i < 5; i++) {
                  // Shortcut
                  var H_i = H[i];

                  // Swap
                  H[i] = (H_i << 8 | H_i >>> 24) & 0x00ff00ff | (H_i << 24 | H_i >>> 8) & 0xff00ff00;
                }

                // Return final computed hash
                return hash;
              },
              clone: function () {
                var clone = Hasher.clone.call(this);
                clone._hash = this._hash.clone();
                return clone;
              }
            });
            function f1(x, y, z) {
              return x ^ y ^ z;
            }
            function f2(x, y, z) {
              return x & y | ~x & z;
            }
            function f3(x, y, z) {
              return (x | ~y) ^ z;
            }
            function f4(x, y, z) {
              return x & z | y & ~z;
            }
            function f5(x, y, z) {
              return x ^ (y | ~z);
            }
            function rotl(x, n) {
              return x << n | x >>> 32 - n;
            }

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.RIPEMD160('message');
             *     var hash = CryptoJS.RIPEMD160(wordArray);
             */
            C.RIPEMD160 = Hasher._createHelper(RIPEMD160);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacRIPEMD160(message, key);
             */
            C.HmacRIPEMD160 = Hasher._createHmacHelper(RIPEMD160);
          })();
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var C_enc = C.enc;
            var Utf8 = C_enc.Utf8;
            var C_algo = C.algo;

            /**
             * HMAC algorithm.
             */
            var HMAC = C_algo.HMAC = Base.extend({
              /**
               * Initializes a newly created HMAC.
               *
               * @param {Hasher} hasher The hash algorithm to use.
               * @param {WordArray|string} key The secret key.
               *
               * @example
               *
               *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);
               */
              init: function (hasher, key) {
                // Init hasher
                hasher = this._hasher = new hasher.init();

                // Convert string to WordArray, else assume WordArray already
                if (typeof key == 'string') {
                  key = Utf8.parse(key);
                }

                // Shortcuts
                var hasherBlockSize = hasher.blockSize;
                var hasherBlockSizeBytes = hasherBlockSize * 4;

                // Allow arbitrary length keys
                if (key.sigBytes > hasherBlockSizeBytes) {
                  key = hasher.finalize(key);
                }

                // Clamp excess bits
                key.clamp();

                // Clone key for inner and outer pads
                var oKey = this._oKey = key.clone();
                var iKey = this._iKey = key.clone();

                // Shortcuts
                var oKeyWords = oKey.words;
                var iKeyWords = iKey.words;

                // XOR keys with pad constants
                for (var i = 0; i < hasherBlockSize; i++) {
                  oKeyWords[i] ^= 0x5c5c5c5c;
                  iKeyWords[i] ^= 0x36363636;
                }
                oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;

                // Set initial values
                this.reset();
              },
              /**
               * Resets this HMAC to its initial state.
               *
               * @example
               *
               *     hmacHasher.reset();
               */
              reset: function () {
                // Shortcut
                var hasher = this._hasher;

                // Reset
                hasher.reset();
                hasher.update(this._iKey);
              },
              /**
               * Updates this HMAC with a message.
               *
               * @param {WordArray|string} messageUpdate The message to append.
               *
               * @return {HMAC} This HMAC instance.
               *
               * @example
               *
               *     hmacHasher.update('message');
               *     hmacHasher.update(wordArray);
               */
              update: function (messageUpdate) {
                this._hasher.update(messageUpdate);

                // Chainable
                return this;
              },
              /**
               * Finalizes the HMAC computation.
               * Note that the finalize operation is effectively a destructive, read-once operation.
               *
               * @param {WordArray|string} messageUpdate (Optional) A final message update.
               *
               * @return {WordArray} The HMAC.
               *
               * @example
               *
               *     var hmac = hmacHasher.finalize();
               *     var hmac = hmacHasher.finalize('message');
               *     var hmac = hmacHasher.finalize(wordArray);
               */
              finalize: function (messageUpdate) {
                // Shortcut
                var hasher = this._hasher;

                // Compute HMAC
                var innerHash = hasher.finalize(messageUpdate);
                hasher.reset();
                var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));
                return hmac;
              }
            });
          })();
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var C_algo = C.algo;
            var SHA1 = C_algo.SHA1;
            var HMAC = C_algo.HMAC;

            /**
             * Password-Based Key Derivation Function 2 algorithm.
             */
            var PBKDF2 = C_algo.PBKDF2 = Base.extend({
              /**
               * Configuration options.
               *
               * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
               * @property {Hasher} hasher The hasher to use. Default: SHA1
               * @property {number} iterations The number of iterations to perform. Default: 1
               */
              cfg: Base.extend({
                keySize: 128 / 32,
                hasher: SHA1,
                iterations: 1
              }),
              /**
               * Initializes a newly created key derivation function.
               *
               * @param {Object} cfg (Optional) The configuration options to use for the derivation.
               *
               * @example
               *
               *     var kdf = CryptoJS.algo.PBKDF2.create();
               *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8 });
               *     var kdf = CryptoJS.algo.PBKDF2.create({ keySize: 8, iterations: 1000 });
               */
              init: function (cfg) {
                this.cfg = this.cfg.extend(cfg);
              },
              /**
               * Computes the Password-Based Key Derivation Function 2.
               *
               * @param {WordArray|string} password The password.
               * @param {WordArray|string} salt A salt.
               *
               * @return {WordArray} The derived key.
               *
               * @example
               *
               *     var key = kdf.compute(password, salt);
               */
              compute: function (password, salt) {
                // Shortcut
                var cfg = this.cfg;

                // Init HMAC
                var hmac = HMAC.create(cfg.hasher, password);

                // Initial values
                var derivedKey = WordArray.create();
                var blockIndex = WordArray.create([0x00000001]);

                // Shortcuts
                var derivedKeyWords = derivedKey.words;
                var blockIndexWords = blockIndex.words;
                var keySize = cfg.keySize;
                var iterations = cfg.iterations;

                // Generate key
                while (derivedKeyWords.length < keySize) {
                  var block = hmac.update(salt).finalize(blockIndex);
                  hmac.reset();

                  // Shortcuts
                  var blockWords = block.words;
                  var blockWordsLength = blockWords.length;

                  // Iterations
                  var intermediate = block;
                  for (var i = 1; i < iterations; i++) {
                    intermediate = hmac.finalize(intermediate);
                    hmac.reset();

                    // Shortcut
                    var intermediateWords = intermediate.words;

                    // XOR intermediate with block
                    for (var j = 0; j < blockWordsLength; j++) {
                      blockWords[j] ^= intermediateWords[j];
                    }
                  }
                  derivedKey.concat(block);
                  blockIndexWords[0]++;
                }
                derivedKey.sigBytes = keySize * 4;
                return derivedKey;
              }
            });

            /**
             * Computes the Password-Based Key Derivation Function 2.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             * @param {Object} cfg (Optional) The configuration options to use for this computation.
             *
             * @return {WordArray} The derived key.
             *
             * @static
             *
             * @example
             *
             *     var key = CryptoJS.PBKDF2(password, salt);
             *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8 });
             *     var key = CryptoJS.PBKDF2(password, salt, { keySize: 8, iterations: 1000 });
             */
            C.PBKDF2 = function (password, salt, cfg) {
              return PBKDF2.create(cfg).compute(password, salt);
            };
          })();
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var C_algo = C.algo;
            var MD5 = C_algo.MD5;

            /**
             * This key derivation function is meant to conform with EVP_BytesToKey.
             * www.openssl.org/docs/crypto/EVP_BytesToKey.html
             */
            var EvpKDF = C_algo.EvpKDF = Base.extend({
              /**
               * Configuration options.
               *
               * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)
               * @property {Hasher} hasher The hash algorithm to use. Default: MD5
               * @property {number} iterations The number of iterations to perform. Default: 1
               */
              cfg: Base.extend({
                keySize: 128 / 32,
                hasher: MD5,
                iterations: 1
              }),
              /**
               * Initializes a newly created key derivation function.
               *
               * @param {Object} cfg (Optional) The configuration options to use for the derivation.
               *
               * @example
               *
               *     var kdf = CryptoJS.algo.EvpKDF.create();
               *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });
               *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });
               */
              init: function (cfg) {
                this.cfg = this.cfg.extend(cfg);
              },
              /**
               * Derives a key from a password.
               *
               * @param {WordArray|string} password The password.
               * @param {WordArray|string} salt A salt.
               *
               * @return {WordArray} The derived key.
               *
               * @example
               *
               *     var key = kdf.compute(password, salt);
               */
              compute: function (password, salt) {
                // Shortcut
                var cfg = this.cfg;

                // Init hasher
                var hasher = cfg.hasher.create();

                // Initial values
                var derivedKey = WordArray.create();

                // Shortcuts
                var derivedKeyWords = derivedKey.words;
                var keySize = cfg.keySize;
                var iterations = cfg.iterations;

                // Generate key
                while (derivedKeyWords.length < keySize) {
                  if (block) {
                    hasher.update(block);
                  }
                  var block = hasher.update(password).finalize(salt);
                  hasher.reset();

                  // Iterations
                  for (var i = 1; i < iterations; i++) {
                    block = hasher.finalize(block);
                    hasher.reset();
                  }
                  derivedKey.concat(block);
                }
                derivedKey.sigBytes = keySize * 4;
                return derivedKey;
              }
            });

            /**
             * Derives a key from a password.
             *
             * @param {WordArray|string} password The password.
             * @param {WordArray|string} salt A salt.
             * @param {Object} cfg (Optional) The configuration options to use for this computation.
             *
             * @return {WordArray} The derived key.
             *
             * @static
             *
             * @example
             *
             *     var key = CryptoJS.EvpKDF(password, salt);
             *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });
             *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });
             */
            C.EvpKDF = function (password, salt, cfg) {
              return EvpKDF.create(cfg).compute(password, salt);
            };
          })();
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var C_algo = C.algo;
            var SHA256 = C_algo.SHA256;

            /**
             * SHA-224 hash algorithm.
             */
            var SHA224 = C_algo.SHA224 = SHA256.extend({
              _doReset: function () {
                this._hash = new WordArray.init([0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939, 0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4]);
              },
              _doFinalize: function () {
                var hash = SHA256._doFinalize.call(this);
                hash.sigBytes -= 4;
                return hash;
              }
            });

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA224('message');
             *     var hash = CryptoJS.SHA224(wordArray);
             */
            C.SHA224 = SHA256._createHelper(SHA224);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA224(message, key);
             */
            C.HmacSHA224 = SHA256._createHmacHelper(SHA224);
          })();
          (function (undefined$1) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var X32WordArray = C_lib.WordArray;

            /**
             * x64 namespace.
             */
            var C_x64 = C.x64 = {};

            /**
             * A 64-bit word.
             */
            var X64Word = C_x64.Word = Base.extend({
              /**
               * Initializes a newly created 64-bit word.
               *
               * @param {number} high The high 32 bits.
               * @param {number} low The low 32 bits.
               *
               * @example
               *
               *     var x64Word = CryptoJS.x64.Word.create(0x00010203, 0x04050607);
               */
              init: function (high, low) {
                this.high = high;
                this.low = low;
              }

              /**
               * Bitwise NOTs this word.
               *
               * @return {X64Word} A new x64-Word object after negating.
               *
               * @example
               *
               *     var negated = x64Word.not();
               */
              // not: function () {
              // var high = ~this.high;
              // var low = ~this.low;

              // return X64Word.create(high, low);
              // },

              /**
               * Bitwise ANDs this word with the passed word.
               *
               * @param {X64Word} word The x64-Word to AND with this word.
               *
               * @return {X64Word} A new x64-Word object after ANDing.
               *
               * @example
               *
               *     var anded = x64Word.and(anotherX64Word);
               */
              // and: function (word) {
              // var high = this.high & word.high;
              // var low = this.low & word.low;

              // return X64Word.create(high, low);
              // },

              /**
               * Bitwise ORs this word with the passed word.
               *
               * @param {X64Word} word The x64-Word to OR with this word.
               *
               * @return {X64Word} A new x64-Word object after ORing.
               *
               * @example
               *
               *     var ored = x64Word.or(anotherX64Word);
               */
              // or: function (word) {
              // var high = this.high | word.high;
              // var low = this.low | word.low;

              // return X64Word.create(high, low);
              // },

              /**
               * Bitwise XORs this word with the passed word.
               *
               * @param {X64Word} word The x64-Word to XOR with this word.
               *
               * @return {X64Word} A new x64-Word object after XORing.
               *
               * @example
               *
               *     var xored = x64Word.xor(anotherX64Word);
               */
              // xor: function (word) {
              // var high = this.high ^ word.high;
              // var low = this.low ^ word.low;

              // return X64Word.create(high, low);
              // },

              /**
               * Shifts this word n bits to the left.
               *
               * @param {number} n The number of bits to shift.
               *
               * @return {X64Word} A new x64-Word object after shifting.
               *
               * @example
               *
               *     var shifted = x64Word.shiftL(25);
               */
              // shiftL: function (n) {
              // if (n < 32) {
              // var high = (this.high << n) | (this.low >>> (32 - n));
              // var low = this.low << n;
              // } else {
              // var high = this.low << (n - 32);
              // var low = 0;
              // }

              // return X64Word.create(high, low);
              // },

              /**
               * Shifts this word n bits to the right.
               *
               * @param {number} n The number of bits to shift.
               *
               * @return {X64Word} A new x64-Word object after shifting.
               *
               * @example
               *
               *     var shifted = x64Word.shiftR(7);
               */
              // shiftR: function (n) {
              // if (n < 32) {
              // var low = (this.low >>> n) | (this.high << (32 - n));
              // var high = this.high >>> n;
              // } else {
              // var low = this.high >>> (n - 32);
              // var high = 0;
              // }

              // return X64Word.create(high, low);
              // },

              /**
               * Rotates this word n bits to the left.
               *
               * @param {number} n The number of bits to rotate.
               *
               * @return {X64Word} A new x64-Word object after rotating.
               *
               * @example
               *
               *     var rotated = x64Word.rotL(25);
               */
              // rotL: function (n) {
              // return this.shiftL(n).or(this.shiftR(64 - n));
              // },

              /**
               * Rotates this word n bits to the right.
               *
               * @param {number} n The number of bits to rotate.
               *
               * @return {X64Word} A new x64-Word object after rotating.
               *
               * @example
               *
               *     var rotated = x64Word.rotR(7);
               */
              // rotR: function (n) {
              // return this.shiftR(n).or(this.shiftL(64 - n));
              // },

              /**
               * Adds this word with the passed word.
               *
               * @param {X64Word} word The x64-Word to add with this word.
               *
               * @return {X64Word} A new x64-Word object after adding.
               *
               * @example
               *
               *     var added = x64Word.add(anotherX64Word);
               */
              // add: function (word) {
              // var low = (this.low + word.low) | 0;
              // var carry = (low >>> 0) < (this.low >>> 0) ? 1 : 0;
              // var high = (this.high + word.high + carry) | 0;

              // return X64Word.create(high, low);
              // }
            });

            /**
             * An array of 64-bit words.
             *
             * @property {Array} words The array of CryptoJS.x64.Word objects.
             * @property {number} sigBytes The number of significant bytes in this word array.
             */
            var X64WordArray = C_x64.WordArray = Base.extend({
              /**
               * Initializes a newly created word array.
               *
               * @param {Array} words (Optional) An array of CryptoJS.x64.Word objects.
               * @param {number} sigBytes (Optional) The number of significant bytes in the words.
               *
               * @example
               *
               *     var wordArray = CryptoJS.x64.WordArray.create();
               *
               *     var wordArray = CryptoJS.x64.WordArray.create([
               *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
               *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
               *     ]);
               *
               *     var wordArray = CryptoJS.x64.WordArray.create([
               *         CryptoJS.x64.Word.create(0x00010203, 0x04050607),
               *         CryptoJS.x64.Word.create(0x18191a1b, 0x1c1d1e1f)
               *     ], 10);
               */
              init: function (words, sigBytes) {
                words = this.words = words || [];
                if (sigBytes != undefined$1) {
                  this.sigBytes = sigBytes;
                } else {
                  this.sigBytes = words.length * 8;
                }
              },
              /**
               * Converts this 64-bit word array to a 32-bit word array.
               *
               * @return {CryptoJS.lib.WordArray} This word array's data as a 32-bit word array.
               *
               * @example
               *
               *     var x32WordArray = x64WordArray.toX32();
               */
              toX32: function () {
                // Shortcuts
                var x64Words = this.words;
                var x64WordsLength = x64Words.length;

                // Convert
                var x32Words = [];
                for (var i = 0; i < x64WordsLength; i++) {
                  var x64Word = x64Words[i];
                  x32Words.push(x64Word.high);
                  x32Words.push(x64Word.low);
                }
                return X32WordArray.create(x32Words, this.sigBytes);
              },
              /**
               * Creates a copy of this word array.
               *
               * @return {X64WordArray} The clone.
               *
               * @example
               *
               *     var clone = x64WordArray.clone();
               */
              clone: function () {
                var clone = Base.clone.call(this);

                // Clone "words" array
                var words = clone.words = this.words.slice(0);

                // Clone each X64Word object
                var wordsLength = words.length;
                for (var i = 0; i < wordsLength; i++) {
                  words[i] = words[i].clone();
                }
                return clone;
              }
            });
          })();
          (function (Math) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var Hasher = C_lib.Hasher;
            var C_x64 = C.x64;
            var X64Word = C_x64.Word;
            var C_algo = C.algo;

            // Constants tables
            var RHO_OFFSETS = [];
            var PI_INDEXES = [];
            var ROUND_CONSTANTS = [];

            // Compute Constants
            (function () {
              // Compute rho offset constants
              var x = 1,
                y = 0;
              for (var t = 0; t < 24; t++) {
                RHO_OFFSETS[x + 5 * y] = (t + 1) * (t + 2) / 2 % 64;
                var newX = y % 5;
                var newY = (2 * x + 3 * y) % 5;
                x = newX;
                y = newY;
              }

              // Compute pi index constants
              for (var x = 0; x < 5; x++) {
                for (var y = 0; y < 5; y++) {
                  PI_INDEXES[x + 5 * y] = y + (2 * x + 3 * y) % 5 * 5;
                }
              }

              // Compute round constants
              var LFSR = 0x01;
              for (var i = 0; i < 24; i++) {
                var roundConstantMsw = 0;
                var roundConstantLsw = 0;
                for (var j = 0; j < 7; j++) {
                  if (LFSR & 0x01) {
                    var bitPosition = (1 << j) - 1;
                    if (bitPosition < 32) {
                      roundConstantLsw ^= 1 << bitPosition;
                    } else /* if (bitPosition >= 32) */{
                        roundConstantMsw ^= 1 << bitPosition - 32;
                      }
                  }

                  // Compute next LFSR
                  if (LFSR & 0x80) {
                    // Primitive polynomial over GF(2): x^8 + x^6 + x^5 + x^4 + 1
                    LFSR = LFSR << 1 ^ 0x71;
                  } else {
                    LFSR <<= 1;
                  }
                }
                ROUND_CONSTANTS[i] = X64Word.create(roundConstantMsw, roundConstantLsw);
              }
            })();

            // Reusable objects for temporary values
            var T = [];
            (function () {
              for (var i = 0; i < 25; i++) {
                T[i] = X64Word.create();
              }
            })();

            /**
             * SHA-3 hash algorithm.
             */
            var SHA3 = C_algo.SHA3 = Hasher.extend({
              /**
               * Configuration options.
               *
               * @property {number} outputLength
               *   The desired number of bits in the output hash.
               *   Only values permitted are: 224, 256, 384, 512.
               *   Default: 512
               */
              cfg: Hasher.cfg.extend({
                outputLength: 512
              }),
              _doReset: function () {
                var state = this._state = [];
                for (var i = 0; i < 25; i++) {
                  state[i] = new X64Word.init();
                }
                this.blockSize = (1600 - 2 * this.cfg.outputLength) / 32;
              },
              _doProcessBlock: function (M, offset) {
                // Shortcuts
                var state = this._state;
                var nBlockSizeLanes = this.blockSize / 2;

                // Absorb
                for (var i = 0; i < nBlockSizeLanes; i++) {
                  // Shortcuts
                  var M2i = M[offset + 2 * i];
                  var M2i1 = M[offset + 2 * i + 1];

                  // Swap endian
                  M2i = (M2i << 8 | M2i >>> 24) & 0x00ff00ff | (M2i << 24 | M2i >>> 8) & 0xff00ff00;
                  M2i1 = (M2i1 << 8 | M2i1 >>> 24) & 0x00ff00ff | (M2i1 << 24 | M2i1 >>> 8) & 0xff00ff00;

                  // Absorb message into state
                  var lane = state[i];
                  lane.high ^= M2i1;
                  lane.low ^= M2i;
                }

                // Rounds
                for (var round = 0; round < 24; round++) {
                  // Theta
                  for (var x = 0; x < 5; x++) {
                    // Mix column lanes
                    var tMsw = 0,
                      tLsw = 0;
                    for (var y = 0; y < 5; y++) {
                      var lane = state[x + 5 * y];
                      tMsw ^= lane.high;
                      tLsw ^= lane.low;
                    }

                    // Temporary values
                    var Tx = T[x];
                    Tx.high = tMsw;
                    Tx.low = tLsw;
                  }
                  for (var x = 0; x < 5; x++) {
                    // Shortcuts
                    var Tx4 = T[(x + 4) % 5];
                    var Tx1 = T[(x + 1) % 5];
                    var Tx1Msw = Tx1.high;
                    var Tx1Lsw = Tx1.low;

                    // Mix surrounding columns
                    var tMsw = Tx4.high ^ (Tx1Msw << 1 | Tx1Lsw >>> 31);
                    var tLsw = Tx4.low ^ (Tx1Lsw << 1 | Tx1Msw >>> 31);
                    for (var y = 0; y < 5; y++) {
                      var lane = state[x + 5 * y];
                      lane.high ^= tMsw;
                      lane.low ^= tLsw;
                    }
                  }

                  // Rho Pi
                  for (var laneIndex = 1; laneIndex < 25; laneIndex++) {
                    // Shortcuts
                    var lane = state[laneIndex];
                    var laneMsw = lane.high;
                    var laneLsw = lane.low;
                    var rhoOffset = RHO_OFFSETS[laneIndex];

                    // Rotate lanes
                    if (rhoOffset < 32) {
                      var tMsw = laneMsw << rhoOffset | laneLsw >>> 32 - rhoOffset;
                      var tLsw = laneLsw << rhoOffset | laneMsw >>> 32 - rhoOffset;
                    } else /* if (rhoOffset >= 32) */{
                        var tMsw = laneLsw << rhoOffset - 32 | laneMsw >>> 64 - rhoOffset;
                        var tLsw = laneMsw << rhoOffset - 32 | laneLsw >>> 64 - rhoOffset;
                      }

                    // Transpose lanes
                    var TPiLane = T[PI_INDEXES[laneIndex]];
                    TPiLane.high = tMsw;
                    TPiLane.low = tLsw;
                  }

                  // Rho pi at x = y = 0
                  var T0 = T[0];
                  var state0 = state[0];
                  T0.high = state0.high;
                  T0.low = state0.low;

                  // Chi
                  for (var x = 0; x < 5; x++) {
                    for (var y = 0; y < 5; y++) {
                      // Shortcuts
                      var laneIndex = x + 5 * y;
                      var lane = state[laneIndex];
                      var TLane = T[laneIndex];
                      var Tx1Lane = T[(x + 1) % 5 + 5 * y];
                      var Tx2Lane = T[(x + 2) % 5 + 5 * y];

                      // Mix rows
                      lane.high = TLane.high ^ ~Tx1Lane.high & Tx2Lane.high;
                      lane.low = TLane.low ^ ~Tx1Lane.low & Tx2Lane.low;
                    }
                  }

                  // Iota
                  var lane = state[0];
                  var roundConstant = ROUND_CONSTANTS[round];
                  lane.high ^= roundConstant.high;
                  lane.low ^= roundConstant.low;
                }
              },
              _doFinalize: function () {
                // Shortcuts
                var data = this._data;
                var dataWords = data.words;
                var nBitsTotal = this._nDataBytes * 8;
                var nBitsLeft = data.sigBytes * 8;
                var blockSizeBits = this.blockSize * 32;

                // Add padding
                dataWords[nBitsLeft >>> 5] |= 0x1 << 24 - nBitsLeft % 32;
                dataWords[(Math.ceil((nBitsLeft + 1) / blockSizeBits) * blockSizeBits >>> 5) - 1] |= 0x80;
                data.sigBytes = dataWords.length * 4;

                // Hash final blocks
                this._process();

                // Shortcuts
                var state = this._state;
                var outputLengthBytes = this.cfg.outputLength / 8;
                var outputLengthLanes = outputLengthBytes / 8;

                // Squeeze
                var hashWords = [];
                for (var i = 0; i < outputLengthLanes; i++) {
                  // Shortcuts
                  var lane = state[i];
                  var laneMsw = lane.high;
                  var laneLsw = lane.low;

                  // Swap endian
                  laneMsw = (laneMsw << 8 | laneMsw >>> 24) & 0x00ff00ff | (laneMsw << 24 | laneMsw >>> 8) & 0xff00ff00;
                  laneLsw = (laneLsw << 8 | laneLsw >>> 24) & 0x00ff00ff | (laneLsw << 24 | laneLsw >>> 8) & 0xff00ff00;

                  // Squeeze state to retrieve hash
                  hashWords.push(laneLsw);
                  hashWords.push(laneMsw);
                }

                // Return final computed hash
                return new WordArray.init(hashWords, outputLengthBytes);
              },
              clone: function () {
                var clone = Hasher.clone.call(this);
                var state = clone._state = this._state.slice(0);
                for (var i = 0; i < 25; i++) {
                  state[i] = state[i].clone();
                }
                return clone;
              }
            });

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA3('message');
             *     var hash = CryptoJS.SHA3(wordArray);
             */
            C.SHA3 = Hasher._createHelper(SHA3);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA3(message, key);
             */
            C.HmacSHA3 = Hasher._createHmacHelper(SHA3);
          })(Math);
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Hasher = C_lib.Hasher;
            var C_x64 = C.x64;
            var X64Word = C_x64.Word;
            var X64WordArray = C_x64.WordArray;
            var C_algo = C.algo;
            function X64Word_create() {
              return X64Word.create.apply(X64Word, arguments);
            }

            // Constants
            var K = [X64Word_create(0x428a2f98, 0xd728ae22), X64Word_create(0x71374491, 0x23ef65cd), X64Word_create(0xb5c0fbcf, 0xec4d3b2f), X64Word_create(0xe9b5dba5, 0x8189dbbc), X64Word_create(0x3956c25b, 0xf348b538), X64Word_create(0x59f111f1, 0xb605d019), X64Word_create(0x923f82a4, 0xaf194f9b), X64Word_create(0xab1c5ed5, 0xda6d8118), X64Word_create(0xd807aa98, 0xa3030242), X64Word_create(0x12835b01, 0x45706fbe), X64Word_create(0x243185be, 0x4ee4b28c), X64Word_create(0x550c7dc3, 0xd5ffb4e2), X64Word_create(0x72be5d74, 0xf27b896f), X64Word_create(0x80deb1fe, 0x3b1696b1), X64Word_create(0x9bdc06a7, 0x25c71235), X64Word_create(0xc19bf174, 0xcf692694), X64Word_create(0xe49b69c1, 0x9ef14ad2), X64Word_create(0xefbe4786, 0x384f25e3), X64Word_create(0x0fc19dc6, 0x8b8cd5b5), X64Word_create(0x240ca1cc, 0x77ac9c65), X64Word_create(0x2de92c6f, 0x592b0275), X64Word_create(0x4a7484aa, 0x6ea6e483), X64Word_create(0x5cb0a9dc, 0xbd41fbd4), X64Word_create(0x76f988da, 0x831153b5), X64Word_create(0x983e5152, 0xee66dfab), X64Word_create(0xa831c66d, 0x2db43210), X64Word_create(0xb00327c8, 0x98fb213f), X64Word_create(0xbf597fc7, 0xbeef0ee4), X64Word_create(0xc6e00bf3, 0x3da88fc2), X64Word_create(0xd5a79147, 0x930aa725), X64Word_create(0x06ca6351, 0xe003826f), X64Word_create(0x14292967, 0x0a0e6e70), X64Word_create(0x27b70a85, 0x46d22ffc), X64Word_create(0x2e1b2138, 0x5c26c926), X64Word_create(0x4d2c6dfc, 0x5ac42aed), X64Word_create(0x53380d13, 0x9d95b3df), X64Word_create(0x650a7354, 0x8baf63de), X64Word_create(0x766a0abb, 0x3c77b2a8), X64Word_create(0x81c2c92e, 0x47edaee6), X64Word_create(0x92722c85, 0x1482353b), X64Word_create(0xa2bfe8a1, 0x4cf10364), X64Word_create(0xa81a664b, 0xbc423001), X64Word_create(0xc24b8b70, 0xd0f89791), X64Word_create(0xc76c51a3, 0x0654be30), X64Word_create(0xd192e819, 0xd6ef5218), X64Word_create(0xd6990624, 0x5565a910), X64Word_create(0xf40e3585, 0x5771202a), X64Word_create(0x106aa070, 0x32bbd1b8), X64Word_create(0x19a4c116, 0xb8d2d0c8), X64Word_create(0x1e376c08, 0x5141ab53), X64Word_create(0x2748774c, 0xdf8eeb99), X64Word_create(0x34b0bcb5, 0xe19b48a8), X64Word_create(0x391c0cb3, 0xc5c95a63), X64Word_create(0x4ed8aa4a, 0xe3418acb), X64Word_create(0x5b9cca4f, 0x7763e373), X64Word_create(0x682e6ff3, 0xd6b2b8a3), X64Word_create(0x748f82ee, 0x5defb2fc), X64Word_create(0x78a5636f, 0x43172f60), X64Word_create(0x84c87814, 0xa1f0ab72), X64Word_create(0x8cc70208, 0x1a6439ec), X64Word_create(0x90befffa, 0x23631e28), X64Word_create(0xa4506ceb, 0xde82bde9), X64Word_create(0xbef9a3f7, 0xb2c67915), X64Word_create(0xc67178f2, 0xe372532b), X64Word_create(0xca273ece, 0xea26619c), X64Word_create(0xd186b8c7, 0x21c0c207), X64Word_create(0xeada7dd6, 0xcde0eb1e), X64Word_create(0xf57d4f7f, 0xee6ed178), X64Word_create(0x06f067aa, 0x72176fba), X64Word_create(0x0a637dc5, 0xa2c898a6), X64Word_create(0x113f9804, 0xbef90dae), X64Word_create(0x1b710b35, 0x131c471b), X64Word_create(0x28db77f5, 0x23047d84), X64Word_create(0x32caab7b, 0x40c72493), X64Word_create(0x3c9ebe0a, 0x15c9bebc), X64Word_create(0x431d67c4, 0x9c100d4c), X64Word_create(0x4cc5d4be, 0xcb3e42b6), X64Word_create(0x597f299c, 0xfc657e2a), X64Word_create(0x5fcb6fab, 0x3ad6faec), X64Word_create(0x6c44198c, 0x4a475817)];

            // Reusable objects
            var W = [];
            (function () {
              for (var i = 0; i < 80; i++) {
                W[i] = X64Word_create();
              }
            })();

            /**
             * SHA-512 hash algorithm.
             */
            var SHA512 = C_algo.SHA512 = Hasher.extend({
              _doReset: function () {
                this._hash = new X64WordArray.init([new X64Word.init(0x6a09e667, 0xf3bcc908), new X64Word.init(0xbb67ae85, 0x84caa73b), new X64Word.init(0x3c6ef372, 0xfe94f82b), new X64Word.init(0xa54ff53a, 0x5f1d36f1), new X64Word.init(0x510e527f, 0xade682d1), new X64Word.init(0x9b05688c, 0x2b3e6c1f), new X64Word.init(0x1f83d9ab, 0xfb41bd6b), new X64Word.init(0x5be0cd19, 0x137e2179)]);
              },
              _doProcessBlock: function (M, offset) {
                // Shortcuts
                var H = this._hash.words;
                var H0 = H[0];
                var H1 = H[1];
                var H2 = H[2];
                var H3 = H[3];
                var H4 = H[4];
                var H5 = H[5];
                var H6 = H[6];
                var H7 = H[7];
                var H0h = H0.high;
                var H0l = H0.low;
                var H1h = H1.high;
                var H1l = H1.low;
                var H2h = H2.high;
                var H2l = H2.low;
                var H3h = H3.high;
                var H3l = H3.low;
                var H4h = H4.high;
                var H4l = H4.low;
                var H5h = H5.high;
                var H5l = H5.low;
                var H6h = H6.high;
                var H6l = H6.low;
                var H7h = H7.high;
                var H7l = H7.low;

                // Working variables
                var ah = H0h;
                var al = H0l;
                var bh = H1h;
                var bl = H1l;
                var ch = H2h;
                var cl = H2l;
                var dh = H3h;
                var dl = H3l;
                var eh = H4h;
                var el = H4l;
                var fh = H5h;
                var fl = H5l;
                var gh = H6h;
                var gl = H6l;
                var hh = H7h;
                var hl = H7l;

                // Rounds
                for (var i = 0; i < 80; i++) {
                  // Shortcut
                  var Wi = W[i];

                  // Extend message
                  if (i < 16) {
                    var Wih = Wi.high = M[offset + i * 2] | 0;
                    var Wil = Wi.low = M[offset + i * 2 + 1] | 0;
                  } else {
                    // Gamma0
                    var gamma0x = W[i - 15];
                    var gamma0xh = gamma0x.high;
                    var gamma0xl = gamma0x.low;
                    var gamma0h = (gamma0xh >>> 1 | gamma0xl << 31) ^ (gamma0xh >>> 8 | gamma0xl << 24) ^ gamma0xh >>> 7;
                    var gamma0l = (gamma0xl >>> 1 | gamma0xh << 31) ^ (gamma0xl >>> 8 | gamma0xh << 24) ^ (gamma0xl >>> 7 | gamma0xh << 25);

                    // Gamma1
                    var gamma1x = W[i - 2];
                    var gamma1xh = gamma1x.high;
                    var gamma1xl = gamma1x.low;
                    var gamma1h = (gamma1xh >>> 19 | gamma1xl << 13) ^ (gamma1xh << 3 | gamma1xl >>> 29) ^ gamma1xh >>> 6;
                    var gamma1l = (gamma1xl >>> 19 | gamma1xh << 13) ^ (gamma1xl << 3 | gamma1xh >>> 29) ^ (gamma1xl >>> 6 | gamma1xh << 26);

                    // W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16]
                    var Wi7 = W[i - 7];
                    var Wi7h = Wi7.high;
                    var Wi7l = Wi7.low;
                    var Wi16 = W[i - 16];
                    var Wi16h = Wi16.high;
                    var Wi16l = Wi16.low;
                    var Wil = gamma0l + Wi7l;
                    var Wih = gamma0h + Wi7h + (Wil >>> 0 < gamma0l >>> 0 ? 1 : 0);
                    var Wil = Wil + gamma1l;
                    var Wih = Wih + gamma1h + (Wil >>> 0 < gamma1l >>> 0 ? 1 : 0);
                    var Wil = Wil + Wi16l;
                    var Wih = Wih + Wi16h + (Wil >>> 0 < Wi16l >>> 0 ? 1 : 0);
                    Wi.high = Wih;
                    Wi.low = Wil;
                  }
                  var chh = eh & fh ^ ~eh & gh;
                  var chl = el & fl ^ ~el & gl;
                  var majh = ah & bh ^ ah & ch ^ bh & ch;
                  var majl = al & bl ^ al & cl ^ bl & cl;
                  var sigma0h = (ah >>> 28 | al << 4) ^ (ah << 30 | al >>> 2) ^ (ah << 25 | al >>> 7);
                  var sigma0l = (al >>> 28 | ah << 4) ^ (al << 30 | ah >>> 2) ^ (al << 25 | ah >>> 7);
                  var sigma1h = (eh >>> 14 | el << 18) ^ (eh >>> 18 | el << 14) ^ (eh << 23 | el >>> 9);
                  var sigma1l = (el >>> 14 | eh << 18) ^ (el >>> 18 | eh << 14) ^ (el << 23 | eh >>> 9);

                  // t1 = h + sigma1 + ch + K[i] + W[i]
                  var Ki = K[i];
                  var Kih = Ki.high;
                  var Kil = Ki.low;
                  var t1l = hl + sigma1l;
                  var t1h = hh + sigma1h + (t1l >>> 0 < hl >>> 0 ? 1 : 0);
                  var t1l = t1l + chl;
                  var t1h = t1h + chh + (t1l >>> 0 < chl >>> 0 ? 1 : 0);
                  var t1l = t1l + Kil;
                  var t1h = t1h + Kih + (t1l >>> 0 < Kil >>> 0 ? 1 : 0);
                  var t1l = t1l + Wil;
                  var t1h = t1h + Wih + (t1l >>> 0 < Wil >>> 0 ? 1 : 0);

                  // t2 = sigma0 + maj
                  var t2l = sigma0l + majl;
                  var t2h = sigma0h + majh + (t2l >>> 0 < sigma0l >>> 0 ? 1 : 0);

                  // Update working variables
                  hh = gh;
                  hl = gl;
                  gh = fh;
                  gl = fl;
                  fh = eh;
                  fl = el;
                  el = dl + t1l | 0;
                  eh = dh + t1h + (el >>> 0 < dl >>> 0 ? 1 : 0) | 0;
                  dh = ch;
                  dl = cl;
                  ch = bh;
                  cl = bl;
                  bh = ah;
                  bl = al;
                  al = t1l + t2l | 0;
                  ah = t1h + t2h + (al >>> 0 < t1l >>> 0 ? 1 : 0) | 0;
                }

                // Intermediate hash value
                H0l = H0.low = H0l + al;
                H0.high = H0h + ah + (H0l >>> 0 < al >>> 0 ? 1 : 0);
                H1l = H1.low = H1l + bl;
                H1.high = H1h + bh + (H1l >>> 0 < bl >>> 0 ? 1 : 0);
                H2l = H2.low = H2l + cl;
                H2.high = H2h + ch + (H2l >>> 0 < cl >>> 0 ? 1 : 0);
                H3l = H3.low = H3l + dl;
                H3.high = H3h + dh + (H3l >>> 0 < dl >>> 0 ? 1 : 0);
                H4l = H4.low = H4l + el;
                H4.high = H4h + eh + (H4l >>> 0 < el >>> 0 ? 1 : 0);
                H5l = H5.low = H5l + fl;
                H5.high = H5h + fh + (H5l >>> 0 < fl >>> 0 ? 1 : 0);
                H6l = H6.low = H6l + gl;
                H6.high = H6h + gh + (H6l >>> 0 < gl >>> 0 ? 1 : 0);
                H7l = H7.low = H7l + hl;
                H7.high = H7h + hh + (H7l >>> 0 < hl >>> 0 ? 1 : 0);
              },
              _doFinalize: function () {
                // Shortcuts
                var data = this._data;
                var dataWords = data.words;
                var nBitsTotal = this._nDataBytes * 8;
                var nBitsLeft = data.sigBytes * 8;

                // Add padding
                dataWords[nBitsLeft >>> 5] |= 0x80 << 24 - nBitsLeft % 32;
                dataWords[(nBitsLeft + 128 >>> 10 << 5) + 30] = Math.floor(nBitsTotal / 0x100000000);
                dataWords[(nBitsLeft + 128 >>> 10 << 5) + 31] = nBitsTotal;
                data.sigBytes = dataWords.length * 4;

                // Hash final blocks
                this._process();

                // Convert hash to 32-bit word array before returning
                var hash = this._hash.toX32();

                // Return final computed hash
                return hash;
              },
              clone: function () {
                var clone = Hasher.clone.call(this);
                clone._hash = this._hash.clone();
                return clone;
              },
              blockSize: 1024 / 32
            });

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA512('message');
             *     var hash = CryptoJS.SHA512(wordArray);
             */
            C.SHA512 = Hasher._createHelper(SHA512);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA512(message, key);
             */
            C.HmacSHA512 = Hasher._createHmacHelper(SHA512);
          })();
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_x64 = C.x64;
            var X64Word = C_x64.Word;
            var X64WordArray = C_x64.WordArray;
            var C_algo = C.algo;
            var SHA512 = C_algo.SHA512;

            /**
             * SHA-384 hash algorithm.
             */
            var SHA384 = C_algo.SHA384 = SHA512.extend({
              _doReset: function () {
                this._hash = new X64WordArray.init([new X64Word.init(0xcbbb9d5d, 0xc1059ed8), new X64Word.init(0x629a292a, 0x367cd507), new X64Word.init(0x9159015a, 0x3070dd17), new X64Word.init(0x152fecd8, 0xf70e5939), new X64Word.init(0x67332667, 0xffc00b31), new X64Word.init(0x8eb44a87, 0x68581511), new X64Word.init(0xdb0c2e0d, 0x64f98fa7), new X64Word.init(0x47b5481d, 0xbefa4fa4)]);
              },
              _doFinalize: function () {
                var hash = SHA512._doFinalize.call(this);
                hash.sigBytes -= 16;
                return hash;
              }
            });

            /**
             * Shortcut function to the hasher's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             *
             * @return {WordArray} The hash.
             *
             * @static
             *
             * @example
             *
             *     var hash = CryptoJS.SHA384('message');
             *     var hash = CryptoJS.SHA384(wordArray);
             */
            C.SHA384 = SHA512._createHelper(SHA384);

            /**
             * Shortcut function to the HMAC's object interface.
             *
             * @param {WordArray|string} message The message to hash.
             * @param {WordArray|string} key The secret key.
             *
             * @return {WordArray} The HMAC.
             *
             * @static
             *
             * @example
             *
             *     var hmac = CryptoJS.HmacSHA384(message, key);
             */
            C.HmacSHA384 = SHA512._createHmacHelper(SHA384);
          })();

          /**
           * Cipher core components.
           */
          CryptoJS.lib.Cipher || function (undefined$1) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var Base = C_lib.Base;
            var WordArray = C_lib.WordArray;
            var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;
            var C_enc = C.enc;
            var Utf8 = C_enc.Utf8;
            var Base64 = C_enc.Base64;
            var C_algo = C.algo;
            var EvpKDF = C_algo.EvpKDF;

            /**
             * Abstract base cipher template.
             *
             * @property {number} keySize This cipher's key size. Default: 4 (128 bits)
             * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)
             * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.
             * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.
             */
            var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({
              /**
               * Configuration options.
               *
               * @property {WordArray} iv The IV to use for this operation.
               */
              cfg: Base.extend(),
              /**
               * Creates this cipher in encryption mode.
               *
               * @param {WordArray} key The key.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @return {Cipher} A cipher instance.
               *
               * @static
               *
               * @example
               *
               *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });
               */
              createEncryptor: function (key, cfg) {
                return this.create(this._ENC_XFORM_MODE, key, cfg);
              },
              /**
               * Creates this cipher in decryption mode.
               *
               * @param {WordArray} key The key.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @return {Cipher} A cipher instance.
               *
               * @static
               *
               * @example
               *
               *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });
               */
              createDecryptor: function (key, cfg) {
                return this.create(this._DEC_XFORM_MODE, key, cfg);
              },
              /**
               * Initializes a newly created cipher.
               *
               * @param {number} xformMode Either the encryption or decryption transormation mode constant.
               * @param {WordArray} key The key.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @example
               *
               *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });
               */
              init: function (xformMode, key, cfg) {
                // Apply config defaults
                this.cfg = this.cfg.extend(cfg);

                // Store transform mode and key
                this._xformMode = xformMode;
                this._key = key;

                // Set initial values
                this.reset();
              },
              /**
               * Resets this cipher to its initial state.
               *
               * @example
               *
               *     cipher.reset();
               */
              reset: function () {
                // Reset data buffer
                BufferedBlockAlgorithm.reset.call(this);

                // Perform concrete-cipher logic
                this._doReset();
              },
              /**
               * Adds data to be encrypted or decrypted.
               *
               * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.
               *
               * @return {WordArray} The data after processing.
               *
               * @example
               *
               *     var encrypted = cipher.process('data');
               *     var encrypted = cipher.process(wordArray);
               */
              process: function (dataUpdate) {
                // Append
                this._append(dataUpdate);

                // Process available blocks
                return this._process();
              },
              /**
               * Finalizes the encryption or decryption process.
               * Note that the finalize operation is effectively a destructive, read-once operation.
               *
               * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.
               *
               * @return {WordArray} The data after final processing.
               *
               * @example
               *
               *     var encrypted = cipher.finalize();
               *     var encrypted = cipher.finalize('data');
               *     var encrypted = cipher.finalize(wordArray);
               */
              finalize: function (dataUpdate) {
                // Final data update
                if (dataUpdate) {
                  this._append(dataUpdate);
                }

                // Perform concrete-cipher logic
                var finalProcessedData = this._doFinalize();
                return finalProcessedData;
              },
              keySize: 128 / 32,
              ivSize: 128 / 32,
              _ENC_XFORM_MODE: 1,
              _DEC_XFORM_MODE: 2,
              /**
               * Creates shortcut functions to a cipher's object interface.
               *
               * @param {Cipher} cipher The cipher to create a helper for.
               *
               * @return {Object} An object with encrypt and decrypt shortcut functions.
               *
               * @static
               *
               * @example
               *
               *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);
               */
              _createHelper: function () {
                function selectCipherStrategy(key) {
                  if (typeof key == 'string') {
                    return PasswordBasedCipher;
                  } else {
                    return SerializableCipher;
                  }
                }
                return function (cipher) {
                  return {
                    encrypt: function (message, key, cfg) {
                      return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);
                    },
                    decrypt: function (ciphertext, key, cfg) {
                      return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);
                    }
                  };
                };
              }()
            });

            /**
             * Abstract base stream cipher template.
             *
             * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)
             */
            var StreamCipher = C_lib.StreamCipher = Cipher.extend({
              _doFinalize: function () {
                // Process partial blocks
                var finalProcessedBlocks = this._process(!!'flush');
                return finalProcessedBlocks;
              },
              blockSize: 1
            });

            /**
             * Mode namespace.
             */
            var C_mode = C.mode = {};

            /**
             * Abstract base block cipher mode template.
             */
            var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({
              /**
               * Creates this mode for encryption.
               *
               * @param {Cipher} cipher A block cipher instance.
               * @param {Array} iv The IV words.
               *
               * @static
               *
               * @example
               *
               *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);
               */
              createEncryptor: function (cipher, iv) {
                return this.Encryptor.create(cipher, iv);
              },
              /**
               * Creates this mode for decryption.
               *
               * @param {Cipher} cipher A block cipher instance.
               * @param {Array} iv The IV words.
               *
               * @static
               *
               * @example
               *
               *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);
               */
              createDecryptor: function (cipher, iv) {
                return this.Decryptor.create(cipher, iv);
              },
              /**
               * Initializes a newly created mode.
               *
               * @param {Cipher} cipher A block cipher instance.
               * @param {Array} iv The IV words.
               *
               * @example
               *
               *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);
               */
              init: function (cipher, iv) {
                this._cipher = cipher;
                this._iv = iv;
              }
            });

            /**
             * Cipher Block Chaining mode.
             */
            var CBC = C_mode.CBC = function () {
              /**
               * Abstract base CBC mode.
               */
              var CBC = BlockCipherMode.extend();

              /**
               * CBC encryptor.
               */
              CBC.Encryptor = CBC.extend({
                /**
                 * Processes the data block at offset.
                 *
                 * @param {Array} words The data words to operate on.
                 * @param {number} offset The offset where the block starts.
                 *
                 * @example
                 *
                 *     mode.processBlock(data.words, offset);
                 */
                processBlock: function (words, offset) {
                  // Shortcuts
                  var cipher = this._cipher;
                  var blockSize = cipher.blockSize;

                  // XOR and encrypt
                  xorBlock.call(this, words, offset, blockSize);
                  cipher.encryptBlock(words, offset);

                  // Remember this block to use with next block
                  this._prevBlock = words.slice(offset, offset + blockSize);
                }
              });

              /**
               * CBC decryptor.
               */
              CBC.Decryptor = CBC.extend({
                /**
                 * Processes the data block at offset.
                 *
                 * @param {Array} words The data words to operate on.
                 * @param {number} offset The offset where the block starts.
                 *
                 * @example
                 *
                 *     mode.processBlock(data.words, offset);
                 */
                processBlock: function (words, offset) {
                  // Shortcuts
                  var cipher = this._cipher;
                  var blockSize = cipher.blockSize;

                  // Remember this block to use with next block
                  var thisBlock = words.slice(offset, offset + blockSize);

                  // Decrypt and XOR
                  cipher.decryptBlock(words, offset);
                  xorBlock.call(this, words, offset, blockSize);

                  // This block becomes the previous block
                  this._prevBlock = thisBlock;
                }
              });
              function xorBlock(words, offset, blockSize) {
                // Shortcut
                var iv = this._iv;

                // Choose mixing block
                if (iv) {
                  var block = iv;

                  // Remove IV for subsequent blocks
                  this._iv = undefined$1;
                } else {
                  var block = this._prevBlock;
                }

                // XOR blocks
                for (var i = 0; i < blockSize; i++) {
                  words[offset + i] ^= block[i];
                }
              }
              return CBC;
            }();

            /**
             * Padding namespace.
             */
            var C_pad = C.pad = {};

            /**
             * PKCS #5/7 padding strategy.
             */
            var Pkcs7 = C_pad.Pkcs7 = {
              /**
               * Pads data using the algorithm defined in PKCS #5/7.
               *
               * @param {WordArray} data The data to pad.
               * @param {number} blockSize The multiple that the data should be padded to.
               *
               * @static
               *
               * @example
               *
               *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);
               */
              pad: function (data, blockSize) {
                // Shortcut
                var blockSizeBytes = blockSize * 4;

                // Count padding bytes
                var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

                // Create padding word
                var paddingWord = nPaddingBytes << 24 | nPaddingBytes << 16 | nPaddingBytes << 8 | nPaddingBytes;

                // Create padding
                var paddingWords = [];
                for (var i = 0; i < nPaddingBytes; i += 4) {
                  paddingWords.push(paddingWord);
                }
                var padding = WordArray.create(paddingWords, nPaddingBytes);

                // Add padding
                data.concat(padding);
              },
              /**
               * Unpads data that had been padded using the algorithm defined in PKCS #5/7.
               *
               * @param {WordArray} data The data to unpad.
               *
               * @static
               *
               * @example
               *
               *     CryptoJS.pad.Pkcs7.unpad(wordArray);
               */
              unpad: function (data) {
                // Get number of padding bytes from last byte
                var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff;

                // Remove padding
                data.sigBytes -= nPaddingBytes;
              }
            };

            /**
             * Abstract base block cipher template.
             *
             * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)
             */
            var BlockCipher = C_lib.BlockCipher = Cipher.extend({
              /**
               * Configuration options.
               *
               * @property {Mode} mode The block mode to use. Default: CBC
               * @property {Padding} padding The padding strategy to use. Default: Pkcs7
               */
              cfg: Cipher.cfg.extend({
                mode: CBC,
                padding: Pkcs7
              }),
              reset: function () {
                // Reset cipher
                Cipher.reset.call(this);

                // Shortcuts
                var cfg = this.cfg;
                var iv = cfg.iv;
                var mode = cfg.mode;

                // Reset block mode
                if (this._xformMode == this._ENC_XFORM_MODE) {
                  var modeCreator = mode.createEncryptor;
                } else /* if (this._xformMode == this._DEC_XFORM_MODE) */{
                    var modeCreator = mode.createDecryptor;
                    // Keep at least one block in the buffer for unpadding
                    this._minBufferSize = 1;
                  }
                if (this._mode && this._mode.__creator == modeCreator) {
                  this._mode.init(this, iv && iv.words);
                } else {
                  this._mode = modeCreator.call(mode, this, iv && iv.words);
                  this._mode.__creator = modeCreator;
                }
              },
              _doProcessBlock: function (words, offset) {
                this._mode.processBlock(words, offset);
              },
              _doFinalize: function () {
                // Shortcut
                var padding = this.cfg.padding;

                // Finalize
                if (this._xformMode == this._ENC_XFORM_MODE) {
                  // Pad data
                  padding.pad(this._data, this.blockSize);

                  // Process final blocks
                  var finalProcessedBlocks = this._process(!!'flush');
                } else /* if (this._xformMode == this._DEC_XFORM_MODE) */{
                    // Process final blocks
                    var finalProcessedBlocks = this._process(!!'flush');

                    // Unpad data
                    padding.unpad(finalProcessedBlocks);
                  }
                return finalProcessedBlocks;
              },
              blockSize: 128 / 32
            });

            /**
             * A collection of cipher parameters.
             *
             * @property {WordArray} ciphertext The raw ciphertext.
             * @property {WordArray} key The key to this ciphertext.
             * @property {WordArray} iv The IV used in the ciphering operation.
             * @property {WordArray} salt The salt used with a key derivation function.
             * @property {Cipher} algorithm The cipher algorithm.
             * @property {Mode} mode The block mode used in the ciphering operation.
             * @property {Padding} padding The padding scheme used in the ciphering operation.
             * @property {number} blockSize The block size of the cipher.
             * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.
             */
            var CipherParams = C_lib.CipherParams = Base.extend({
              /**
               * Initializes a newly created cipher params object.
               *
               * @param {Object} cipherParams An object with any of the possible cipher parameters.
               *
               * @example
               *
               *     var cipherParams = CryptoJS.lib.CipherParams.create({
               *         ciphertext: ciphertextWordArray,
               *         key: keyWordArray,
               *         iv: ivWordArray,
               *         salt: saltWordArray,
               *         algorithm: CryptoJS.algo.AES,
               *         mode: CryptoJS.mode.CBC,
               *         padding: CryptoJS.pad.PKCS7,
               *         blockSize: 4,
               *         formatter: CryptoJS.format.OpenSSL
               *     });
               */
              init: function (cipherParams) {
                this.mixIn(cipherParams);
              },
              /**
               * Converts this cipher params object to a string.
               *
               * @param {Format} formatter (Optional) The formatting strategy to use.
               *
               * @return {string} The stringified cipher params.
               *
               * @throws Error If neither the formatter nor the default formatter is set.
               *
               * @example
               *
               *     var string = cipherParams + '';
               *     var string = cipherParams.toString();
               *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);
               */
              toString: function (formatter) {
                return (formatter || this.formatter).stringify(this);
              }
            });

            /**
             * Format namespace.
             */
            var C_format = C.format = {};

            /**
             * OpenSSL formatting strategy.
             */
            var OpenSSLFormatter = C_format.OpenSSL = {
              /**
               * Converts a cipher params object to an OpenSSL-compatible string.
               *
               * @param {CipherParams} cipherParams The cipher params object.
               *
               * @return {string} The OpenSSL-compatible string.
               *
               * @static
               *
               * @example
               *
               *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);
               */
              stringify: function (cipherParams) {
                // Shortcuts
                var ciphertext = cipherParams.ciphertext;
                var salt = cipherParams.salt;

                // Format
                if (salt) {
                  var wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);
                } else {
                  var wordArray = ciphertext;
                }
                return wordArray.toString(Base64);
              },
              /**
               * Converts an OpenSSL-compatible string to a cipher params object.
               *
               * @param {string} openSSLStr The OpenSSL-compatible string.
               *
               * @return {CipherParams} The cipher params object.
               *
               * @static
               *
               * @example
               *
               *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);
               */
              parse: function (openSSLStr) {
                // Parse base64
                var ciphertext = Base64.parse(openSSLStr);

                // Shortcut
                var ciphertextWords = ciphertext.words;

                // Test for salt
                if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {
                  // Extract salt
                  var salt = WordArray.create(ciphertextWords.slice(2, 4));

                  // Remove salt from ciphertext
                  ciphertextWords.splice(0, 4);
                  ciphertext.sigBytes -= 16;
                }
                return CipherParams.create({
                  ciphertext: ciphertext,
                  salt: salt
                });
              }
            };

            /**
             * A cipher wrapper that returns ciphertext as a serializable cipher params object.
             */
            var SerializableCipher = C_lib.SerializableCipher = Base.extend({
              /**
               * Configuration options.
               *
               * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL
               */
              cfg: Base.extend({
                format: OpenSSLFormatter
              }),
              /**
               * Encrypts a message.
               *
               * @param {Cipher} cipher The cipher algorithm to use.
               * @param {WordArray|string} message The message to encrypt.
               * @param {WordArray} key The key.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @return {CipherParams} A cipher params object.
               *
               * @static
               *
               * @example
               *
               *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);
               *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });
               *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });
               */
              encrypt: function (cipher, message, key, cfg) {
                // Apply config defaults
                cfg = this.cfg.extend(cfg);

                // Encrypt
                var encryptor = cipher.createEncryptor(key, cfg);
                var ciphertext = encryptor.finalize(message);

                // Shortcut
                var cipherCfg = encryptor.cfg;

                // Create and return serializable cipher params
                return CipherParams.create({
                  ciphertext: ciphertext,
                  key: key,
                  iv: cipherCfg.iv,
                  algorithm: cipher,
                  mode: cipherCfg.mode,
                  padding: cipherCfg.padding,
                  blockSize: cipher.blockSize,
                  formatter: cfg.format
                });
              },
              /**
               * Decrypts serialized ciphertext.
               *
               * @param {Cipher} cipher The cipher algorithm to use.
               * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
               * @param {WordArray} key The key.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @return {WordArray} The plaintext.
               *
               * @static
               *
               * @example
               *
               *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });
               *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });
               */
              decrypt: function (cipher, ciphertext, key, cfg) {
                // Apply config defaults
                cfg = this.cfg.extend(cfg);

                // Convert string to CipherParams
                ciphertext = this._parse(ciphertext, cfg.format);

                // Decrypt
                var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);
                return plaintext;
              },
              /**
               * Converts serialized ciphertext to CipherParams,
               * else assumed CipherParams already and returns ciphertext unchanged.
               *
               * @param {CipherParams|string} ciphertext The ciphertext.
               * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.
               *
               * @return {CipherParams} The unserialized ciphertext.
               *
               * @static
               *
               * @example
               *
               *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);
               */
              _parse: function (ciphertext, format) {
                if (typeof ciphertext == 'string') {
                  return format.parse(ciphertext, this);
                } else {
                  return ciphertext;
                }
              }
            });

            /**
             * Key derivation function namespace.
             */
            var C_kdf = C.kdf = {};

            /**
             * OpenSSL key derivation function.
             */
            var OpenSSLKdf = C_kdf.OpenSSL = {
              /**
               * Derives a key and IV from a password.
               *
               * @param {string} password The password to derive from.
               * @param {number} keySize The size in words of the key to generate.
               * @param {number} ivSize The size in words of the IV to generate.
               * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.
               *
               * @return {CipherParams} A cipher params object with the key, IV, and salt.
               *
               * @static
               *
               * @example
               *
               *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);
               *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');
               */
              execute: function (password, keySize, ivSize, salt) {
                // Generate random salt
                if (!salt) {
                  salt = WordArray.random(64 / 8);
                }

                // Derive key and IV
                var key = EvpKDF.create({
                  keySize: keySize + ivSize
                }).compute(password, salt);

                // Separate key and IV
                var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);
                key.sigBytes = keySize * 4;

                // Return params
                return CipherParams.create({
                  key: key,
                  iv: iv,
                  salt: salt
                });
              }
            };

            /**
             * A serializable cipher wrapper that derives the key from a password,
             * and returns ciphertext as a serializable cipher params object.
             */
            var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({
              /**
               * Configuration options.
               *
               * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL
               */
              cfg: SerializableCipher.cfg.extend({
                kdf: OpenSSLKdf
              }),
              /**
               * Encrypts a message using a password.
               *
               * @param {Cipher} cipher The cipher algorithm to use.
               * @param {WordArray|string} message The message to encrypt.
               * @param {string} password The password.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @return {CipherParams} A cipher params object.
               *
               * @static
               *
               * @example
               *
               *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');
               *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });
               */
              encrypt: function (cipher, message, password, cfg) {
                // Apply config defaults
                cfg = this.cfg.extend(cfg);

                // Derive key and other params
                var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);

                // Add IV to config
                cfg.iv = derivedParams.iv;

                // Encrypt
                var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);

                // Mix in derived params
                ciphertext.mixIn(derivedParams);
                return ciphertext;
              },
              /**
               * Decrypts serialized ciphertext using a password.
               *
               * @param {Cipher} cipher The cipher algorithm to use.
               * @param {CipherParams|string} ciphertext The ciphertext to decrypt.
               * @param {string} password The password.
               * @param {Object} cfg (Optional) The configuration options to use for this operation.
               *
               * @return {WordArray} The plaintext.
               *
               * @static
               *
               * @example
               *
               *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });
               *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });
               */
              decrypt: function (cipher, ciphertext, password, cfg) {
                // Apply config defaults
                cfg = this.cfg.extend(cfg);

                // Convert string to CipherParams
                ciphertext = this._parse(ciphertext, cfg.format);

                // Derive key and other params
                var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);

                // Add IV to config
                cfg.iv = derivedParams.iv;

                // Decrypt
                var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);
                return plaintext;
              }
            });
          }();

          /**
           * Cipher Feedback block mode.
           */
          CryptoJS.mode.CFB = function () {
            var CFB = CryptoJS.lib.BlockCipherMode.extend();
            CFB.Encryptor = CFB.extend({
              processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

                // Remember this block to use with next block
                this._prevBlock = words.slice(offset, offset + blockSize);
              }
            });
            CFB.Decryptor = CFB.extend({
              processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;

                // Remember this block to use with next block
                var thisBlock = words.slice(offset, offset + blockSize);
                generateKeystreamAndEncrypt.call(this, words, offset, blockSize, cipher);

                // This block becomes the previous block
                this._prevBlock = thisBlock;
              }
            });
            function generateKeystreamAndEncrypt(words, offset, blockSize, cipher) {
              // Shortcut
              var iv = this._iv;

              // Generate keystream
              if (iv) {
                var keystream = iv.slice(0);

                // Remove IV for subsequent blocks
                this._iv = undefined;
              } else {
                var keystream = this._prevBlock;
              }
              cipher.encryptBlock(keystream, 0);

              // Encrypt
              for (var i = 0; i < blockSize; i++) {
                words[offset + i] ^= keystream[i];
              }
            }
            return CFB;
          }();

          /**
           * Electronic Codebook block mode.
           */
          CryptoJS.mode.ECB = function () {
            var ECB = CryptoJS.lib.BlockCipherMode.extend();
            ECB.Encryptor = ECB.extend({
              processBlock: function (words, offset) {
                this._cipher.encryptBlock(words, offset);
              }
            });
            ECB.Decryptor = ECB.extend({
              processBlock: function (words, offset) {
                this._cipher.decryptBlock(words, offset);
              }
            });
            return ECB;
          }();

          /**
           * ANSI X.923 padding strategy.
           */
          CryptoJS.pad.AnsiX923 = {
            pad: function (data, blockSize) {
              // Shortcuts
              var dataSigBytes = data.sigBytes;
              var blockSizeBytes = blockSize * 4;

              // Count padding bytes
              var nPaddingBytes = blockSizeBytes - dataSigBytes % blockSizeBytes;

              // Compute last byte position
              var lastBytePos = dataSigBytes + nPaddingBytes - 1;

              // Pad
              data.clamp();
              data.words[lastBytePos >>> 2] |= nPaddingBytes << 24 - lastBytePos % 4 * 8;
              data.sigBytes += nPaddingBytes;
            },
            unpad: function (data) {
              // Get number of padding bytes from last byte
              var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff;

              // Remove padding
              data.sigBytes -= nPaddingBytes;
            }
          };

          /**
           * ISO 10126 padding strategy.
           */
          CryptoJS.pad.Iso10126 = {
            pad: function (data, blockSize) {
              // Shortcut
              var blockSizeBytes = blockSize * 4;

              // Count padding bytes
              var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;

              // Pad
              data.concat(CryptoJS.lib.WordArray.random(nPaddingBytes - 1)).concat(CryptoJS.lib.WordArray.create([nPaddingBytes << 24], 1));
            },
            unpad: function (data) {
              // Get number of padding bytes from last byte
              var nPaddingBytes = data.words[data.sigBytes - 1 >>> 2] & 0xff;

              // Remove padding
              data.sigBytes -= nPaddingBytes;
            }
          };

          /**
           * ISO/IEC 9797-1 Padding Method 2.
           */
          CryptoJS.pad.Iso97971 = {
            pad: function (data, blockSize) {
              // Add 0x80 byte
              data.concat(CryptoJS.lib.WordArray.create([0x80000000], 1));

              // Zero pad the rest
              CryptoJS.pad.ZeroPadding.pad(data, blockSize);
            },
            unpad: function (data) {
              // Remove zero padding
              CryptoJS.pad.ZeroPadding.unpad(data);

              // Remove one more byte -- the 0x80 byte
              data.sigBytes--;
            }
          };

          /**
           * Output Feedback block mode.
           */
          CryptoJS.mode.OFB = function () {
            var OFB = CryptoJS.lib.BlockCipherMode.extend();
            var Encryptor = OFB.Encryptor = OFB.extend({
              processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                var iv = this._iv;
                var keystream = this._keystream;

                // Generate keystream
                if (iv) {
                  keystream = this._keystream = iv.slice(0);

                  // Remove IV for subsequent blocks
                  this._iv = undefined;
                }
                cipher.encryptBlock(keystream, 0);

                // Encrypt
                for (var i = 0; i < blockSize; i++) {
                  words[offset + i] ^= keystream[i];
                }
              }
            });
            OFB.Decryptor = Encryptor;
            return OFB;
          }();

          /**
           * A noop padding strategy.
           */
          CryptoJS.pad.NoPadding = {
            pad: function () {},
            unpad: function () {}
          };
          (function (undefined$1) {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var CipherParams = C_lib.CipherParams;
            var C_enc = C.enc;
            var Hex = C_enc.Hex;
            var C_format = C.format;
            var HexFormatter = C_format.Hex = {
              /**
               * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.
               *
               * @param {CipherParams} cipherParams The cipher params object.
               *
               * @return {string} The hexadecimally encoded string.
               *
               * @static
               *
               * @example
               *
               *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);
               */
              stringify: function (cipherParams) {
                return cipherParams.ciphertext.toString(Hex);
              },
              /**
               * Converts a hexadecimally encoded ciphertext string to a cipher params object.
               *
               * @param {string} input The hexadecimally encoded string.
               *
               * @return {CipherParams} The cipher params object.
               *
               * @static
               *
               * @example
               *
               *     var cipherParams = CryptoJS.format.Hex.parse(hexString);
               */
              parse: function (input) {
                var ciphertext = Hex.parse(input);
                return CipherParams.create({
                  ciphertext: ciphertext
                });
              }
            };
          })();
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var BlockCipher = C_lib.BlockCipher;
            var C_algo = C.algo;

            // Lookup tables
            var SBOX = [];
            var INV_SBOX = [];
            var SUB_MIX_0 = [];
            var SUB_MIX_1 = [];
            var SUB_MIX_2 = [];
            var SUB_MIX_3 = [];
            var INV_SUB_MIX_0 = [];
            var INV_SUB_MIX_1 = [];
            var INV_SUB_MIX_2 = [];
            var INV_SUB_MIX_3 = [];

            // Compute lookup tables
            (function () {
              // Compute double table
              var d = [];
              for (var i = 0; i < 256; i++) {
                if (i < 128) {
                  d[i] = i << 1;
                } else {
                  d[i] = i << 1 ^ 0x11b;
                }
              }

              // Walk GF(2^8)
              var x = 0;
              var xi = 0;
              for (var i = 0; i < 256; i++) {
                // Compute sbox
                var sx = xi ^ xi << 1 ^ xi << 2 ^ xi << 3 ^ xi << 4;
                sx = sx >>> 8 ^ sx & 0xff ^ 0x63;
                SBOX[x] = sx;
                INV_SBOX[sx] = x;

                // Compute multiplication
                var x2 = d[x];
                var x4 = d[x2];
                var x8 = d[x4];

                // Compute sub bytes, mix columns tables
                var t = d[sx] * 0x101 ^ sx * 0x1010100;
                SUB_MIX_0[x] = t << 24 | t >>> 8;
                SUB_MIX_1[x] = t << 16 | t >>> 16;
                SUB_MIX_2[x] = t << 8 | t >>> 24;
                SUB_MIX_3[x] = t;

                // Compute inv sub bytes, inv mix columns tables
                var t = x8 * 0x1010101 ^ x4 * 0x10001 ^ x2 * 0x101 ^ x * 0x1010100;
                INV_SUB_MIX_0[sx] = t << 24 | t >>> 8;
                INV_SUB_MIX_1[sx] = t << 16 | t >>> 16;
                INV_SUB_MIX_2[sx] = t << 8 | t >>> 24;
                INV_SUB_MIX_3[sx] = t;

                // Compute next counter
                if (!x) {
                  x = xi = 1;
                } else {
                  x = x2 ^ d[d[d[x8 ^ x2]]];
                  xi ^= d[d[xi]];
                }
              }
            })();

            // Precomputed Rcon lookup
            var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];

            /**
             * AES block cipher algorithm.
             */
            var AES = C_algo.AES = BlockCipher.extend({
              _doReset: function () {
                // Skip reset of nRounds has been set before and key did not change
                if (this._nRounds && this._keyPriorReset === this._key) {
                  return;
                }

                // Shortcuts
                var key = this._keyPriorReset = this._key;
                var keyWords = key.words;
                var keySize = key.sigBytes / 4;

                // Compute number of rounds
                var nRounds = this._nRounds = keySize + 6;

                // Compute number of key schedule rows
                var ksRows = (nRounds + 1) * 4;

                // Compute key schedule
                var keySchedule = this._keySchedule = [];
                for (var ksRow = 0; ksRow < ksRows; ksRow++) {
                  if (ksRow < keySize) {
                    keySchedule[ksRow] = keyWords[ksRow];
                  } else {
                    var t = keySchedule[ksRow - 1];
                    if (!(ksRow % keySize)) {
                      // Rot word
                      t = t << 8 | t >>> 24;

                      // Sub word
                      t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 0xff] << 16 | SBOX[t >>> 8 & 0xff] << 8 | SBOX[t & 0xff];

                      // Mix Rcon
                      t ^= RCON[ksRow / keySize | 0] << 24;
                    } else if (keySize > 6 && ksRow % keySize == 4) {
                      // Sub word
                      t = SBOX[t >>> 24] << 24 | SBOX[t >>> 16 & 0xff] << 16 | SBOX[t >>> 8 & 0xff] << 8 | SBOX[t & 0xff];
                    }
                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;
                  }
                }

                // Compute inv key schedule
                var invKeySchedule = this._invKeySchedule = [];
                for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {
                  var ksRow = ksRows - invKsRow;
                  if (invKsRow % 4) {
                    var t = keySchedule[ksRow];
                  } else {
                    var t = keySchedule[ksRow - 4];
                  }
                  if (invKsRow < 4 || ksRow <= 4) {
                    invKeySchedule[invKsRow] = t;
                  } else {
                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[t >>> 16 & 0xff]] ^ INV_SUB_MIX_2[SBOX[t >>> 8 & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];
                  }
                }
              },
              encryptBlock: function (M, offset) {
                this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);
              },
              decryptBlock: function (M, offset) {
                // Swap 2nd and 4th rows
                var t = M[offset + 1];
                M[offset + 1] = M[offset + 3];
                M[offset + 3] = t;
                this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);

                // Inv swap 2nd and 4th rows
                var t = M[offset + 1];
                M[offset + 1] = M[offset + 3];
                M[offset + 3] = t;
              },
              _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {
                // Shortcut
                var nRounds = this._nRounds;

                // Get input, add round key
                var s0 = M[offset] ^ keySchedule[0];
                var s1 = M[offset + 1] ^ keySchedule[1];
                var s2 = M[offset + 2] ^ keySchedule[2];
                var s3 = M[offset + 3] ^ keySchedule[3];

                // Key schedule row counter
                var ksRow = 4;

                // Rounds
                for (var round = 1; round < nRounds; round++) {
                  // Shift rows, sub bytes, mix columns, add round key
                  var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[s1 >>> 16 & 0xff] ^ SUB_MIX_2[s2 >>> 8 & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];
                  var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[s2 >>> 16 & 0xff] ^ SUB_MIX_2[s3 >>> 8 & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];
                  var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[s3 >>> 16 & 0xff] ^ SUB_MIX_2[s0 >>> 8 & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];
                  var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[s0 >>> 16 & 0xff] ^ SUB_MIX_2[s1 >>> 8 & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];

                  // Update state
                  s0 = t0;
                  s1 = t1;
                  s2 = t2;
                  s3 = t3;
                }

                // Shift rows, sub bytes, add round key
                var t0 = (SBOX[s0 >>> 24] << 24 | SBOX[s1 >>> 16 & 0xff] << 16 | SBOX[s2 >>> 8 & 0xff] << 8 | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];
                var t1 = (SBOX[s1 >>> 24] << 24 | SBOX[s2 >>> 16 & 0xff] << 16 | SBOX[s3 >>> 8 & 0xff] << 8 | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];
                var t2 = (SBOX[s2 >>> 24] << 24 | SBOX[s3 >>> 16 & 0xff] << 16 | SBOX[s0 >>> 8 & 0xff] << 8 | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];
                var t3 = (SBOX[s3 >>> 24] << 24 | SBOX[s0 >>> 16 & 0xff] << 16 | SBOX[s1 >>> 8 & 0xff] << 8 | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];

                // Set output
                M[offset] = t0;
                M[offset + 1] = t1;
                M[offset + 2] = t2;
                M[offset + 3] = t3;
              },
              keySize: 256 / 32
            });

            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);
             */
            C.AES = BlockCipher._createHelper(AES);
          })();
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var WordArray = C_lib.WordArray;
            var BlockCipher = C_lib.BlockCipher;
            var C_algo = C.algo;

            // Permuted Choice 1 constants
            var PC1 = [57, 49, 41, 33, 25, 17, 9, 1, 58, 50, 42, 34, 26, 18, 10, 2, 59, 51, 43, 35, 27, 19, 11, 3, 60, 52, 44, 36, 63, 55, 47, 39, 31, 23, 15, 7, 62, 54, 46, 38, 30, 22, 14, 6, 61, 53, 45, 37, 29, 21, 13, 5, 28, 20, 12, 4];

            // Permuted Choice 2 constants
            var PC2 = [14, 17, 11, 24, 1, 5, 3, 28, 15, 6, 21, 10, 23, 19, 12, 4, 26, 8, 16, 7, 27, 20, 13, 2, 41, 52, 31, 37, 47, 55, 30, 40, 51, 45, 33, 48, 44, 49, 39, 56, 34, 53, 46, 42, 50, 36, 29, 32];

            // Cumulative bit shift constants
            var BIT_SHIFTS = [1, 2, 4, 6, 8, 10, 12, 14, 15, 17, 19, 21, 23, 25, 27, 28];

            // SBOXes and round permutation constants
            var SBOX_P = [{
              0x0: 0x808200,
              0x10000000: 0x8000,
              0x20000000: 0x808002,
              0x30000000: 0x2,
              0x40000000: 0x200,
              0x50000000: 0x808202,
              0x60000000: 0x800202,
              0x70000000: 0x800000,
              0x80000000: 0x202,
              0x90000000: 0x800200,
              0xa0000000: 0x8200,
              0xb0000000: 0x808000,
              0xc0000000: 0x8002,
              0xd0000000: 0x800002,
              0xe0000000: 0x0,
              0xf0000000: 0x8202,
              0x8000000: 0x0,
              0x18000000: 0x808202,
              0x28000000: 0x8202,
              0x38000000: 0x8000,
              0x48000000: 0x808200,
              0x58000000: 0x200,
              0x68000000: 0x808002,
              0x78000000: 0x2,
              0x88000000: 0x800200,
              0x98000000: 0x8200,
              0xa8000000: 0x808000,
              0xb8000000: 0x800202,
              0xc8000000: 0x800002,
              0xd8000000: 0x8002,
              0xe8000000: 0x202,
              0xf8000000: 0x800000,
              0x1: 0x8000,
              0x10000001: 0x2,
              0x20000001: 0x808200,
              0x30000001: 0x800000,
              0x40000001: 0x808002,
              0x50000001: 0x8200,
              0x60000001: 0x200,
              0x70000001: 0x800202,
              0x80000001: 0x808202,
              0x90000001: 0x808000,
              0xa0000001: 0x800002,
              0xb0000001: 0x8202,
              0xc0000001: 0x202,
              0xd0000001: 0x800200,
              0xe0000001: 0x8002,
              0xf0000001: 0x0,
              0x8000001: 0x808202,
              0x18000001: 0x808000,
              0x28000001: 0x800000,
              0x38000001: 0x200,
              0x48000001: 0x8000,
              0x58000001: 0x800002,
              0x68000001: 0x2,
              0x78000001: 0x8202,
              0x88000001: 0x8002,
              0x98000001: 0x800202,
              0xa8000001: 0x202,
              0xb8000001: 0x808200,
              0xc8000001: 0x800200,
              0xd8000001: 0x0,
              0xe8000001: 0x8200,
              0xf8000001: 0x808002
            }, {
              0x0: 0x40084010,
              0x1000000: 0x4000,
              0x2000000: 0x80000,
              0x3000000: 0x40080010,
              0x4000000: 0x40000010,
              0x5000000: 0x40084000,
              0x6000000: 0x40004000,
              0x7000000: 0x10,
              0x8000000: 0x84000,
              0x9000000: 0x40004010,
              0xa000000: 0x40000000,
              0xb000000: 0x84010,
              0xc000000: 0x80010,
              0xd000000: 0x0,
              0xe000000: 0x4010,
              0xf000000: 0x40080000,
              0x800000: 0x40004000,
              0x1800000: 0x84010,
              0x2800000: 0x10,
              0x3800000: 0x40004010,
              0x4800000: 0x40084010,
              0x5800000: 0x40000000,
              0x6800000: 0x80000,
              0x7800000: 0x40080010,
              0x8800000: 0x80010,
              0x9800000: 0x0,
              0xa800000: 0x4000,
              0xb800000: 0x40080000,
              0xc800000: 0x40000010,
              0xd800000: 0x84000,
              0xe800000: 0x40084000,
              0xf800000: 0x4010,
              0x10000000: 0x0,
              0x11000000: 0x40080010,
              0x12000000: 0x40004010,
              0x13000000: 0x40084000,
              0x14000000: 0x40080000,
              0x15000000: 0x10,
              0x16000000: 0x84010,
              0x17000000: 0x4000,
              0x18000000: 0x4010,
              0x19000000: 0x80000,
              0x1a000000: 0x80010,
              0x1b000000: 0x40000010,
              0x1c000000: 0x84000,
              0x1d000000: 0x40004000,
              0x1e000000: 0x40000000,
              0x1f000000: 0x40084010,
              0x10800000: 0x84010,
              0x11800000: 0x80000,
              0x12800000: 0x40080000,
              0x13800000: 0x4000,
              0x14800000: 0x40004000,
              0x15800000: 0x40084010,
              0x16800000: 0x10,
              0x17800000: 0x40000000,
              0x18800000: 0x40084000,
              0x19800000: 0x40000010,
              0x1a800000: 0x40004010,
              0x1b800000: 0x80010,
              0x1c800000: 0x0,
              0x1d800000: 0x4010,
              0x1e800000: 0x40080010,
              0x1f800000: 0x84000
            }, {
              0x0: 0x104,
              0x100000: 0x0,
              0x200000: 0x4000100,
              0x300000: 0x10104,
              0x400000: 0x10004,
              0x500000: 0x4000004,
              0x600000: 0x4010104,
              0x700000: 0x4010000,
              0x800000: 0x4000000,
              0x900000: 0x4010100,
              0xa00000: 0x10100,
              0xb00000: 0x4010004,
              0xc00000: 0x4000104,
              0xd00000: 0x10000,
              0xe00000: 0x4,
              0xf00000: 0x100,
              0x80000: 0x4010100,
              0x180000: 0x4010004,
              0x280000: 0x0,
              0x380000: 0x4000100,
              0x480000: 0x4000004,
              0x580000: 0x10000,
              0x680000: 0x10004,
              0x780000: 0x104,
              0x880000: 0x4,
              0x980000: 0x100,
              0xa80000: 0x4010000,
              0xb80000: 0x10104,
              0xc80000: 0x10100,
              0xd80000: 0x4000104,
              0xe80000: 0x4010104,
              0xf80000: 0x4000000,
              0x1000000: 0x4010100,
              0x1100000: 0x10004,
              0x1200000: 0x10000,
              0x1300000: 0x4000100,
              0x1400000: 0x100,
              0x1500000: 0x4010104,
              0x1600000: 0x4000004,
              0x1700000: 0x0,
              0x1800000: 0x4000104,
              0x1900000: 0x4000000,
              0x1a00000: 0x4,
              0x1b00000: 0x10100,
              0x1c00000: 0x4010000,
              0x1d00000: 0x104,
              0x1e00000: 0x10104,
              0x1f00000: 0x4010004,
              0x1080000: 0x4000000,
              0x1180000: 0x104,
              0x1280000: 0x4010100,
              0x1380000: 0x0,
              0x1480000: 0x10004,
              0x1580000: 0x4000100,
              0x1680000: 0x100,
              0x1780000: 0x4010004,
              0x1880000: 0x10000,
              0x1980000: 0x4010104,
              0x1a80000: 0x10104,
              0x1b80000: 0x4000004,
              0x1c80000: 0x4000104,
              0x1d80000: 0x4010000,
              0x1e80000: 0x4,
              0x1f80000: 0x10100
            }, {
              0x0: 0x80401000,
              0x10000: 0x80001040,
              0x20000: 0x401040,
              0x30000: 0x80400000,
              0x40000: 0x0,
              0x50000: 0x401000,
              0x60000: 0x80000040,
              0x70000: 0x400040,
              0x80000: 0x80000000,
              0x90000: 0x400000,
              0xa0000: 0x40,
              0xb0000: 0x80001000,
              0xc0000: 0x80400040,
              0xd0000: 0x1040,
              0xe0000: 0x1000,
              0xf0000: 0x80401040,
              0x8000: 0x80001040,
              0x18000: 0x40,
              0x28000: 0x80400040,
              0x38000: 0x80001000,
              0x48000: 0x401000,
              0x58000: 0x80401040,
              0x68000: 0x0,
              0x78000: 0x80400000,
              0x88000: 0x1000,
              0x98000: 0x80401000,
              0xa8000: 0x400000,
              0xb8000: 0x1040,
              0xc8000: 0x80000000,
              0xd8000: 0x400040,
              0xe8000: 0x401040,
              0xf8000: 0x80000040,
              0x100000: 0x400040,
              0x110000: 0x401000,
              0x120000: 0x80000040,
              0x130000: 0x0,
              0x140000: 0x1040,
              0x150000: 0x80400040,
              0x160000: 0x80401000,
              0x170000: 0x80001040,
              0x180000: 0x80401040,
              0x190000: 0x80000000,
              0x1a0000: 0x80400000,
              0x1b0000: 0x401040,
              0x1c0000: 0x80001000,
              0x1d0000: 0x400000,
              0x1e0000: 0x40,
              0x1f0000: 0x1000,
              0x108000: 0x80400000,
              0x118000: 0x80401040,
              0x128000: 0x0,
              0x138000: 0x401000,
              0x148000: 0x400040,
              0x158000: 0x80000000,
              0x168000: 0x80001040,
              0x178000: 0x40,
              0x188000: 0x80000040,
              0x198000: 0x1000,
              0x1a8000: 0x80001000,
              0x1b8000: 0x80400040,
              0x1c8000: 0x1040,
              0x1d8000: 0x80401000,
              0x1e8000: 0x400000,
              0x1f8000: 0x401040
            }, {
              0x0: 0x80,
              0x1000: 0x1040000,
              0x2000: 0x40000,
              0x3000: 0x20000000,
              0x4000: 0x20040080,
              0x5000: 0x1000080,
              0x6000: 0x21000080,
              0x7000: 0x40080,
              0x8000: 0x1000000,
              0x9000: 0x20040000,
              0xa000: 0x20000080,
              0xb000: 0x21040080,
              0xc000: 0x21040000,
              0xd000: 0x0,
              0xe000: 0x1040080,
              0xf000: 0x21000000,
              0x800: 0x1040080,
              0x1800: 0x21000080,
              0x2800: 0x80,
              0x3800: 0x1040000,
              0x4800: 0x40000,
              0x5800: 0x20040080,
              0x6800: 0x21040000,
              0x7800: 0x20000000,
              0x8800: 0x20040000,
              0x9800: 0x0,
              0xa800: 0x21040080,
              0xb800: 0x1000080,
              0xc800: 0x20000080,
              0xd800: 0x21000000,
              0xe800: 0x1000000,
              0xf800: 0x40080,
              0x10000: 0x40000,
              0x11000: 0x80,
              0x12000: 0x20000000,
              0x13000: 0x21000080,
              0x14000: 0x1000080,
              0x15000: 0x21040000,
              0x16000: 0x20040080,
              0x17000: 0x1000000,
              0x18000: 0x21040080,
              0x19000: 0x21000000,
              0x1a000: 0x1040000,
              0x1b000: 0x20040000,
              0x1c000: 0x40080,
              0x1d000: 0x20000080,
              0x1e000: 0x0,
              0x1f000: 0x1040080,
              0x10800: 0x21000080,
              0x11800: 0x1000000,
              0x12800: 0x1040000,
              0x13800: 0x20040080,
              0x14800: 0x20000000,
              0x15800: 0x1040080,
              0x16800: 0x80,
              0x17800: 0x21040000,
              0x18800: 0x40080,
              0x19800: 0x21040080,
              0x1a800: 0x0,
              0x1b800: 0x21000000,
              0x1c800: 0x1000080,
              0x1d800: 0x40000,
              0x1e800: 0x20040000,
              0x1f800: 0x20000080
            }, {
              0x0: 0x10000008,
              0x100: 0x2000,
              0x200: 0x10200000,
              0x300: 0x10202008,
              0x400: 0x10002000,
              0x500: 0x200000,
              0x600: 0x200008,
              0x700: 0x10000000,
              0x800: 0x0,
              0x900: 0x10002008,
              0xa00: 0x202000,
              0xb00: 0x8,
              0xc00: 0x10200008,
              0xd00: 0x202008,
              0xe00: 0x2008,
              0xf00: 0x10202000,
              0x80: 0x10200000,
              0x180: 0x10202008,
              0x280: 0x8,
              0x380: 0x200000,
              0x480: 0x202008,
              0x580: 0x10000008,
              0x680: 0x10002000,
              0x780: 0x2008,
              0x880: 0x200008,
              0x980: 0x2000,
              0xa80: 0x10002008,
              0xb80: 0x10200008,
              0xc80: 0x0,
              0xd80: 0x10202000,
              0xe80: 0x202000,
              0xf80: 0x10000000,
              0x1000: 0x10002000,
              0x1100: 0x10200008,
              0x1200: 0x10202008,
              0x1300: 0x2008,
              0x1400: 0x200000,
              0x1500: 0x10000000,
              0x1600: 0x10000008,
              0x1700: 0x202000,
              0x1800: 0x202008,
              0x1900: 0x0,
              0x1a00: 0x8,
              0x1b00: 0x10200000,
              0x1c00: 0x2000,
              0x1d00: 0x10002008,
              0x1e00: 0x10202000,
              0x1f00: 0x200008,
              0x1080: 0x8,
              0x1180: 0x202000,
              0x1280: 0x200000,
              0x1380: 0x10000008,
              0x1480: 0x10002000,
              0x1580: 0x2008,
              0x1680: 0x10202008,
              0x1780: 0x10200000,
              0x1880: 0x10202000,
              0x1980: 0x10200008,
              0x1a80: 0x2000,
              0x1b80: 0x202008,
              0x1c80: 0x200008,
              0x1d80: 0x0,
              0x1e80: 0x10000000,
              0x1f80: 0x10002008
            }, {
              0x0: 0x100000,
              0x10: 0x2000401,
              0x20: 0x400,
              0x30: 0x100401,
              0x40: 0x2100401,
              0x50: 0x0,
              0x60: 0x1,
              0x70: 0x2100001,
              0x80: 0x2000400,
              0x90: 0x100001,
              0xa0: 0x2000001,
              0xb0: 0x2100400,
              0xc0: 0x2100000,
              0xd0: 0x401,
              0xe0: 0x100400,
              0xf0: 0x2000000,
              0x8: 0x2100001,
              0x18: 0x0,
              0x28: 0x2000401,
              0x38: 0x2100400,
              0x48: 0x100000,
              0x58: 0x2000001,
              0x68: 0x2000000,
              0x78: 0x401,
              0x88: 0x100401,
              0x98: 0x2000400,
              0xa8: 0x2100000,
              0xb8: 0x100001,
              0xc8: 0x400,
              0xd8: 0x2100401,
              0xe8: 0x1,
              0xf8: 0x100400,
              0x100: 0x2000000,
              0x110: 0x100000,
              0x120: 0x2000401,
              0x130: 0x2100001,
              0x140: 0x100001,
              0x150: 0x2000400,
              0x160: 0x2100400,
              0x170: 0x100401,
              0x180: 0x401,
              0x190: 0x2100401,
              0x1a0: 0x100400,
              0x1b0: 0x1,
              0x1c0: 0x0,
              0x1d0: 0x2100000,
              0x1e0: 0x2000001,
              0x1f0: 0x400,
              0x108: 0x100400,
              0x118: 0x2000401,
              0x128: 0x2100001,
              0x138: 0x1,
              0x148: 0x2000000,
              0x158: 0x100000,
              0x168: 0x401,
              0x178: 0x2100400,
              0x188: 0x2000001,
              0x198: 0x2100000,
              0x1a8: 0x0,
              0x1b8: 0x2100401,
              0x1c8: 0x100401,
              0x1d8: 0x400,
              0x1e8: 0x2000400,
              0x1f8: 0x100001
            }, {
              0x0: 0x8000820,
              0x1: 0x20000,
              0x2: 0x8000000,
              0x3: 0x20,
              0x4: 0x20020,
              0x5: 0x8020820,
              0x6: 0x8020800,
              0x7: 0x800,
              0x8: 0x8020000,
              0x9: 0x8000800,
              0xa: 0x20800,
              0xb: 0x8020020,
              0xc: 0x820,
              0xd: 0x0,
              0xe: 0x8000020,
              0xf: 0x20820,
              0x80000000: 0x800,
              0x80000001: 0x8020820,
              0x80000002: 0x8000820,
              0x80000003: 0x8000000,
              0x80000004: 0x8020000,
              0x80000005: 0x20800,
              0x80000006: 0x20820,
              0x80000007: 0x20,
              0x80000008: 0x8000020,
              0x80000009: 0x820,
              0x8000000a: 0x20020,
              0x8000000b: 0x8020800,
              0x8000000c: 0x0,
              0x8000000d: 0x8020020,
              0x8000000e: 0x8000800,
              0x8000000f: 0x20000,
              0x10: 0x20820,
              0x11: 0x8020800,
              0x12: 0x20,
              0x13: 0x800,
              0x14: 0x8000800,
              0x15: 0x8000020,
              0x16: 0x8020020,
              0x17: 0x20000,
              0x18: 0x0,
              0x19: 0x20020,
              0x1a: 0x8020000,
              0x1b: 0x8000820,
              0x1c: 0x8020820,
              0x1d: 0x20800,
              0x1e: 0x820,
              0x1f: 0x8000000,
              0x80000010: 0x20000,
              0x80000011: 0x800,
              0x80000012: 0x8020020,
              0x80000013: 0x20820,
              0x80000014: 0x20,
              0x80000015: 0x8020000,
              0x80000016: 0x8000000,
              0x80000017: 0x8000820,
              0x80000018: 0x8020820,
              0x80000019: 0x8000020,
              0x8000001a: 0x8000800,
              0x8000001b: 0x0,
              0x8000001c: 0x20800,
              0x8000001d: 0x820,
              0x8000001e: 0x20020,
              0x8000001f: 0x8020800
            }];

            // Masks that select the SBOX input
            var SBOX_MASK = [0xf8000001, 0x1f800000, 0x01f80000, 0x001f8000, 0x0001f800, 0x00001f80, 0x000001f8, 0x8000001f];

            /**
             * DES block cipher algorithm.
             */
            var DES = C_algo.DES = BlockCipher.extend({
              _doReset: function () {
                // Shortcuts
                var key = this._key;
                var keyWords = key.words;

                // Select 56 bits according to PC1
                var keyBits = [];
                for (var i = 0; i < 56; i++) {
                  var keyBitPos = PC1[i] - 1;
                  keyBits[i] = keyWords[keyBitPos >>> 5] >>> 31 - keyBitPos % 32 & 1;
                }

                // Assemble 16 subkeys
                var subKeys = this._subKeys = [];
                for (var nSubKey = 0; nSubKey < 16; nSubKey++) {
                  // Create subkey
                  var subKey = subKeys[nSubKey] = [];

                  // Shortcut
                  var bitShift = BIT_SHIFTS[nSubKey];

                  // Select 48 bits according to PC2
                  for (var i = 0; i < 24; i++) {
                    // Select from the left 28 key bits
                    subKey[i / 6 | 0] |= keyBits[(PC2[i] - 1 + bitShift) % 28] << 31 - i % 6;

                    // Select from the right 28 key bits
                    subKey[4 + (i / 6 | 0)] |= keyBits[28 + (PC2[i + 24] - 1 + bitShift) % 28] << 31 - i % 6;
                  }

                  // Since each subkey is applied to an expanded 32-bit input,
                  // the subkey can be broken into 8 values scaled to 32-bits,
                  // which allows the key to be used without expansion
                  subKey[0] = subKey[0] << 1 | subKey[0] >>> 31;
                  for (var i = 1; i < 7; i++) {
                    subKey[i] = subKey[i] >>> (i - 1) * 4 + 3;
                  }
                  subKey[7] = subKey[7] << 5 | subKey[7] >>> 27;
                }

                // Compute inverse subkeys
                var invSubKeys = this._invSubKeys = [];
                for (var i = 0; i < 16; i++) {
                  invSubKeys[i] = subKeys[15 - i];
                }
              },
              encryptBlock: function (M, offset) {
                this._doCryptBlock(M, offset, this._subKeys);
              },
              decryptBlock: function (M, offset) {
                this._doCryptBlock(M, offset, this._invSubKeys);
              },
              _doCryptBlock: function (M, offset, subKeys) {
                // Get input
                this._lBlock = M[offset];
                this._rBlock = M[offset + 1];

                // Initial permutation
                exchangeLR.call(this, 4, 0x0f0f0f0f);
                exchangeLR.call(this, 16, 0x0000ffff);
                exchangeRL.call(this, 2, 0x33333333);
                exchangeRL.call(this, 8, 0x00ff00ff);
                exchangeLR.call(this, 1, 0x55555555);

                // Rounds
                for (var round = 0; round < 16; round++) {
                  // Shortcuts
                  var subKey = subKeys[round];
                  var lBlock = this._lBlock;
                  var rBlock = this._rBlock;

                  // Feistel function
                  var f = 0;
                  for (var i = 0; i < 8; i++) {
                    f |= SBOX_P[i][((rBlock ^ subKey[i]) & SBOX_MASK[i]) >>> 0];
                  }
                  this._lBlock = rBlock;
                  this._rBlock = lBlock ^ f;
                }

                // Undo swap from last round
                var t = this._lBlock;
                this._lBlock = this._rBlock;
                this._rBlock = t;

                // Final permutation
                exchangeLR.call(this, 1, 0x55555555);
                exchangeRL.call(this, 8, 0x00ff00ff);
                exchangeRL.call(this, 2, 0x33333333);
                exchangeLR.call(this, 16, 0x0000ffff);
                exchangeLR.call(this, 4, 0x0f0f0f0f);

                // Set output
                M[offset] = this._lBlock;
                M[offset + 1] = this._rBlock;
              },
              keySize: 64 / 32,
              ivSize: 64 / 32,
              blockSize: 64 / 32
            });

            // Swap bits across the left and right words
            function exchangeLR(offset, mask) {
              var t = (this._lBlock >>> offset ^ this._rBlock) & mask;
              this._rBlock ^= t;
              this._lBlock ^= t << offset;
            }
            function exchangeRL(offset, mask) {
              var t = (this._rBlock >>> offset ^ this._lBlock) & mask;
              this._lBlock ^= t;
              this._rBlock ^= t << offset;
            }

            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.DES.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.DES.decrypt(ciphertext, key, cfg);
             */
            C.DES = BlockCipher._createHelper(DES);

            /**
             * Triple-DES block cipher algorithm.
             */
            var TripleDES = C_algo.TripleDES = BlockCipher.extend({
              _doReset: function () {
                // Shortcuts
                var key = this._key;
                var keyWords = key.words;

                // Create DES instances
                this._des1 = DES.createEncryptor(WordArray.create(keyWords.slice(0, 2)));
                this._des2 = DES.createEncryptor(WordArray.create(keyWords.slice(2, 4)));
                this._des3 = DES.createEncryptor(WordArray.create(keyWords.slice(4, 6)));
              },
              encryptBlock: function (M, offset) {
                this._des1.encryptBlock(M, offset);
                this._des2.decryptBlock(M, offset);
                this._des3.encryptBlock(M, offset);
              },
              decryptBlock: function (M, offset) {
                this._des3.decryptBlock(M, offset);
                this._des2.encryptBlock(M, offset);
                this._des1.decryptBlock(M, offset);
              },
              keySize: 192 / 32,
              ivSize: 64 / 32,
              blockSize: 64 / 32
            });

            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.TripleDES.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.TripleDES.decrypt(ciphertext, key, cfg);
             */
            C.TripleDES = BlockCipher._createHelper(TripleDES);
          })();
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var StreamCipher = C_lib.StreamCipher;
            var C_algo = C.algo;

            /**
             * RC4 stream cipher algorithm.
             */
            var RC4 = C_algo.RC4 = StreamCipher.extend({
              _doReset: function () {
                // Shortcuts
                var key = this._key;
                var keyWords = key.words;
                var keySigBytes = key.sigBytes;

                // Init sbox
                var S = this._S = [];
                for (var i = 0; i < 256; i++) {
                  S[i] = i;
                }

                // Key setup
                for (var i = 0, j = 0; i < 256; i++) {
                  var keyByteIndex = i % keySigBytes;
                  var keyByte = keyWords[keyByteIndex >>> 2] >>> 24 - keyByteIndex % 4 * 8 & 0xff;
                  j = (j + S[i] + keyByte) % 256;

                  // Swap
                  var t = S[i];
                  S[i] = S[j];
                  S[j] = t;
                }

                // Counters
                this._i = this._j = 0;
              },
              _doProcessBlock: function (M, offset) {
                M[offset] ^= generateKeystreamWord.call(this);
              },
              keySize: 256 / 32,
              ivSize: 0
            });
            function generateKeystreamWord() {
              // Shortcuts
              var S = this._S;
              var i = this._i;
              var j = this._j;

              // Generate keystream word
              var keystreamWord = 0;
              for (var n = 0; n < 4; n++) {
                i = (i + 1) % 256;
                j = (j + S[i]) % 256;

                // Swap
                var t = S[i];
                S[i] = S[j];
                S[j] = t;
                keystreamWord |= S[(S[i] + S[j]) % 256] << 24 - n * 8;
              }

              // Update counters
              this._i = i;
              this._j = j;
              return keystreamWord;
            }

            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.RC4.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.RC4.decrypt(ciphertext, key, cfg);
             */
            C.RC4 = StreamCipher._createHelper(RC4);

            /**
             * Modified RC4 stream cipher algorithm.
             */
            var RC4Drop = C_algo.RC4Drop = RC4.extend({
              /**
               * Configuration options.
               *
               * @property {number} drop The number of keystream words to drop. Default 192
               */
              cfg: RC4.cfg.extend({
                drop: 192
              }),
              _doReset: function () {
                RC4._doReset.call(this);

                // Drop
                for (var i = this.cfg.drop; i > 0; i--) {
                  generateKeystreamWord.call(this);
                }
              }
            });

            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.RC4Drop.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.RC4Drop.decrypt(ciphertext, key, cfg);
             */
            C.RC4Drop = StreamCipher._createHelper(RC4Drop);
          })();

          /** @preserve
           * Counter block mode compatible with  Dr Brian Gladman fileenc.c
           * derived from CryptoJS.mode.CTR
           * Jan Hruby jhruby.web@gmail.com
           */
          CryptoJS.mode.CTRGladman = function () {
            var CTRGladman = CryptoJS.lib.BlockCipherMode.extend();
            function incWord(word) {
              if ((word >> 24 & 0xff) === 0xff) {
                //overflow
                var b1 = word >> 16 & 0xff;
                var b2 = word >> 8 & 0xff;
                var b3 = word & 0xff;
                if (b1 === 0xff)
                  // overflow b1
                  {
                    b1 = 0;
                    if (b2 === 0xff) {
                      b2 = 0;
                      if (b3 === 0xff) {
                        b3 = 0;
                      } else {
                        ++b3;
                      }
                    } else {
                      ++b2;
                    }
                  } else {
                  ++b1;
                }
                word = 0;
                word += b1 << 16;
                word += b2 << 8;
                word += b3;
              } else {
                word += 0x01 << 24;
              }
              return word;
            }
            function incCounter(counter) {
              if ((counter[0] = incWord(counter[0])) === 0) {
                // encr_data in fileenc.c from  Dr Brian Gladman's counts only with DWORD j < 8
                counter[1] = incWord(counter[1]);
              }
              return counter;
            }
            var Encryptor = CTRGladman.Encryptor = CTRGladman.extend({
              processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                var iv = this._iv;
                var counter = this._counter;

                // Generate keystream
                if (iv) {
                  counter = this._counter = iv.slice(0);

                  // Remove IV for subsequent blocks
                  this._iv = undefined;
                }
                incCounter(counter);
                var keystream = counter.slice(0);
                cipher.encryptBlock(keystream, 0);

                // Encrypt
                for (var i = 0; i < blockSize; i++) {
                  words[offset + i] ^= keystream[i];
                }
              }
            });
            CTRGladman.Decryptor = Encryptor;
            return CTRGladman;
          }();
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var StreamCipher = C_lib.StreamCipher;
            var C_algo = C.algo;

            // Reusable objects
            var S = [];
            var C_ = [];
            var G = [];

            /**
             * Rabbit stream cipher algorithm
             */
            var Rabbit = C_algo.Rabbit = StreamCipher.extend({
              _doReset: function () {
                // Shortcuts
                var K = this._key.words;
                var iv = this.cfg.iv;

                // Swap endian
                for (var i = 0; i < 4; i++) {
                  K[i] = (K[i] << 8 | K[i] >>> 24) & 0x00ff00ff | (K[i] << 24 | K[i] >>> 8) & 0xff00ff00;
                }

                // Generate initial state values
                var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16];

                // Generate initial counter values
                var C = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 0xffff0000 | K[1] & 0x0000ffff, K[3] << 16 | K[3] >>> 16, K[1] & 0xffff0000 | K[2] & 0x0000ffff, K[0] << 16 | K[0] >>> 16, K[2] & 0xffff0000 | K[3] & 0x0000ffff, K[1] << 16 | K[1] >>> 16, K[3] & 0xffff0000 | K[0] & 0x0000ffff];

                // Carry bit
                this._b = 0;

                // Iterate the system four times
                for (var i = 0; i < 4; i++) {
                  nextState.call(this);
                }

                // Modify the counters
                for (var i = 0; i < 8; i++) {
                  C[i] ^= X[i + 4 & 7];
                }

                // IV setup
                if (iv) {
                  // Shortcuts
                  var IV = iv.words;
                  var IV_0 = IV[0];
                  var IV_1 = IV[1];

                  // Generate four subvectors
                  var i0 = (IV_0 << 8 | IV_0 >>> 24) & 0x00ff00ff | (IV_0 << 24 | IV_0 >>> 8) & 0xff00ff00;
                  var i2 = (IV_1 << 8 | IV_1 >>> 24) & 0x00ff00ff | (IV_1 << 24 | IV_1 >>> 8) & 0xff00ff00;
                  var i1 = i0 >>> 16 | i2 & 0xffff0000;
                  var i3 = i2 << 16 | i0 & 0x0000ffff;

                  // Modify counter values
                  C[0] ^= i0;
                  C[1] ^= i1;
                  C[2] ^= i2;
                  C[3] ^= i3;
                  C[4] ^= i0;
                  C[5] ^= i1;
                  C[6] ^= i2;
                  C[7] ^= i3;

                  // Iterate the system four times
                  for (var i = 0; i < 4; i++) {
                    nextState.call(this);
                  }
                }
              },
              _doProcessBlock: function (M, offset) {
                // Shortcut
                var X = this._X;

                // Iterate the system
                nextState.call(this);

                // Generate four keystream words
                S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
                S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
                S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
                S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
                for (var i = 0; i < 4; i++) {
                  // Swap endian
                  S[i] = (S[i] << 8 | S[i] >>> 24) & 0x00ff00ff | (S[i] << 24 | S[i] >>> 8) & 0xff00ff00;

                  // Encrypt
                  M[offset + i] ^= S[i];
                }
              },
              blockSize: 128 / 32,
              ivSize: 64 / 32
            });
            function nextState() {
              // Shortcuts
              var X = this._X;
              var C = this._C;

              // Save old counter values
              for (var i = 0; i < 8; i++) {
                C_[i] = C[i];
              }

              // Calculate new counter values
              C[0] = C[0] + 0x4d34d34d + this._b | 0;
              C[1] = C[1] + 0xd34d34d3 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
              C[2] = C[2] + 0x34d34d34 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
              C[3] = C[3] + 0x4d34d34d + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
              C[4] = C[4] + 0xd34d34d3 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
              C[5] = C[5] + 0x34d34d34 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
              C[6] = C[6] + 0x4d34d34d + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
              C[7] = C[7] + 0xd34d34d3 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
              this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;

              // Calculate the g-values
              for (var i = 0; i < 8; i++) {
                var gx = X[i] + C[i];

                // Construct high and low argument for squaring
                var ga = gx & 0xffff;
                var gb = gx >>> 16;

                // Calculate high and low result of squaring
                var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                var gl = ((gx & 0xffff0000) * gx | 0) + ((gx & 0x0000ffff) * gx | 0);

                // High XOR low
                G[i] = gh ^ gl;
              }

              // Calculate new state values
              X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
              X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
              X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
              X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
              X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
              X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
              X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
              X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
            }

            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.Rabbit.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.Rabbit.decrypt(ciphertext, key, cfg);
             */
            C.Rabbit = StreamCipher._createHelper(Rabbit);
          })();

          /**
           * Counter block mode.
           */
          CryptoJS.mode.CTR = function () {
            var CTR = CryptoJS.lib.BlockCipherMode.extend();
            var Encryptor = CTR.Encryptor = CTR.extend({
              processBlock: function (words, offset) {
                // Shortcuts
                var cipher = this._cipher;
                var blockSize = cipher.blockSize;
                var iv = this._iv;
                var counter = this._counter;

                // Generate keystream
                if (iv) {
                  counter = this._counter = iv.slice(0);

                  // Remove IV for subsequent blocks
                  this._iv = undefined;
                }
                var keystream = counter.slice(0);
                cipher.encryptBlock(keystream, 0);

                // Increment counter
                counter[blockSize - 1] = counter[blockSize - 1] + 1 | 0;

                // Encrypt
                for (var i = 0; i < blockSize; i++) {
                  words[offset + i] ^= keystream[i];
                }
              }
            });
            CTR.Decryptor = Encryptor;
            return CTR;
          }();
          (function () {
            // Shortcuts
            var C = CryptoJS;
            var C_lib = C.lib;
            var StreamCipher = C_lib.StreamCipher;
            var C_algo = C.algo;

            // Reusable objects
            var S = [];
            var C_ = [];
            var G = [];

            /**
             * Rabbit stream cipher algorithm.
             *
             * This is a legacy version that neglected to convert the key to little-endian.
             * This error doesn't affect the cipher's security,
             * but it does affect its compatibility with other implementations.
             */
            var RabbitLegacy = C_algo.RabbitLegacy = StreamCipher.extend({
              _doReset: function () {
                // Shortcuts
                var K = this._key.words;
                var iv = this.cfg.iv;

                // Generate initial state values
                var X = this._X = [K[0], K[3] << 16 | K[2] >>> 16, K[1], K[0] << 16 | K[3] >>> 16, K[2], K[1] << 16 | K[0] >>> 16, K[3], K[2] << 16 | K[1] >>> 16];

                // Generate initial counter values
                var C = this._C = [K[2] << 16 | K[2] >>> 16, K[0] & 0xffff0000 | K[1] & 0x0000ffff, K[3] << 16 | K[3] >>> 16, K[1] & 0xffff0000 | K[2] & 0x0000ffff, K[0] << 16 | K[0] >>> 16, K[2] & 0xffff0000 | K[3] & 0x0000ffff, K[1] << 16 | K[1] >>> 16, K[3] & 0xffff0000 | K[0] & 0x0000ffff];

                // Carry bit
                this._b = 0;

                // Iterate the system four times
                for (var i = 0; i < 4; i++) {
                  nextState.call(this);
                }

                // Modify the counters
                for (var i = 0; i < 8; i++) {
                  C[i] ^= X[i + 4 & 7];
                }

                // IV setup
                if (iv) {
                  // Shortcuts
                  var IV = iv.words;
                  var IV_0 = IV[0];
                  var IV_1 = IV[1];

                  // Generate four subvectors
                  var i0 = (IV_0 << 8 | IV_0 >>> 24) & 0x00ff00ff | (IV_0 << 24 | IV_0 >>> 8) & 0xff00ff00;
                  var i2 = (IV_1 << 8 | IV_1 >>> 24) & 0x00ff00ff | (IV_1 << 24 | IV_1 >>> 8) & 0xff00ff00;
                  var i1 = i0 >>> 16 | i2 & 0xffff0000;
                  var i3 = i2 << 16 | i0 & 0x0000ffff;

                  // Modify counter values
                  C[0] ^= i0;
                  C[1] ^= i1;
                  C[2] ^= i2;
                  C[3] ^= i3;
                  C[4] ^= i0;
                  C[5] ^= i1;
                  C[6] ^= i2;
                  C[7] ^= i3;

                  // Iterate the system four times
                  for (var i = 0; i < 4; i++) {
                    nextState.call(this);
                  }
                }
              },
              _doProcessBlock: function (M, offset) {
                // Shortcut
                var X = this._X;

                // Iterate the system
                nextState.call(this);

                // Generate four keystream words
                S[0] = X[0] ^ X[5] >>> 16 ^ X[3] << 16;
                S[1] = X[2] ^ X[7] >>> 16 ^ X[5] << 16;
                S[2] = X[4] ^ X[1] >>> 16 ^ X[7] << 16;
                S[3] = X[6] ^ X[3] >>> 16 ^ X[1] << 16;
                for (var i = 0; i < 4; i++) {
                  // Swap endian
                  S[i] = (S[i] << 8 | S[i] >>> 24) & 0x00ff00ff | (S[i] << 24 | S[i] >>> 8) & 0xff00ff00;

                  // Encrypt
                  M[offset + i] ^= S[i];
                }
              },
              blockSize: 128 / 32,
              ivSize: 64 / 32
            });
            function nextState() {
              // Shortcuts
              var X = this._X;
              var C = this._C;

              // Save old counter values
              for (var i = 0; i < 8; i++) {
                C_[i] = C[i];
              }

              // Calculate new counter values
              C[0] = C[0] + 0x4d34d34d + this._b | 0;
              C[1] = C[1] + 0xd34d34d3 + (C[0] >>> 0 < C_[0] >>> 0 ? 1 : 0) | 0;
              C[2] = C[2] + 0x34d34d34 + (C[1] >>> 0 < C_[1] >>> 0 ? 1 : 0) | 0;
              C[3] = C[3] + 0x4d34d34d + (C[2] >>> 0 < C_[2] >>> 0 ? 1 : 0) | 0;
              C[4] = C[4] + 0xd34d34d3 + (C[3] >>> 0 < C_[3] >>> 0 ? 1 : 0) | 0;
              C[5] = C[5] + 0x34d34d34 + (C[4] >>> 0 < C_[4] >>> 0 ? 1 : 0) | 0;
              C[6] = C[6] + 0x4d34d34d + (C[5] >>> 0 < C_[5] >>> 0 ? 1 : 0) | 0;
              C[7] = C[7] + 0xd34d34d3 + (C[6] >>> 0 < C_[6] >>> 0 ? 1 : 0) | 0;
              this._b = C[7] >>> 0 < C_[7] >>> 0 ? 1 : 0;

              // Calculate the g-values
              for (var i = 0; i < 8; i++) {
                var gx = X[i] + C[i];

                // Construct high and low argument for squaring
                var ga = gx & 0xffff;
                var gb = gx >>> 16;

                // Calculate high and low result of squaring
                var gh = ((ga * ga >>> 17) + ga * gb >>> 15) + gb * gb;
                var gl = ((gx & 0xffff0000) * gx | 0) + ((gx & 0x0000ffff) * gx | 0);

                // High XOR low
                G[i] = gh ^ gl;
              }

              // Calculate new state values
              X[0] = G[0] + (G[7] << 16 | G[7] >>> 16) + (G[6] << 16 | G[6] >>> 16) | 0;
              X[1] = G[1] + (G[0] << 8 | G[0] >>> 24) + G[7] | 0;
              X[2] = G[2] + (G[1] << 16 | G[1] >>> 16) + (G[0] << 16 | G[0] >>> 16) | 0;
              X[3] = G[3] + (G[2] << 8 | G[2] >>> 24) + G[1] | 0;
              X[4] = G[4] + (G[3] << 16 | G[3] >>> 16) + (G[2] << 16 | G[2] >>> 16) | 0;
              X[5] = G[5] + (G[4] << 8 | G[4] >>> 24) + G[3] | 0;
              X[6] = G[6] + (G[5] << 16 | G[5] >>> 16) + (G[4] << 16 | G[4] >>> 16) | 0;
              X[7] = G[7] + (G[6] << 8 | G[6] >>> 24) + G[5] | 0;
            }

            /**
             * Shortcut functions to the cipher's object interface.
             *
             * @example
             *
             *     var ciphertext = CryptoJS.RabbitLegacy.encrypt(message, key, cfg);
             *     var plaintext  = CryptoJS.RabbitLegacy.decrypt(ciphertext, key, cfg);
             */
            C.RabbitLegacy = StreamCipher._createHelper(RabbitLegacy);
          })();

          /**
           * Zero padding strategy.
           */
          CryptoJS.pad.ZeroPadding = {
            pad: function (data, blockSize) {
              // Shortcut
              var blockSizeBytes = blockSize * 4;

              // Pad
              data.clamp();
              data.sigBytes += blockSizeBytes - (data.sigBytes % blockSizeBytes || blockSizeBytes);
            },
            unpad: function (data) {
              // Shortcut
              var dataWords = data.words;

              // Unpad
              var i = data.sigBytes - 1;
              while (!(dataWords[i >>> 2] >>> 24 - i % 4 * 8 & 0xff)) {
                i--;
              }
              data.sigBytes = i + 1;
            }
          };
          return CryptoJS;
        });

        // #endregion ORIGINAL CODE

        _cjsExports = exports('default', module.exports);
      }, {});
    }
  };
});

System.register("chunks:///_virtual/CryptoES.mjs_cjs=&original=.js", ['./CryptoES.js', './cjs-loader.mjs'], function (exports, module) {
  var __cjsMetaURL, loader;
  return {
    setters: [function (module) {
      __cjsMetaURL = module.__cjsMetaURL;
      var _setter = {};
      _setter.__cjsMetaURL = module.__cjsMetaURL;
      _setter.default = module.default;
      exports(_setter);
    }, function (module) {
      loader = module.default;
    }],
    execute: function () {
      // I am the facade module who provides access to the CommonJS module './CryptoES.js'~
      if (!__cjsMetaURL) {
        loader.throwInvalidWrapper('./CryptoES.js', module.meta.url);
      }
      loader.require(__cjsMetaURL);
    }
  };
});

System.register("chunks:///_virtual/data-agent.ts", ['cc', './config.ts', './time-agent.ts', './request-manager.ts', './log-util.ts', './storage-manager.ts'], function (exports) {
  var cclegacy, Config, TimeAgent, ReqeustManager, LogUtil, StorageManager;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      TimeAgent = module.TimeAgent;
    }, function (module) {
      ReqeustManager = module.ReqeustManager;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      StorageManager = module.StorageManager;
    }],
    execute: function () {
      cclegacy._RF.push({}, "946e4RT9LNAiI1QTYqh/T/f", "data-agent", undefined);
      let DataType = exports('DataType', /*#__PURE__*/function (DataType) {
        DataType["Game"] = "game";
        DataType["Gain"] = "gain";
        DataType["Player"] = "player";
        DataType["SgPicInfo"] = "sgPicInfo";
        DataType["Local"] = "local";
        DataType["Sg"] = "sg";
        return DataType;
      }({}));
      class DataAgent {
        static fetchData() {
          return new Promise((resolve, reject) => {
            LogUtil.log('fetchData uid is:', StorageManager.instance.getUid());
            ReqeustManager.instance.get(`/fetch/player/${StorageManager.instance.getUid()}`).then(data => {
              const payload = data['data']['payload'];
              if (!payload) {
                LogUtil.warn('fetchData payload is null');
                resolve(null);
                return;
              }
              if (payload['now']) {
                const serverTime = payload['now'];
                if (!!serverTime && serverTime > 0) {
                  TimeAgent.instance.setServerTime(serverTime);
                }
              }

              // if (payload['game']) {
              //     const gameData = payload['game'];
              //     this.saveData(DataType.Game, gameData);
              // }

              // if (payload['gain']) {
              //     const gainData = payload['gain'];
              //     this.saveData(DataType.Gain, gainData);
              // }

              // const playerData = {
              //     sid: payload['sid'],
              //     major: payload['tokenMajor'],
              //     minor: payload['tokenMinor']
              // }

              // this.saveData(DataType.Player, playerData);

              resolve(payload);
            }).catch(error => {
              LogUtil.error('error fetchData:', error);
              // slient
              resolve(null);
            });
          });
        }
        static uploadData(type, payload) {
          return new Promise((resolve, reject) => {
            ReqeustManager.instance.post(`/update/player`, {
              code: Config.GAME_CODE,
              version: Config.GAME_VERSION,
              payload: payload
            }).then(data => {
              if (data['ret'] === 0) {
                resolve();
              } else {
                console.error('error welcome: ', data['message']);
              }
            }).catch(error => {
              console.error('error welcome:', error);
              reject(error);
            });
          });
        }
        static saveData(key, value) {
          if (!key || !value) {
            LogUtil.warn('save data: key or value is null');
            return;
          }
          StorageManager.instance.set(`data.${key}`, value);
        }
        static getData(key) {
          if (!key) {
            LogUtil.warn('get data: key is null');
            return null;
          }
          const obj = StorageManager.instance.getJson(`data.${key}`);
          if (!obj) {
            return null;
          }
          return obj;
        }
      }
      exports('DataAgent', DataAgent);
      DataAgent._saveKey = 'raw_data_from_server';
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/debug-info-view.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './game-data-manager.ts', './config.ts', './ui-manager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Label, _decorator, director, UIView, GameDataManager, Config, UIManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Label = module.Label;
      _decorator = module._decorator;
      director = module.director;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      UIManager = module.UIManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "9200bX/welOrogUrXiwsV7j", "debug-info-view", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let DebugInfoView = exports('DebugInfoView', (_dec = ccclass('DebugInfoView'), _dec2 = property(Label), _dec3 = property(Label), _dec4 = property(Label), _dec5 = property(Label), _dec(_class = (_class2 = class DebugInfoView extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "lblPicLoadingTime", _descriptor, this);
          _initializerDefineProperty(this, "flagChangeTime", _descriptor2, this);
          _initializerDefineProperty(this, "lblCachedSpecial", _descriptor3, this);
          _initializerDefineProperty(this, "lblCachedNormal", _descriptor4, this);
        }
        onOpen(fromUI, ...args) {
          let accountLayout = director.getScene().getChildByPath('Canvas/midLayer/LayoutTokenAccount');
          if (accountLayout) {
            accountLayout.active = false;
          }
          let gdMgr = GameDataManager.instance;
          if (gdMgr.preloadPicEndTime > 0) {
            let loadingTime = Math.floor((gdMgr.preloadPicEndTime - gdMgr.preloadPicStartTime) / 1000);
            this.lblPicLoadingTime.string = `Picture Loading Time: ${loadingTime}s`;
          } else {
            this.lblPicLoadingTime.string = `Picture Loading Time: uncompleted`;
          }
          this.refreshSpecialCached();
          this.refreshNormalCached();
          this.flagChangeTime.string = `Flag Change Time: ${Config.flagChangeDuration}s`;
        }
        onCloseBtn() {
          UIManager.instance.close(this);
        }
        refreshSpecialCached() {
          let gdMgr = GameDataManager.instance;
          let unshown_s = gdMgr.getUnselectedPictureList(10, true, false, true);
          let shown_s = gdMgr.getUnselectedPictureList(10, true, true, true);
          this.lblCachedSpecial.string = `unshown/unselected(s): ${unshown_s.length}/${unshown_s.length + shown_s.length}`;
        }
        refreshNormalCached() {
          let gdMgr = GameDataManager.instance;
          let unshown_n = gdMgr.getUnselectedPictureList(10, false, false, true);
          let shown_n = gdMgr.getUnselectedPictureList(10, false, true, true);
          this.lblCachedNormal.string = `unshown/unselected(n): ${unshown_n.length}/${unshown_n.length + shown_n.length}`;
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "lblPicLoadingTime", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "flagChangeTime", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "lblCachedSpecial", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "lblCachedNormal", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/debug-util.ts", ['cc'], function (exports) {
  var cclegacy, _decorator;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }],
    execute: function () {
      var _dec, _class2, _class3;
      cclegacy._RF.push({}, "b1b4bOWYlJN+6fB/aPSmRha", "debug-util", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      class PreloadGraphDebugInfo {
        constructor() {
          this.special_A_s_url = '';
          this.special_B_s_url = '';
          this.victory_B_s_url = '';
          this.selected_A_t_url = '';
          this.selected_B_t_url = '';
        }
      }
      let DebugUtil = exports('DebugUtil', (_dec = ccclass('DebugUtil'), _dec(_class2 = (_class3 = class DebugUtil {
        constructor() {
          this.preloadGraphInfo = new PreloadGraphDebugInfo();
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new DebugUtil();
          }
          return this._instance;
        }
      }, _class3._instance = null, _class3)) || _class2));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/default-config.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "f8df8gF9DxDPKWp2pzFiXDR", "default-config", undefined);
      const REWARD_CONFIG_DEFAULT = exports('REWARD_CONFIG_DEFAULT', {
        "sdk": {
          "active_waiting_time": 10
        },
        "major_token_milestone": [100, 200, 300, 400, 450, 480, 490, 500, 600, 700, 800, 1000, 1500],
        "ad": {
          "reward_multiple": 2,
          "free_times": -1,
          "drift_bubble": {
            "show": {
              "show_delay_first": 45,
              "exist_time": 30,
              "show_delay_recieved": 10,
              "show_delay_not_recieved": 30
            },
            "flip": {
              "is_ad_first_flip": true,
              "rewardIds": [0, 0, 0, 1]
            }
          },
          "win_streak": {
            "flip": {
              "is_ad_first_flip": true,
              "rewardIds": [0, 0, 0, 1]
            }
          },
          "special_card": {
            "major": {
              "num_min": 2,
              "num_max": 3
            },
            "minor": {
              "num_min": 1,
              "num_max": 2
            }
          },
          "turn_table_major_rate": 0.8,
          "inter": {
            "show_weights": [200, 100],
            "skip_times": [1, 0],
            "cd_time": 30,
            "page": {
              "level_win": {
                "is_play": true,
                "weight": 100
              },
              "tab_illustration": {
                "is_play": false,
                "weight": 0
              },
              "tab_album": {
                "is_play": false,
                "weight": 0
              },
              "photo_choose": {
                "is_play": false,
                "weight": 0
              },
              "victory_reward": {
                "is_play": false,
                "weight": 0
              },
              "surprise_reward": {
                "is_play": true,
                "weight": 50
              },
              "enough_coins": {
                "is_play": true,
                "weight": 100
              }
            }
          },
          "lucky_card_reward": 1
        },
        "tool": {
          "magic": {
            "free_amount": 0,
            "paid_amount": 3,
            "price_by_minor": 1000
          },
          "undo": {
            "free_amount": 0,
            "paid_amount": 3,
            "price_by_minor": 1000
          }
        },
        "sign_in": {
          "is_ad": true,
          "show_after_games": 1,
          "rewards": [{
            "itemId": 1,
            "amount": 5000
          }, {
            "itemId": 0,
            "amount": 20
          }, {
            "itemId": 1,
            "amount": 5000
          }, {
            "itemId": 0,
            "amount": 30
          }, {
            "itemId": 1,
            "amount": 5000
          }, {
            "itemId": 0,
            "amount": 50
          }, {
            "itemId": 0,
            "amount": 300
          }]
        },
        "range": {
          "major_before_redeem": [{
            "hold": 0.4,
            "output_min": 0.16,
            "output_max": 0.2
          }, {
            "hold": 0.64,
            "output_min": 0.064,
            "output_max": 0.08
          }, {
            "hold": 0.76,
            "output_min": 0.048,
            "output_max": 0.06
          }, {
            "hold": 0.8,
            "output_min": 0.032,
            "output_max": 0.04
          }, {
            "hold": 0.89,
            "output_min": 0.02,
            "output_max": 0.024
          }, {
            "hold": 0.965,
            "output_min": 0.01,
            "output_max": 0.012
          }, {
            "hold": 0.985,
            "output_min": 0.004,
            "output_max": 0.005
          }, {
            "hold": 0.995,
            "output_min": 0.002,
            "output_max": 0.003
          }, {
            "hold": 1,
            "output_min": 0.004,
            "output_max": 0.005
          }],
          "major_after_redeem": [{
            "hold": 0.1,
            "output_min": 0.08,
            "output_max": 0.1
          }, {
            "hold": 0.38,
            "output_min": 0.064,
            "output_max": 0.08
          }, {
            "hold": 0.52,
            "output_min": 0.048,
            "output_max": 0.06
          }, {
            "hold": 0.632,
            "output_min": 0.032,
            "output_max": 0.04
          }, {
            "hold": 0.702,
            "output_min": 0.024,
            "output_max": 0.03
          }, {
            "hold": 0.767,
            "output_min": 0.012,
            "output_max": 0.015
          }, {
            "hold": 0.872,
            "output_min": 0.0096,
            "output_max": 0.012
          }, {
            "hold": 0.918,
            "output_min": 0.008,
            "output_max": 0.01
          }, {
            "hold": 0.953,
            "output_min": 0.004,
            "output_max": 0.005
          }, {
            "hold": 0.957,
            "output_min": 0.0032,
            "output_max": 0.004
          }, {
            "hold": 0.963,
            "output_min": 0.0016,
            "output_max": 0.002
          }, {
            "hold": 0.974,
            "output_min": 0.0008,
            "output_max": 0.001
          }, {
            "hold": 0.9802,
            "output_min": 0.00064,
            "output_max": 0.0008
          }, {
            "hold": 0.98982,
            "output_min": 0.0004,
            "output_max": 0.0005
          }, {
            "hold": 1.00042,
            "output_min": 0.0004,
            "output_max": 0.0005
          }],
          "minor": [{
            "hold": 100000,
            "output_min": 300,
            "output_max": 300
          }, {
            "hold": 99999999,
            "output_min": 60,
            "output_max": 60
          }],
          "fragment": 1
        },
        "action": {
          "reward_id": 1,
          "flip": 2,
          "move_from_stock": 1,
          "move_to_foundation": 5,
          "card_collect": 10,
          "ace_to_foundation": 10
        },
        "theme": {
          "front_prices": [5000, 5000, 5000, 5000, 5000],
          "back_prices": [5000, 5000, 5000, 5000, 5000]
        },
        "real_reward": [{
          "time": 300,
          "count": 5,
          "action": "wait"
        }, {
          "time": 86400,
          "count": 24,
          "action": "wait"
        }, {
          "time": 259200,
          "count": 300,
          "action": "ad"
        }, {
          "time": 259200,
          "count": 72,
          "action": "queue",
          "init": 9997,
          "cut_per_min": 0.7,
          "cut_per_ad": 21
        }],
        "rating": {
          "show_after_games": [99, 999]
        },
        "no_web_version": ["1.0.0"],
        "no_sg_version": ["1.0.0"],
        "is_more_game": false,
        "gm": {
          "is_gm": false
        },
        "stage": {
          "special_stage_interval": 10
        },
        "chapters": [{
          "stage_groups": [{
            "stage_num": 5
          }, {
            "stage_num": 5
          }, {
            "stage_num": 5
          }, {
            "stage_num": 5
          }]
        }, {
          "stage_groups": [{
            "stage_num": 5
          }, {
            "stage_num": 5
          }, {
            "stage_num": 5
          }, {
            "stage_num": 5
          }]
        }],
        "sg": {
          "is_sg": true,
          "illustration_cost": 1000,
          "album_cost": 10,
          "preload_time": 20,
          "unselected_size": 50,
          "select": {
            "refresh_time": 1,
            "special_num": 0,
            "special_frequency": {
              "frequency": 5,
              "show_num": 3
            }
          },
          "unshow_limit": 10
        }
      });
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/drift-bubble.ts", ['cc', './reward-manager.ts'], function (exports) {
  var cclegacy, Component, view, UITransform, _decorator, tween, Vec3, RewardManager;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Component = module.Component;
      view = module.view;
      UITransform = module.UITransform;
      _decorator = module._decorator;
      tween = module.tween;
      Vec3 = module.Vec3;
    }, function (module) {
      RewardManager = module.RewardManager;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "f594cRCmg5EUYCh3s+Q7gtf", "drift-bubble", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      const EVENT_BUBBLE_REMOVED = exports('EVENT_BUBBLE_REMOVED', 'eventemoveBubble');
      let DriftBubble = exports('DriftBubble', (_dec = ccclass('drift_bubble'), _dec(_class = class DriftBubble extends Component {
        constructor(...args) {
          super(...args);
          this.driftTime = 0;
          this.bubbleTween = null;
        }
        onLoad() {
          this.driftTime = RewardManager.instance.getConfig().ad.drift_bubble.show.exist_time;
        }
        startMove() {
          const screenSize = view.getVisibleSize();
          const nodeSize = this.node.getComponent(UITransform).contentSize;
          let moveTimes = 10;
          const moveStep = () => {
            const currentPos = this.node.getPosition();
            const verticalDistance = screenSize.height / moveTimes;
            let targetX = screenSize.width / 2 - nodeSize.width / 2 - Math.random() * 100;
            targetX = currentPos.x > 0 ? 0 - targetX : targetX;
            const targetY = currentPos.y + verticalDistance;
            if (this.bubbleTween) {
              this.bubbleTween.stop();
              this.bubbleTween = null;
            }
            this.bubbleTween = this.bubbleTween = tween(this.node).to(this.driftTime / moveTimes, {
              position: new Vec3(targetX, targetY, 0)
            }, {
              easing: 'sineOut'
            }).call(() => {
              moveStep();
            }).start();
          };
          moveStep();
        }
        stopMove() {
          this.bubbleTween && this.bubbleTween.stop();
        }
      }) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/FJOIKK.ts", ['cc', './BSCTBWK.ts'], function (exports) {
  var cclegacy, BSCTBWK;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      BSCTBWK = module.BSCTBWK;
    }],
    execute: function () {
      cclegacy._RF.push({}, "da962HodclDv6l18uGtCK7A", "FJOIKK", undefined);
      class FJOIKK extends BSCTBWK {
        static MSCGDWEHBPVJEQE() {
          return this.ALNZVIWVOSKNXTKX();
        }
      }
      exports('FJOIKK', FJOIKK);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/flip-ctrl.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './game-res-manager.ts', './card.ts', './ui-util.ts', './action-chain.ts', './audio-manager.ts', './game-constants.ts', './log-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Event, Node, _decorator, Component, Vec3, tween, GameResManager, Card, CardArea, UIUtil, ActionChain, AudioManager, AudioUrl, LogUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Event = module.Event;
      Node = module.Node;
      _decorator = module._decorator;
      Component = module.Component;
      Vec3 = module.Vec3;
      tween = module.tween;
    }, function (module) {
      GameResManager = module.GameResManager;
    }, function (module) {
      Card = module.Card;
      CardArea = module.CardArea;
    }, function (module) {
      UIUtil = module.UIUtil;
    }, function (module) {
      ActionChain = module.ActionChain;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      AudioUrl = module.AudioUrl;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class2, _class3, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "c5cd1VO33xLGqm/xWq5846y", "flip-ctrl", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let FlipSlot = exports('FlipSlot', /*#__PURE__*/function (FlipSlot) {
        FlipSlot["POOL"] = "pool";
        FlipSlot["FLIP_1"] = "flip_1";
        FlipSlot["FLIP_2"] = "flip_2";
        FlipSlot["FLIP_3"] = "flip_3";
        return FlipSlot;
      }({}));
      class FlipCtrlEvent extends Event {
        constructor(name, bubbles, detail) {
          super(name, bubbles);
          this.detail = null;
          this.detail = detail;
        }
      }
      exports('FlipCtrlEvent', FlipCtrlEvent);
      FlipCtrlEvent.enum = {
        POOL_CLICKED: 'pool_clicked'
      };
      let FlipCtrl = exports('FlipCtrl', (_dec = ccclass('FlipCtrl'), _dec2 = property(Node), _dec3 = property(Node), _dec(_class2 = (_class3 = class FlipCtrl extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "slotPoolNode", _descriptor, this);
          _initializerDefineProperty(this, "slotFlipNode", _descriptor2, this);
          this._isTurnOver = false;
        }
        get isTurnOver() {
          return this._isTurnOver;
        }
        start() {}
        clear() {
          this.slotPoolNode.removeAllChildren();
          this.slotFlipNode.children.forEach(node => {
            node.removeAllChildren();
          });
        }
        update(deltaTime) {}
        onEnable() {}
        onDisable() {}
        setupFlipCtrl(cardsData) {
          this._isTurnOver = false;
          const count = cardsData.length;
          for (let i = 0; i < count; i++) {
            const card = GameResManager.instance.getCardNode();
            card.getComponent(Card).setArea(CardArea.STOCK_COVERD);
            card.getComponent(Card).refreshOrigin(new Vec3(0, 0, 0), this.slotPoolNode);
            card.getComponent(Card).setCardData(`${i}_slot`, cardsData[i]);
            card.getComponent(Card).setCovered(true);
            card.getComponent(Card).enableClick();
            card.getComponent(Card).setTag(FlipSlot.POOL);
            this.slotPoolNode.addChild(card);
          }
          LogUtil.log('setupSlot:', this.slotPoolNode.children.length);
        }
        onPoolNodeClicked(event, customEventData) {
          // LogUtil.log('onPoolNodeClicked:', event);
          const detail = {
            type: '',
            num: 0
          };
          if (this.slotPoolNode.children.length === 0) {
            this._isTurnOver = true;
            this.resetFlip();
            detail.type = 'reset';
          } else {
            let flipNum = this.slotPoolNode.children.length > 3 ? 3 : this.slotPoolNode.children.length;
            this.flipTop(flipNum);
            detail.type = 'flip';
            detail.num = flipNum;
          }
          this.node.dispatchEvent(new FlipCtrlEvent(FlipCtrlEvent.enum.POOL_CLICKED, true, detail));
        }
        flipTop(num) {
          AudioManager.instance.playEffect(AudioUrl.FLIP_CARD);
          let topCardList = [];
          for (let i = 0; i < num; i++) {
            let topCard = this.slotPoolNode.children[this.slotPoolNode.children.length - 1 - i];
            topCard && topCardList.push(topCard);
          }
          for (let i = 0; i < topCardList.length; i++) {
            let flipedCard = this.getCardNodeFromLeft(2 - i);
            if (flipedCard) {
              flipedCard.getComponent(Card).stopShake();
              flipedCard.getComponent(Card).disableClick();
            }
            let topCard = topCardList[i];
            topCard.getComponent(Card).disableClick();
            ActionChain.instance.addAction(`flipTop${i}`, this.actionFlipCard.bind(this, topCard));
          }
        }
        flipBack(moveBackToPool, num, back) {
          AudioManager.instance.playEffect(AudioUrl.FLIP_CARD);
          if (moveBackToPool) {
            let flipCardList = [];
            for (let i = 0; i < num; i++) {
              let flipedCard = this.getCardNodeFromLeft(2 - i);
              flipedCard && flipCardList.push(flipedCard);
            }
            for (let i = 0; i < flipCardList.length; i++) {
              let flipedCard = flipCardList[i];
              flipedCard.getComponent(Card).stopShake();
              flipedCard.getComponent(Card).disableClick();
              ActionChain.instance.addAction(`flipBack${i}`, this.actionFlipCardBack.bind(this, flipedCard, moveBackToPool));
            }
          } else {
            let empty = -1;
            switch (back) {
              case FlipSlot.FLIP_1:
                {
                  empty = 0;
                }
                break;
              case FlipSlot.FLIP_2:
                {
                  empty = 1;
                }
                break;
              case FlipSlot.FLIP_3:
                {
                  empty = 2;
                }
                break;
            }
            if (empty > 0) {
              const flipedCard = this.getCardNodeFromLeft(empty);
              flipedCard.getComponent(Card).stopShake();
              flipedCard.getComponent(Card).disableClick();
              ActionChain.instance.addAction(`flipBack`, this.actionFlipCardBack.bind(this, flipedCard, moveBackToPool));
            }
          }
          return Promise.resolve();
        }
        getCardNodeFromLeft(index) {
          const count = this.slotFlipNode.children.length;
          if (index < 0 || index >= count) {
            return null;
          }
          const flipNode = this.slotFlipNode.children[index];
          if (flipNode.children.length === 0) {
            return null;
          }
          return flipNode.children[index > 0 ? 0 : flipNode.children.length - 1];
        }
        getInteractiveFlipNode(name) {
          return this.slotFlipNode.getChildByName(name);
        }
        actionFlipCard(cardNode) {
          return new Promise((resolve, reject) => {
            const thirdFlip = this.slotFlipNode.children[2];

            // 2 -> 1
            this.moveCardInFlip(1, 0);

            // 3 -> 2
            this.moveCardInFlip(2, 1);

            // pool -> 3
            UIUtil.moveCardToParent(cardNode, thirdFlip, CardArea.STOCK_FLIPED);
            cardNode.getComponent(Card).setTag(FlipSlot.FLIP_3);
            cardNode.getComponent(Card).setArea(CardArea.STOCK_FLIPED);
            cardNode.getComponent(Card).refreshOrigin(new Vec3(0, 0, 0), thirdFlip);
            cardNode.getComponent(Card).disableClick();
            cardNode.getComponent(Card).flip();
            tween(cardNode).to(0.1, {
              position: new Vec3(0, 0, 0)
            }).call(() => {
              let card = cardNode.getComponent(Card);
              card.enableClick();
              resolve();
            }).start();
          });
        }
        actionFlipCardBack(cardNode, moveBackToPool) {
          return new Promise((resolve, reject) => {
            if (moveBackToPool) {
              // 3 -> pool
              UIUtil.moveCardToParent(cardNode, this.slotPoolNode, CardArea.STOCK_FLIPED);
              cardNode.getComponent(Card).setTag(FlipSlot.POOL);
              cardNode.getComponent(Card).setArea(CardArea.STOCK_FLIPED);
              cardNode.getComponent(Card).refreshOrigin(new Vec3(0, 0, 0), this.slotPoolNode);
              cardNode.getComponent(Card).disableClick();
              cardNode.getComponent(Card).flip(true);
              tween(cardNode).to(0.1, {
                position: new Vec3(0, 0, 0)
              }).call(() => {
                cardNode.getComponent(Card).enableClick();
                resolve();
              }).start();
              this.moveCardInFlip(1, 2);
              this.moveCardInFlip(0, 1);
            } else {
              cardNode.getComponent(Card).enableClick();
              switch (cardNode.getComponent(Card).tag) {
                case FlipSlot.FLIP_3:
                  {
                    this.moveCardInFlip(1, 0);
                    this.moveCardInFlip(2, 1);
                  }
                  break;
                case FlipSlot.FLIP_2:
                  {
                    this.moveCardInFlip(1, 0);
                  }
                  break;
              }
              resolve();
            }
          });
        }
        moveCardInFlip(formIndex, toIndex) {
          const fromFlip = this.slotFlipNode.children[formIndex];
          const toFlip = this.slotFlipNode.children[toIndex];
          if (fromFlip.children.length === 0) {
            return false;
          }
          const cardNode = fromFlip.children[fromFlip.children.length - 1];
          UIUtil.moveCardToParent(cardNode, toFlip, CardArea.STOCK_FLIPED);
          if (toIndex === 0) {
            cardNode.getComponent(Card).setTag(FlipSlot.FLIP_1);
          } else if (toIndex === 1) {
            cardNode.getComponent(Card).setTag(FlipSlot.FLIP_2);
          } else if (toIndex === 2) {
            cardNode.getComponent(Card).setTag(FlipSlot.FLIP_3);
          }
          cardNode.getComponent(Card).setArea(CardArea.STOCK_FLIPED);
          cardNode.getComponent(Card).refreshOrigin(new Vec3(0, 0, 0), toFlip);
          tween(cardNode).to(0.1, {
            position: new Vec3(0, 0, 0)
          }).call(() => {
            cardNode.getComponent(Card).enableClick();
          }).start();
          return true;
        }
        resetFlip() {
          ActionChain.instance.addAction('resetFlip', this.actionResetFlip.bind(this));
        }
        actionResetFlip() {
          return new Promise((resolve, reject) => {
            const nodes = this.slotFlipNode.children.reduce((acc, cur) => acc.concat(cur.children), []).reverse();
            if (nodes.length === 0) {
              resolve();
              return;
            }
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              node.setScale(1, 1, 1);
              node.getComponent(Card).setTag(FlipSlot.POOL);
              node.getComponent(Card).setCovered(true);
              node.getComponent(Card).setArea(CardArea.STOCK_COVERD);
              node.getComponent(Card).enableClick();
              UIUtil.moveCardToParent(node, this.slotPoolNode, CardArea.STOCK_FLIPED, new Vec3(0, 0, 0));
              if (i === nodes.length - 1) {
                resolve();
              }
            }
          });
        }
        get cardCount() {
          return this.slotPoolNode.children.length + this.slotFlipNode.children.reduce((acc, cur) => acc + cur.children.length, 0);
        }
        getAllCards() {
          return this.slotPoolNode.children.concat(this.slotFlipNode.children.reduce((acc, cur) => acc.concat(cur.children), []));
        }
        getDealStartWorldPos() {
          return this.slotPoolNode.worldPosition;
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class3.prototype, "slotPoolNode", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "slotFlipNode", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class3)) || _class2));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/front-line.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Asset, _decorator, Component, native, game, sys;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Asset = module.Asset;
      _decorator = module._decorator;
      Component = module.Component;
      native = module.native;
      game = module.game;
      sys = module.sys;
    }],
    execute: function () {
      var _dec, _dec2, _class2, _class3, _descriptor;
      cclegacy._RF.push({}, "e070357W+9FC6tw6XKs3C+1", "front-line", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      class HotUpdateInfo {
        constructor() {
          this.version = '';
          this.timestamp = 0;
        }
      }
      exports('HotUpdateInfo', HotUpdateInfo);
      const FrontLineEvent = exports('FrontLineEvent', {
        UPDATE_PROGRESS: 'update_progress',
        UPDATE_ERROR: 'update_error',
        UPDATE_SUCCESS: 'update_success',
        UPDATE_FAILED: 'update_failed',
        ALREADY_UP_TO_DATE: 'already_up_to_date'
      });
      const HOT_UPDATE_TIMESTAMP = exports('HOT_UPDATE_TIMESTAMP', 'hot_update_timestamp');
      const HOT_UPDATE_TIME_COST = exports('HOT_UPDATE_TIME_COST', 'hot_update_time_cost');
      const HOT_UPDATE_VERSION = exports('HOT_UPDATE_VERSION', 'hot_update_version');
      let FrontLine = exports('FrontLine', (_dec = ccclass('FrontLine'), _dec2 = property(Asset), _dec(_class2 = (_class3 = class FrontLine extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "localManifest", _descriptor, this);
          this._assetsManager = void 0;
          this._storagePath = void 0;
          this._isStarted = false;
          this._callback = null;
          this._retryLimit = 3;
          this._retryCount = 0;
          this._localStorageFolderName = 'front_line';
          this._maxConcurrentTask = 8;
        }
        start(callback) {
          console.log(`OjaiTest-front line start: ${this._isStarted}`);
          if (this._isStarted) {
            return false;
          }
          this._callback = callback;
          this._isStarted = true;
          if (!this.localManifest) {
            if (this._callback) {
              this._callback(false, 'OjaiTest-local manifest is null');
            }
            return false;
          }
          this.init();
          if (!this._assetsManager) {
            if (this._callback) {
              this._callback(false, 'OjaiTest-assets manager is null');
            }
            return false;
          }
          this.actionUpdate();
          return true;
        }
        init() {
          if (!native || !native.fileUtils) {
            return;
          }
          this._storagePath = native.fileUtils.getWritablePath() + this._localStorageFolderName;
          console.log(`OjaiTest-front line init-url: ${this.localManifest.nativeUrl}`);
          this._assetsManager = new native.AssetsManager(this.localManifest.nativeUrl, this._storagePath, this.versionCompare);
          console.log(`OjaiTest-front line init: ${this._assetsManager}`);
          this._assetsManager.setMaxConcurrentTask(this._maxConcurrentTask);
          this._assetsManager.setVerifyCallback(this.fileVerify.bind(this));
        }
        versionCompare(versionA, versionB) {
          var vA = versionA.split('.');
          var vB = versionB.split('.');
          for (var i = 0; i < vA.length; ++i) {
            var a = parseInt(vA[i]);
            var b = parseInt(vB[i] || '0');
            if (a === b) {
              continue;
            } else {
              return a - b;
            }
          }
          if (vB.length > vA.length) {
            return -1;
          } else {
            return 0;
          }
        }
        fileVerify(path, asset) {
          console.log('OjaiTest-fileVerify', path, asset.nativeUrl);
          return true;
        }
        actionCheck() {
          this._assetsManager.setEventCallback(this.onCheckEvent.bind(this));
          this._assetsManager.checkUpdate();
        }

        /**
         * 根据EventAssetsManager枚举值获取对应的key名称
         */
        getEventCodeName(code) {
          for (const key in native.EventAssetsManager) {
            const value = native.EventAssetsManager[key];
            if (typeof value === 'number' && value === code) {
              return key;
            }
          }
          return `UNKNOWN_EVENT_CODE_${code}`;
        }
        getStateName(state) {
          for (const key in native.AssetsManager.State) {
            const value = native.AssetsManager.State[key];
            if (typeof value === 'number' && value === state) {
              return key;
            }
          }
          return `UNKNOWN_STATE_${state}`;
        }
        printEventEnumValue() {
          for (const key in native.EventAssetsManager) {
            const value = native.EventAssetsManager[key];
            if (typeof value === 'number') {
              console.log(`${key}: ${value}`);
            }
          }
          for (const key in native.AssetsManager.State) {
            const value = native.AssetsManager.State[key];
            if (typeof value === 'number') {
              console.log(`${key}: ${value}`);
            }
          }
          console.log('=== 所有枚举值列表结束 ===');
        }
        onCheckEvent(event) {
          const eventCode = event.getEventCode();
          switch (eventCode) {
            case native.EventAssetsManager.ERROR_NO_LOCAL_MANIFEST:
            case native.EventAssetsManager.ERROR_DOWNLOAD_MANIFEST:
            case native.EventAssetsManager.ERROR_PARSE_MANIFEST:
              this.onUpdateError(event);
              break;
            case native.EventAssetsManager.ALREADY_UP_TO_DATE:
              this.onAlreadyUpToDate();
              break;
            case native.EventAssetsManager.NEW_VERSION_FOUND:
              this.actionUpdate();
              break;
          }
        }
        actionUpdate() {
          console.log('OjaiTest-actionUpdate');
          this._assetsManager.setEventCallback(this.onUpdateEvent.bind(this));
          this._assetsManager.update();
        }
        onUpdateEvent(event) {
          const eventCode = event.getEventCode();
          switch (eventCode) {
            case native.EventAssetsManager.ERROR_DOWNLOAD_MANIFEST:
            case native.EventAssetsManager.ERROR_PARSE_MANIFEST:
            case native.EventAssetsManager.ERROR_UPDATING:
            case native.EventAssetsManager.ERROR_DECOMPRESS:
            case native.EventAssetsManager.ERROR_NO_LOCAL_MANIFEST:
              this.onUpdateError(event);
              break;
            case native.EventAssetsManager.UPDATE_PROGRESSION:
              this.onUpdateProgress(event);
              break;
            case native.EventAssetsManager.ALREADY_UP_TO_DATE:
              this.onAlreadyUpToDate();
              break;
            case native.EventAssetsManager.UPDATE_FAILED:
              this.onUpdateFailedAndRetry();
              break;
            case native.EventAssetsManager.UPDATE_FINISHED:
              this.onUpdateSuccess();
              break;
          }
        }
        onUpdateError(event) {
          console.log(`OjaiTest-onUpdateError:${event.getMessage()}`);
          this.cleanUp();

          // 触发错误事件
          this.node.emit(FrontLineEvent.UPDATE_ERROR);

          // 回调失败状态
          if (this._callback) {
            this._callback(false, '');
          }
        }
        onUpdateProgress(event) {
          let percent = event.getDownloadedBytes() / event.getTotalBytes();
          if (typeof percent === 'number' && percent > 0) {
            percent = Math.floor(percent * 100) / 100;
            console.log(`OjaiTest-onUpdateProgress: ${(percent * 100).toFixed(0)}%`);
            this.node.emit(FrontLineEvent.UPDATE_PROGRESS, percent);
          }
        }
        onAlreadyUpToDate() {
          console.log('onAlreadyUpToDate');
          this.cleanUp();

          // 触发已经是最新版本事件
          this.node.emit(FrontLineEvent.ALREADY_UP_TO_DATE);
          if (this._callback) {
            this._callback(true, '');
          }
        }
        onUpdateFailedAndRetry() {
          console.log('OjaiTest-onUpdateFailedAndRetry');
          if (this._retryCount < this._retryLimit) {
            this._retryCount++;
            this._assetsManager.downloadFailedAssets();
          } else {
            this.cleanUp();

            // 触发更新失败事件
            this.node.emit(FrontLineEvent.UPDATE_FAILED);
            if (this._callback) {
              this._callback(false, '');
            }
          }
        }
        onUpdateSuccess() {
          console.log('OjaiTest-onUpdateSuccess');
          this.cleanUp();
          const searchPaths = native.fileUtils.getSearchPaths();
          const newPaths = this._assetsManager.getLocalManifest().getSearchPaths();
          Array.prototype.push.apply(searchPaths, newPaths);
          localStorage.setItem('FlexSearchPaths', JSON.stringify(searchPaths));
          native.fileUtils.setSearchPaths(searchPaths);

          // 触发更新成功事件
          this.node.emit(FrontLineEvent.UPDATE_SUCCESS);
          if (this._callback) {
            this._callback(true, "");
          }
          setTimeout(() => {
            game.restart();
          }, 500);
        }
        cleanUp() {
          this._assetsManager.setEventCallback(null);
        }
        getVersion() {
          if (!sys.isNative) {
            return;
          }
          try {
            // 获取可写路径下的version.manifest文件路径
            const storagePath = native.fileUtils.getWritablePath() + this._localStorageFolderName;
            const versionManifestPath = storagePath + '/version.manifest';
            console.log(`OjaiTest-getVersion: 尝试读取文件 ${versionManifestPath}`);

            // 检查文件是否存在
            if (!native.fileUtils.isFileExist(versionManifestPath)) {
              console.log('OjaiTest-getVersion: version.manifest文件不存在，尝试读取本地版本');
              // 如果热更新版本不存在，尝试读取本地版本
              return this.getLocalVersion();
            }

            // 读取version.manifest文件内容
            const fileContent = native.fileUtils.getStringFromFile(versionManifestPath);
            if (!fileContent) {
              console.log('OjaiTest-getVersion: 无法读取version.manifest文件内容');
              return this.getLocalVersion();
            }

            // 解析JSON内容
            const manifestData = JSON.parse(fileContent);
            const version = manifestData.version;
            console.log(`OjaiTest-getVersion: 成功解析版本号 ${version}`);
            return version;
          } catch (error) {
            console.error('OjaiTest-getVersion: 解析version.manifest文件失败', error);
            return this.getLocalVersion();
          }
        }

        /**
         * 获取本地版本号
         */
        getLocalVersion() {
          if (!sys.isNative) {
            return;
          }
          try {
            // 尝试从本地manifest文件获取版本号
            if (this.localManifest && this.localManifest.nativeUrl) {
              const localManifestPath = this.localManifest.nativeUrl;
              console.log(`OjaiTest-getLocalVersion: 尝试读取本地manifest ${localManifestPath}`);
              const fileContent = native.fileUtils.getStringFromFile(localManifestPath);
              if (fileContent) {
                const manifestData = JSON.parse(fileContent);
                const version = manifestData.version;
                console.log(`OjaiTest-getLocalVersion: 本地版本号 ${version}`);
                return version;
              }
            }

            // 如果无法获取本地版本，返回默认版本
            console.log('OjaiTest-getLocalVersion: 无法获取版本号，返回默认版本');
            return '1.0.0';
          } catch (error) {
            console.error('OjaiTest-getLocalVersion: 获取本地版本号失败', error);
            return '1.0.0';
          }
        }

        /**
         * 示例：如何使用getVersion方法
         * 可以在需要获取当前版本号的地方调用这个方法
         */
        logCurrentVersion() {
          const currentVersion = this.getVersion();
          console.log(`OjaiTest-当前资源版本: ${currentVersion}`);
          if (currentVersion) {
            // 可以将版本号保存到本地存储中
            sys.localStorage.setItem(HOT_UPDATE_VERSION, currentVersion);
          }
        }
      }, _descriptor = _applyDecoratedDescriptor(_class3.prototype, "localManifest", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _class3)) || _class2));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/FSIOKP.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "b8843PWP/5HIpT1MDdlPeAZ", "FSIOKP", undefined);
      /**
       * @author : jinshui
       * @date   : 2024/6/3 0003 21:52
       */
      class FSIOKP {}
      exports('FSIOKP', FSIOKP);
      class GameAd {
        constructor() {
          /**
           * 广告入口
           */
          this.entry = void 0;
          /**
           * 广告类型
           */
          this.type = void 0;
          /**
           *  收益
           */
          this.revenue = void 0;
        }
      }
      exports('GameAd', GameAd);
      class NewbyearAd {
        constructor() {
          this.id = void 0;
          // 广告id
          this.format = void 0;
          // 广告类型: "icon"
          this.type = void 0;
        } // icon广告类型  h5, store, url
      }
      exports('NewbyearAd', NewbyearAd);
      class BillingItemDetails {
        constructor() {
          this.id = void 0;
          // 商品id
          this.type = void 0;
          // 类型: 内购:iap, 订阅:subs
          this.price = void 0;
          // 本地当前价格，比如USD $0.99
          this.originalPrice = void 0;
        } // 本地原价，比如USD $1.99
      }
      exports('BillingItemDetails', BillingItemDetails);
      class BillingIapUnconsumedItem {
        constructor() {
          this.id = void 0;
          // 商品id
          this.count = void 0;
          // 购买数量（废弃）
          this.orderId = void 0;
          // 订单id
          this.thirdOrderId = void 0;
          // 三方订单id（google订单id/）
          this.customId = void 0;
          // 自定义参数
          this.receiptBase64 = void 0;
        } // 收据,Base64 NO_WRAP 编码
      }
      exports('BillingIapUnconsumedItem', BillingIapUnconsumedItem);
      class BillingSubscriptionItem {
        constructor() {
          this.id = void 0;
          // 商品id
          this.orderId = void 0;
          // 订单id
          this.thirdOrderId = void 0;
          // 三方订单id（google订单id/）
          this.customId = void 0;
          // 自定义参数
          this.expireTime = void 0;
          // 过期时间  默认为0，表示永不过期。
          this.receiptBase64 = void 0;
        } // 收据,Base64 NO_WRAP 编码
      }
      exports('BillingSubscriptionItem', BillingSubscriptionItem);
      class ContactServiceData {
        constructor() {
          this.count = void 0;
          // 未读消息数
          this.url = void 0;
        } // 客服链接url
      }
      exports('ContactServiceData', ContactServiceData);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/game-constants.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "4a410xRM7JLiLqxiJpfoAef", "game-constants", undefined);
      let GameEvent = exports('GameEvent', /*#__PURE__*/function (GameEvent) {
        GameEvent["SHOW_BTN"] = "show_btn";
        GameEvent["STAGE"] = "stage";
        GameEvent["GET_REWARD"] = "get_reward";
        GameEvent["TOKEN_ACCOUNT_CHANGE"] = "token_account_change";
        GameEvent["ITEM_GAIN_ANIM"] = "item_gain_anim";
        GameEvent["CLICK_TIPS"] = "click_tips";
        GameEvent["CHANGE_CARD_THEME"] = "change_card_theme";
        GameEvent["PLAY_VIDEO_AD"] = "play_video_ad";
        GameEvent["COLLECT_CARD"] = "collect_card";
        GameEvent["CHANGE_MAJOR_TOKEN_TYPE"] = "change_major_token_type";
        GameEvent["CHANGE_MAP_BG"] = "change_map_bg";
        GameEvent["SHOW_TARGET_CARD"] = "show_target_card";
        GameEvent["LOAD_GRAPH_COPMPLETED"] = "load_graph_copmleted";
        GameEvent["ENABLE_TOUCH"] = "enable_touch";
        GameEvent["DISABLE_TOUCH"] = "disable_touch";
        return GameEvent;
      }({}));
      let ParamShowBtn = exports('ParamShowBtn', /*#__PURE__*/function (ParamShowBtn) {
        ParamShowBtn["SHOW_AUTO"] = "show_auto";
        ParamShowBtn["SHOW_END"] = "show_end";
        ParamShowBtn["HIDE"] = "hide";
        return ParamShowBtn;
      }({}));
      let ParamStage = exports('ParamStage', /*#__PURE__*/function (ParamStage) {
        ParamStage["START"] = "start";
        ParamStage["WIN"] = "win";
        ParamStage["FAIL"] = "fail";
        return ParamStage;
      }({}));
      let ParamGetReward = exports('ParamGetReward', /*#__PURE__*/function (ParamGetReward) {
        ParamGetReward["GET_FROM_DRIFT"] = "get_from_drift";
        return ParamGetReward;
      }({}));
      let ParamClickTips = exports('ParamClickTips', /*#__PURE__*/function (ParamClickTips) {
        ParamClickTips["SHOW"] = "show";
        ParamClickTips["HIDE"] = "hide";
        return ParamClickTips;
      }({}));
      let GameState = exports('GameState', /*#__PURE__*/function (GameState) {
        GameState["INIT"] = "init";
        GameState["DEAL_CARDS"] = "deal_cards";
        GameState["PLAYING"] = "playing";
        GameState["WIN"] = "win";
        GameState["FAIL"] = "fail";
        return GameState;
      }({}));

      //任务类型
      let ActionType = exports('ActionType', /*#__PURE__*/function (ActionType) {
        ActionType["Ad"] = "ad";
        ActionType["Wait"] = "wait";
        ActionType["Queue"] = "queue";
        ActionType["SignIn"] = "sign_in";
        ActionType["Lv"] = "lv";
        ActionType["Play"] = "play";
        return ActionType;
      }({}));
      class GameConstants {}
      exports('GameConstants', GameConstants);
      GameConstants.MoveSpeed = 2500;
      GameConstants.AutoSolveMoveSpeed = 3600;
      GameConstants.CheckGameEndDuration = 5 * 1000;
      GameConstants.IdlePromptDelayCheckDuration = 10 * 1000;
      GameConstants.AutoSolveDelayCheckDuration = 2 * 1000;
      GameConstants.MagicToolPickCount = 3;
      let AudioUrl = exports('AudioUrl', /*#__PURE__*/function (AudioUrl) {
        AudioUrl["BGM"] = "audio/bgm";
        AudioUrl["BTN_CLICK"] = "audio/effect-btn-click";
        AudioUrl["FLIP_CARD"] = "audio/effect-flip-card";
        AudioUrl["DEAL_CARD"] = "audio/effect-deal-card";
        AudioUrl["GAIN_MAJOR"] = "audio/effect-gain-major";
        AudioUrl["GAIN_MINOR"] = "audio/effect-gain-minor";
        AudioUrl["MOVE_TO_TABLEAU"] = "audio/effect-move-tableau";
        AudioUrl["MOVE_CARD_FAILED"] = "audio/effect-move-card-failed";
        AudioUrl["SHOW_POPUP"] = "audio/effect-show-popup";
        AudioUrl["MOVE_TO_FOUNDATION"] = "audio/effect-move-foundation";
        AudioUrl["USE_MAGIC"] = "audio/effect-use-magic";
        AudioUrl["USE_UNDO"] = "audio/effect-use-undo";
        AudioUrl["WIN_GAME"] = "audio/effect-win-game";
        AudioUrl["SHOW_FLIP_REWARD"] = "audio/effect-show-flip-reward";
        AudioUrl["SHOW_ITEM_GET"] = "audio/effect-show-item-get";
        AudioUrl["SHOW_ITEM_OBTAIN"] = "audio/effect-show-item-obtain";
        AudioUrl["SHOW_VICTORY"] = "audio/effect-show-victory";
        AudioUrl["SLIDE_COMPLETE"] = "audio/effect-slide-complete";
        AudioUrl["SHOW_LEVEL_WIN"] = "audio/effect-show-level-win";
        AudioUrl["SPECIAL_REWARD"] = "audio/effect-special-reward";
        AudioUrl["laugh"] = "audio/effect-laugh";
        return AudioUrl;
      }({}));
      const ChapterName = exports('ChapterName', ["Consume Life", "Small-Town Life"]);
      const StartLevelReportEvents = exports('StartLevelReportEvents', {
        2: 'level_two_start',
        3: 'level_three_start',
        5: 'level_five_start',
        7: 'level_seven_start',
        10: 'level_ten_start'
      });
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/game-data-manager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './data-agent.ts', './game-constants.ts', './reward-type-define.ts', './reward-manager.ts', './mount-manager.ts', './log-util.ts', './mount-point.ts', './object-util.ts', './storage-manager.ts', './report-agent.ts', './game-data-type-define.ts', './time-agent.ts', './random-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, director, DataType, DataAgent, GameEvent, ItemType, RealRewardCompleteInfo, RewardManager, MountManager, LogUtil, MountPoint, ObjectUtil, ClassType, StorageManager, ReportAgent, CustomReportEvent, PageSuccessData, SgData, AlbumData, PictureData, GuideData, ChapterData, TimeAgent, RandomUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
    }, function (module) {
      DataType = module.DataType;
      DataAgent = module.DataAgent;
    }, function (module) {
      GameEvent = module.GameEvent;
    }, function (module) {
      ItemType = module.ItemType;
      RealRewardCompleteInfo = module.RealRewardCompleteInfo;
    }, function (module) {
      RewardManager = module.RewardManager;
    }, function (module) {
      MountManager = module.MountManager;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      MountPoint = module.MountPoint;
    }, function (module) {
      ObjectUtil = module.ObjectUtil;
      ClassType = module.ClassType;
    }, function (module) {
      StorageManager = module.StorageManager;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
      PageSuccessData = module.PageSuccessData;
    }, function (module) {
      SgData = module.SgData;
      AlbumData = module.AlbumData;
      PictureData = module.PictureData;
      GuideData = module.GuideData;
      ChapterData = module.ChapterData;
    }, function (module) {
      TimeAgent = module.TimeAgent;
    }, function (module) {
      RandomUtil = module.RandomUtil;
    }],
    execute: function () {
      var _dec, _class4, _descriptor;
      cclegacy._RF.push({}, "8c275i8ypRDPKkFgqkxXmTy", "game-data-manager", undefined);
      class FirstGameAcion {
        constructor() {
          this.start_game = true;
          this.loading = true;
          this.illustration_guide = true;
          //
          this.select_pic_guide = false;
          this.unlock_pic_guide = true;
          //
          this.more_girls_guide = true;
          //
          this.select_pic = true;
          this.start_stage = true;
          this.move_card = true;
          this.move_card_to_foundation = true;
          this.win_stage = true;
          this.victory_popup = true;
          this.pic_obtain_popup = true;
          this.album_guide = true;
          this.album_view = true;
          this.album_unlock = true;
          this.special_reward_popup_open = true;
          this.special_reward_popup_close = true;
        }
      }
      exports('FirstGameAcion', FirstGameAcion);
      class IllustrationData {
        constructor() {
          this.data = null;
          this.url = '';
        }
      }
      exports('IllustrationData', IllustrationData);
      class SignInData {
        constructor() {
          this.startTime = 0;
          this.progress1 = 0;
          this.progress2 = 0;
        }
      }
      exports('SignInData', SignInData);
      let GameData = (_dec = ClassType(SignInData), (_class4 = class GameData {
        constructor() {
          this.level = 1;
          this.levelShowRating = 0;
          // 展示评星等级（-1：已评星）
          this.gamesPlayed = 0;
          this.gamesWon = 0;
          this.winPencent = 0;
          this.curWinStreak = 0;
          this.maxWinStreak = 0;
          this.bestTime = 0;
          this.avgTime = 0;
          this.cardFrontThemeId = 0;
          this.cardBackThemeId = 0;
          this.themesFrontUnlocked = [0];
          this.themesBackUnlocked = [0];
          this.toolMagicNum = 3;
          this.toolUndoNum = 3;
          this.lastLoginTime = 0;
          this.loginDayNum = 0;
          this.signInDayNum = 0;
          this.showAdTimes = 0;
          this.realReward = new RealRewardCompleteInfo();
          this.skipInterAdTime = 0;
          this.interAdWeight = 0;
          this.majorTokenReportStage = 0;
          this.majorTokenConsumeNum = 0;
          this.lastWinDate = 0;
          this.guideData = new GuideData();
          this.chapterData = new ChapterData();
          this.illustrationData = [];
          this.isPlayPlots = false;
          this.targetCard = null;
          this.firstGameAction = new FirstGameAcion();
          this.reportLv = 0;
          this.selectedSgPicture = null;
          this.version = 0;
          _initializerDefineProperty(this, "signInData", _descriptor, this);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class4.prototype, "signInData", [_dec], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new SignInData();
        }
      }), _class4));
      class LocalData {
        constructor() {
          this.lastRFlag = false;
          this.urlsLoadCount = {};
          this.lastCheckTime = 0;
          this.urlWeightDrop = [];
          this.pageSuccessDataList = [];
        }
      }

      //卡片类型
      let MajorTokenType = exports('MajorTokenType', /*#__PURE__*/function (MajorTokenType) {
        MajorTokenType[MajorTokenType["PayPal"] = 1001] = "PayPal";
        MajorTokenType[MajorTokenType["Amazon"] = 1002] = "Amazon";
        MajorTokenType[MajorTokenType["PayPay"] = 1003] = "PayPay";
        MajorTokenType[MajorTokenType["LinePay"] = 1004] = "LinePay";
        return MajorTokenType;
      }({}));
      class PlayerData {
        constructor() {
          this.majorTokenType = MajorTokenType.PayPal;
          this.major = 0;
          this.minor = 0;
          this.fragment = 0;
          this.sid = '';
          this.inviteCode = '';
        }
      }
      exports('PlayerData', PlayerData);
      class GameDataManager {
        constructor() {
          this.data = new GameData();
          this.playerData = new PlayerData();
          this.localData = new LocalData();
          this.sg = new SgData();
          this.inGame = false;
          this.preloadPicStartTime = 0;
          this.preloadPicEndTime = 0;
          this.specialRewardInfo = null;
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new GameDataManager();
            // this._instance.loadFromLocal();
          }

          return this._instance;
        }
        initDataFromServer(gameData, playerData) {
          LogUtil.log('GameDataManager initData', gameData);
          if (!gameData || !playerData) {
            LogUtil.warn('GameDataManager initData gameData or playerData is null');
            return;
          }
          try {
            if (!gameData['version']) {
              gameData['version'] = 0;
            }
            if (gameData['version'] >= this.data.version) {
              this.data = ObjectUtil.fromPlain(GameData, gameData);
              this.playerData.sid = playerData['sid'] || '';
              this.playerData.major = playerData['major'] || 0;
              this.playerData.minor = playerData['minor'] || 0;
            }
          } catch (error) {
            LogUtil.error('GameDataManager initData error:', error);
          }
        }
        getCurrency() {
          let curData = MountManager.instance.notify(MountPoint.NativeNotifyCurrency, null);
          let cur = curData.length > 0 ? curData[0] : '';
          return cur;
        }
        setMajorToken(val) {
          this.playerData.major = val;
        }
        addMajorToken(val) {
          if (Number.isNaN(val)) {
            LogUtil.error(`addMajorToken-val:${val} is NaN`);
            return;
          }
          this.playerData.major += val;
          if (val < 0) {
            this.data.majorTokenConsumeNum += Math.abs(val);
          }
          director.emit(GameEvent.TOKEN_ACCOUNT_CHANGE, {
            type: ItemType.MajorToken,
            change: val,
            account: this.playerData.major
          });
          let data = RewardManager.instance.getMajorTokenTarget(this.data.majorTokenReportStage);
          if (data > 0 && this.playerData.major + this.data.majorTokenConsumeNum >= data) {
            if (this.data.majorTokenReportStage == 0) {
              ReportAgent.reportCustomEvent(CustomReportEvent.WWY_GAME_LIFE_KEY_NODE, {
                step: 'reach_threshold'
              });
            }
            this.data.majorTokenReportStage++;
          }
        }
        getMajorToken() {
          return this.playerData.major || 0;
        }
        setMinorToken(val) {
          this.playerData.minor = val;
        }
        addMinorToken(val) {
          if (Number.isNaN(val)) {
            LogUtil.error(`addMinorToken-val:${val} is NaN`);
            return;
          }
          this.playerData.minor += val;
          director.emit(GameEvent.TOKEN_ACCOUNT_CHANGE, {
            type: ItemType.MinorToken,
            change: val,
            account: this.playerData.minor
          });
        }
        getMinorToken() {
          return this.playerData.minor || 0;
        }
        setFragment(val) {
          this.playerData.fragment = val;
        }
        getFragment() {
          return this.playerData.fragment || 0;
        }
        addFragment(val) {
          this.playerData.fragment += val;
          director.emit(GameEvent.TOKEN_ACCOUNT_CHANGE, {
            type: ItemType.Fragment,
            change: val,
            account: this.playerData.fragment
          });
        }
        getMajorTokenType() {
          return this.playerData.majorTokenType;
        }
        setMajorTokenType(val) {
          this.playerData.majorTokenType = val;
          director.emit(GameEvent.CHANGE_MAJOR_TOKEN_TYPE, val);
        }
        updateLoginDayNum(now) {
          if (this.data.lastLoginTime == 0) {
            this.data.lastLoginTime = now;
            this.data.loginDayNum = 1;
          } else {
            let date = new Date(now);
            let lastDate = new Date(this.data.lastLoginTime);
            LogUtil.log('today:' + date.getDate());
            LogUtil.log('last:' + lastDate.getDate());
            if (date.getMonth() != lastDate.getMonth() || date.getDate() != lastDate.getDate()) {
              this.data.loginDayNum++;
            }
            this.data.lastLoginTime = now;
          }
        }
        setPlayerSid(sid) {
          this.playerData.sid = sid;
        }
        setPlayerInviteCode(code) {
          this.playerData.inviteCode = code;
        }
        getPlayerSid() {
          return this.playerData.sid;
        }
        getInviteCode() {
          return this.playerData.inviteCode;
        }
        isSpecialStage() {
          let interval = RewardManager.instance.getConfig().stage.special_stage_interval;
          return this.data.level % interval == 0;
        }
        AddAlbumData(albumId, picId) {
          if (!this.sg.album[albumId]) {
            this.sg.album[albumId] = new AlbumData();
          }
          if (picId) {
            this.sg.album[albumId].pictures[picId] = new PictureData();
            this.saveData();
          }
        }
        getPictureData(id, albumId) {
          if (albumId) {
            return this.sg.album[albumId] ? this.sg.album[albumId].pictures[id] : null;
          } else {
            let data = this.sg.illustration[id];
            if (!data) {
              this.sg.illustration[id] = new PictureData();
              this.saveData();
              return this.sg.illustration[id];
            }
            return data;
          }
        }
        onPlayVideoAd(count) {
          this.data.showAdTimes += count;
          if (this.data.realReward.stepId == 2) {
            this.data.realReward.progress += count;
            LogUtil.log(`Ad task-RealReward Step:${this.data.realReward.stepId}-progress:${this.data.realReward.progress}`);
          }
          this.saveData();
        }
        saveData(upload = false) {
          this.saveToLocal();
          if (upload) {
            this.data.version += 1;
            this.updateData();
          }
        }
        updateData() {
          const payload = {
            tokenMajor: this.playerData.major,
            tokenMinor: this.playerData.minor,
            content: JSON.stringify(this.data),
            uid: StorageManager.instance.getUid(),
            type: DataType.Game,
            inviteCode: this.playerData.inviteCode
          };
          DataAgent.uploadData(DataType.Game, payload);
        }
        loadFromLocal() {
          const playerData = DataAgent.getData(DataType.Player);
          if (!!playerData) {
            this.playerData = ObjectUtil.fromPlain(PlayerData, playerData);
          }
          const data = DataAgent.getData(DataType.Game);
          if (!!data) {
            this.data = ObjectUtil.fromPlain(GameData, data);
          }
          const localData = DataAgent.getData(DataType.Local);
          if (!!localData) {
            this.localData = ObjectUtil.fromPlain(LocalData, localData);
          }
          const sgData = DataAgent.getData(DataType.Sg);
          if (!!sgData) {
            this.sg = ObjectUtil.mergeWithDefaults(SgData, sgData);
          }

          // Check if we need to reset daily data
          this.checkAndResetDailyData();
        }
        checkAndResetDailyData() {
          const now = new Date(TimeAgent.instance.getTime());
          const lastCheckDate = new Date(this.localData.lastCheckTime);
          if (now.getDate() !== lastCheckDate.getDate() || now.getMonth() !== lastCheckDate.getMonth() || now.getFullYear() !== lastCheckDate.getFullYear()) {
            this.resetDataOnNewDay();
          }

          // if (Config.DEBUG) {
          //     const timeDiffInMinutes = (now.getTime() - this.localData.lastCheckTime) / (1000 * 60);
          //     if (timeDiffInMinutes >= 5) {
          //         this.resetDataOnNewDay();
          //     }
          // } else {
          //     // Check if it's a new day
          //     if (now.getDate() !== lastCheckDate.getDate() ||
          //         now.getMonth() !== lastCheckDate.getMonth() ||
          //         now.getFullYear() !== lastCheckDate.getFullYear()) {
          //         this.resetDataOnNewDay();
          //     }
          // }

          // Update last login time
          this.localData.lastCheckTime = now.getTime();
          DataAgent.saveData(DataType.Local, this.localData);
        }
        saveToLocal() {
          LogUtil.log(`saveToLocal-${JSON.stringify(this.data)}`);
          DataAgent.saveData(DataType.Player, this.playerData);
          DataAgent.saveData(DataType.Game, this.data);
          DataAgent.saveData(DataType.Local, this.localData);
          DataAgent.saveData(DataType.Sg, this.sg);
        }
        resetData() {
          this.data = new GameData();
          this.sg = new SgData();
          this.playerData.majorTokenType = MajorTokenType.PayPal;
          this.playerData.major = 0;
          this.playerData.minor = 0;
          this.playerData.fragment = 0;
        }
        resetDataOnNewDay() {
          // Reset daily data
          this.localData.urlsLoadCount = {};
          this.localData.urlWeightDrop = [];
        }
        incUrlsLoadCount(url) {
          if (this.localData.urlsLoadCount[url]) {
            this.localData.urlsLoadCount[url]++;
          } else {
            this.localData.urlsLoadCount[url] = 1;
          }
          return this.localData.urlsLoadCount[url] || 0;
        }
        setUrlWeightDrop(url) {
          this.localData.urlWeightDrop.push(url);
        }
        isUrlWeightDrop(url) {
          return this.localData.urlWeightDrop.indexOf(url) != -1;
        }
        getUrlsLoadCount(url) {
          return this.localData.urlsLoadCount[url] || 0;
        }
        getUrlWeightDropList() {
          return this.localData.urlWeightDrop;
        }
        getUncachedPictureList(count, isSpecial) {
          if (count <= 0) {
            return [];
          }
          let unShowList = [];
          let illustrationInfo = MountManager.instance.notify(MountPoint.NativeNotifyGetIllustration, null)[0];
          for (let k of Object.keys(illustrationInfo)) {
            let info = illustrationInfo[k];
            let data = this.getPictureData(info.id);
            if (isSpecial == info.isAd) {
              if (!data.isCached) {
                unShowList.push(info);
              }
            }
          }
          if (unShowList.length > count) {
            return RandomUtil.random(unShowList, count);
          } else {
            return unShowList;
          }
        }
        getUnselectedPictureList(count, isSpecial, isShowed, returnAll = false) {
          if (count <= 0) {
            return [];
          }
          let retList = [];
          let selectedList = [];
          if (isSpecial) {
            this.sg.unselectedSpecialPicInfoList.forEach(info => {
              let data = this.getPictureData(info.id);
              if (data.isSelected) {
                selectedList.push(info);
                return;
              }
              if (data.isShowed == isShowed) {
                retList.push(info);
              }
            });
          } else {
            this.sg.unselectedNormalPicInfoList.forEach(info => {
              let data = this.getPictureData(info.id);
              if (data.isSelected) {
                selectedList.push(info);
                return;
              }
              if (data.isShowed == isShowed) {
                retList.push(info);
              }
            });
          }
          if (selectedList.length > 0) {
            selectedList.forEach(info => {
              if (info.isAd) {
                let idx = this.sg.unselectedSpecialPicInfoList.findIndex(item => item.id == info.id);
                if (idx != -1) {
                  this.sg.unselectedSpecialPicInfoList.splice(idx, 1);
                }
              } else {
                let idx = this.sg.unselectedNormalPicInfoList.findIndex(item => item.id == info.id);
                if (idx != -1) {
                  this.sg.unselectedNormalPicInfoList.splice(idx, 1);
                }
              }
              let idx = this.sg.selectedPicInfoList.findIndex(item => item.id == info.id);
              if (idx == -1) {
                this.sg.selectedPicInfoList.push(info);
              }
            });
          }
          if (returnAll || retList.length <= count) {
            return retList;
          } else {
            return retList;
          }
        }
        getSelectedPictureList(isOwned = false) {
          let list = this.sg.selectedPicInfoList.filter(info => {
            let data = this.getPictureData(info.id);
            return data.isOwned == isOwned;
          });
          return list.reverse();
        }
        getAvailablePictureList(count, isSpecial, exceptId) {
          if (count <= 0) {
            return [];
          }
          let retList = this.getUnselectedPictureList(count, isSpecial, false);
          let diff = count - retList.length;
          if (diff > 0) {
            let unSelectedList = this.getUnselectedPictureList(diff, isSpecial, true);
            retList = retList.concat(unSelectedList);
            diff = count - retList.length;
          }
          if (diff > 0) {
            let selectedList = RandomUtil.random(this.getSelectedPictureList(false), diff);
            retList = retList.concat(selectedList);
          }
          if (exceptId) {
            retList = retList.filter(info => {
              return info.id != exceptId;
            });
          }
          if (retList.length > count) {
            return RandomUtil.random(retList, count);
          } else {
            return retList;
          }
        }
        getRandomBgInfo() {
          let bgList = [];
          let selectedPicList = this.getSelectedPictureList(true);
          let unlockAndFavoriteList = [];
          let favoriteList = [];
          let unlockList = [];
          selectedPicList.forEach(info => {
            let data = this.getPictureData(info.id);
            if (!data.isLocked && data.isFavorite) {
              unlockAndFavoriteList.push(info);
            } else if (!data.isLocked) {
              unlockList.push(info);
            } else if (data.isFavorite) {
              favoriteList.push(info);
            }
          });
          if (unlockAndFavoriteList.length > 0) {
            bgList = unlockAndFavoriteList;
          } else if (favoriteList.length > 0) {
            bgList = favoriteList;
          } else if (unlockList.length > 0) {
            bgList = unlockList;
          }
          if (bgList.length == 0) {
            bgList = selectedPicList.filter(info => {
              let data = this.getPictureData(info.id);
              return data.isFavorite;
            });
            if (bgList.length == 0) {
              bgList = selectedPicList.filter(info => {
                let data = this.getPictureData(info.id);
                return !data.isLocked;
              });
            }
          }
          let bgInfo = null;
          if (bgList.length > 1) {
            bgList = bgList.filter(info => {
              let data = this.getPictureData(info.id);
              if (data.isBg) {
                data.isBg = false;
                return false;
              } else {
                return true;
              }
            });
            let rand = Math.floor(Math.random() * bgList.length);
            bgInfo = bgList[rand];
          } else {
            bgInfo = bgList[0];
          }
          if (bgInfo) {
            let data = this.getPictureData(bgInfo.id);
            data.isBg = true;
            LogUtil.log('Rand Map Bg:', bgInfo.id);
          } else {
            LogUtil.log('Rand Map Bg: null');
          }
          return bgInfo;
        }
        isSgResReady() {
          let gdMgr = GameDataManager.instance;
          let size_n = gdMgr.sg.unselectedNormalPicInfoList.length;
          console.log(`isSgResReady-size_n:${size_n}/4`);
          let size_s = gdMgr.sg.unselectedSpecialPicInfoList.length;
          console.log(`isSgResReady-size_s:${size_s}/4`);
          return size_n >= 4 && size_s >= 4;
        }
        addPageShowData(pageName, isError) {
          let data = this.localData.pageSuccessDataList.find(item => item.page_name == pageName);
          if (!data) {
            data = new PageSuccessData(pageName);
            this.localData.pageSuccessDataList.push(data);
          }
          data.total_time++;
          if (!isError) {
            data.success_time++;
          } else {
            data.fail_times++;
          }
          this.saveData();
        }
      }
      exports('GameDataManager', GameDataManager);
      GameDataManager._instance = null;
      GameDataManager.GameDataManager = void 0;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/game-data-type-define.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './object-util.ts', './reward-type-define.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, MapType, ArrayType, ChapterType;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      MapType = module.MapType;
      ArrayType = module.ArrayType;
    }, function (module) {
      ChapterType = module.ChapterType;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class6, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;
      cclegacy._RF.push({}, "0a9705Bh/1JxJdZWx02/wJY", "game-data-type-define", undefined);
      // guide
      class GuideData {
        constructor() {
          this.isShowRedeemGuide = false;
          this.isShowMajorTokenGuide = false;
        }
      }
      exports('GuideData', GuideData);

      // chapter
      class ChapterData {
        constructor() {
          this.chapterList = [ChapterType.Consumtion, ChapterType.Countryside];
          this.curChapterId = 0;
          this.chapterUnlockedStates = {};
          this.chapterPictures = {};
        }
      }
      exports('ChapterData', ChapterData);

      // sg
      class PictureData {
        constructor() {
          this.isLocked = true;
          // 是否锁定
          this.isCached = false;
          // 是否缓存
          this.isShowed = false;
          // 被展示过
          this.isSelected = false;
          // 被选中
          this.isOwned = false;
          // 是否拥有
          this.isFavorite = false;
          this.isBg = false;
        }
        reset() {
          this.isLocked = true;
          this.isShowed = false;
          this.isSelected = false;
          this.isFavorite = false;
          this.isBg = false;
        }
      }
      exports('PictureData', PictureData);
      class AlbumData {
        constructor() {
          this.pictures = {};
        }
      }
      exports('AlbumData', AlbumData);
      class PictureInfo {
        constructor(tag, id, url_A, url_B, url_A_s, url_B_s, url_A_t, isAd) {
          this.tag = '';
          this.id = '';
          this.url_A = '';
          this.url_B = '';
          this.url_A_s = '';
          this.url_B_s = '';
          this.url_A_t = '';
          this.isAd = false;
          this.tag = tag;
          this.id = id;
          this.url_A = url_A;
          this.url_B = url_B;
          this.url_A_s = url_A_s;
          this.url_B_s = url_B_s;
          this.url_A_t = url_A_t;
          this.isAd = isAd;
        }
      }
      exports('PictureInfo', PictureInfo);
      let SgState = exports('SgState', /*#__PURE__*/function (SgState) {
        SgState[SgState["Unready"] = 0] = "Unready";
        SgState[SgState["Ready"] = 1] = "Ready";
        SgState[SgState["Started"] = 2] = "Started";
        return SgState;
      }({}));
      let SgData = exports('SgData', (_dec = MapType(String, PictureData), _dec2 = ArrayType(PictureInfo), _dec3 = ArrayType(PictureInfo), _dec4 = ArrayType(PictureInfo), _dec5 = ArrayType(PictureInfo), _dec6 = MapType(String, AlbumData), (_class6 = class SgData {
        constructor() {
          _initializerDefineProperty(this, "illustration", _descriptor, this);
          _initializerDefineProperty(this, "unselectedSpecialPicInfoList", _descriptor2, this);
          _initializerDefineProperty(this, "unselectedNormalPicInfoList", _descriptor3, this);
          _initializerDefineProperty(this, "selectedPicInfoList", _descriptor4, this);
          _initializerDefineProperty(this, "downloadedPicInfoList", _descriptor5, this);
          _initializerDefineProperty(this, "album", _descriptor6, this);
          this.selectFreqCount = 0;
          this.isPlayPlots = false;
          this.state = SgState.Unready;
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class6.prototype, "illustration", [_dec], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return {};
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class6.prototype, "unselectedSpecialPicInfoList", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class6.prototype, "unselectedNormalPicInfoList", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class6.prototype, "selectedPicInfoList", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class6.prototype, "downloadedPicInfoList", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class6.prototype, "album", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return {};
        }
      })), _class6)));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/game-desk.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './card.ts', './game-res-manager.ts', './card-constants.ts', './card-dealer.ts', './flip-ctrl.ts', './ui-util.ts', './layout-tableau.ts', './animation-canvas.ts', './game-constants.ts', './audio-manager.ts', './tool-auto-prompt.ts', './tool-auto-solve.ts', './tool-magic.ts', './tool-undo.ts', './bridge-util.ts', './celebrate-agent.ts', './ui-manager.ts', './ui-config.ts', './reward-type-define.ts', './reward-manager.ts', './game-data-manager.ts', './card-render.ts', './log-util.ts', './report-agent.ts', './circular-mask.ts', './game-data-type-define.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, _decorator, Component, director, UITransform, Vec3, tween, UIOpacity, v3, Rect, CardArea, CardEvent, Card, GameResManager, CardConstants, CardSuit, CardPoint, CardDealer, FlipCtrl, FlipCtrlEvent, UIUtil, LayoutTableau, AnimationCanvas, GameState, GameEvent, ParamStage, ParamShowBtn, AudioUrl, GameConstants, StartLevelReportEvents, AudioManager, ToolAutoPrompt, ToolAutoSolve, ToolMagic, ToolUndo, BridgeUtil, VibrationEffect, CelebrateAgent, UIManager, UIID, ItemType, RewardManager, GameDataManager, CardRender, LogUtil, ReportAgent, CustomReportEvent, CircularMask, SgState;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      _decorator = module._decorator;
      Component = module.Component;
      director = module.director;
      UITransform = module.UITransform;
      Vec3 = module.Vec3;
      tween = module.tween;
      UIOpacity = module.UIOpacity;
      v3 = module.v3;
      Rect = module.Rect;
    }, function (module) {
      CardArea = module.CardArea;
      CardEvent = module.CardEvent;
      Card = module.Card;
    }, function (module) {
      GameResManager = module.GameResManager;
    }, function (module) {
      CardConstants = module.CardConstants;
      CardSuit = module.CardSuit;
      CardPoint = module.CardPoint;
    }, function (module) {
      CardDealer = module.CardDealer;
    }, function (module) {
      FlipCtrl = module.FlipCtrl;
      FlipCtrlEvent = module.FlipCtrlEvent;
    }, function (module) {
      UIUtil = module.UIUtil;
    }, function (module) {
      LayoutTableau = module.LayoutTableau;
    }, function (module) {
      AnimationCanvas = module.AnimationCanvas;
    }, function (module) {
      GameState = module.GameState;
      GameEvent = module.GameEvent;
      ParamStage = module.ParamStage;
      ParamShowBtn = module.ParamShowBtn;
      AudioUrl = module.AudioUrl;
      GameConstants = module.GameConstants;
      StartLevelReportEvents = module.StartLevelReportEvents;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      ToolAutoPrompt = module.ToolAutoPrompt;
    }, function (module) {
      ToolAutoSolve = module.ToolAutoSolve;
    }, function (module) {
      ToolMagic = module.ToolMagic;
    }, function (module) {
      ToolUndo = module.ToolUndo;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }, function (module) {
      CelebrateAgent = module.CelebrateAgent;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      UIID = module.UIID;
    }, function (module) {
      ItemType = module.ItemType;
    }, function (module) {
      RewardManager = module.RewardManager;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      CardRender = module.CardRender;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
    }, function (module) {
      CircularMask = module.CircularMask;
    }, function (module) {
      SgState = module.SgState;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7;
      cclegacy._RF.push({}, "1fa1apr5RJEXZANWbGVZU+o", "game-desk", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let GameDesk = exports('GameDesk', (_dec = ccclass('GameDesk'), _dec2 = property(Node), _dec3 = property(Node), _dec4 = property(Node), _dec5 = property(Node), _dec6 = property(FlipCtrl), _dec7 = property(Node), _dec8 = property(Node), _dec(_class = (_class2 = class GameDesk extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "layoutFlip", _descriptor, this);
          _initializerDefineProperty(this, "slotFree", _descriptor2, this);
          _initializerDefineProperty(this, "layoutMain", _descriptor3, this);
          _initializerDefineProperty(this, "layoutFoundation", _descriptor4, this);
          _initializerDefineProperty(this, "flipCtrl", _descriptor5, this);
          _initializerDefineProperty(this, "animCanvas", _descriptor6, this);
          _initializerDefineProperty(this, "promptNode", _descriptor7, this);
          this._isToolsEnabled = true;
          this._cardDealer = new CardDealer();
          this._dragingOriginArea = CardArea.NONE;
          this._lastGameCheckTime = 0;
          this._state = GameState.INIT;
          this._toolAutoPrompt = new ToolAutoPrompt(this);
          this._toolAutoSolve = new ToolAutoSolve(this);
          this._toolUndo = new ToolUndo(this);
          this._agentCelebrate = new CelebrateAgent(this);
        }
        get currentStageIndex() {
          if (GameDataManager.instance.data.level < 1) {
            GameDataManager.instance.data.level = 1;
          }
          return GameDataManager.instance.data.level - 1;
        }
        get isToolsEnabled() {
          return this._isToolsEnabled;
        }
        get state() {
          return this._state;
        }
        start() {}
        update(deltaTime) {}
        startStage() {
          ReportAgent.reportCustomEvent(CustomReportEvent.PLAY_GAME, {
            mode: `${GameDataManager.instance.data.level}`
          });
          let gdMgr = GameDataManager.instance;
          if (gdMgr.data.level > 1 && gdMgr.data.reportLv < gdMgr.data.level) {
            gdMgr.data.reportLv = gdMgr.data.level;
            this.reportLevelStart(gdMgr.data.level);
          }
          ReportAgent.reportCustomEvent(CustomReportEvent.LEVEL_UPGRADE, {
            compsteps: '1',
            extranum: GameDataManager.instance.data.level,
            comptime: 0,
            Compnum: 0
          });
          director.emit(GameEvent.STAGE, ParamStage.START);
          this.scheduleOnce(() => {
            this.dealCard();
          }, 0.1);
        }
        reportLevelStart(lv) {
          let str = StartLevelReportEvents[lv];
          if (str) {
            ReportAgent.reportCustomEvent(CustomReportEvent.USER_LIFECYCLE_MILESTONE, {
              action: str
            });
          }
        }
        setGameState(state) {
          this._state = state;
        }
        onGoNextStage() {
          GameDataManager.instance.data.level += 1;
          this.startStage();
        }
        onEnable() {
          this.node.on(CardEvent.enum.CARD_TOUCH_START, this.onCardTouchStart, this);
          this.node.on(CardEvent.enum.CARD_TOUCH_CANCEL, this.onCardTouchCancel, this);
          this.node.on(CardEvent.enum.CARD_DRAG_START, this.onCardDragStart, this);
          this.node.on(CardEvent.enum.CARD_DRAG_MOVE, this.onCardDragMove, this);
          this.node.on(CardEvent.enum.CARD_DRAG_END, this.onCardDragEnd, this);
          this.node.on(CardEvent.enum.CARD_CLICK, this.onCardClicked, this);
          this.node.on(FlipCtrlEvent.enum.POOL_CLICKED, this.onFlipPoolClicked, this);
          director.on(GameEvent.CHANGE_CARD_THEME, this.updateCardTheme, this);
        }
        onDisable() {
          this.node.off(CardEvent.enum.CARD_TOUCH_START, this.onCardTouchStart, this);
          this.node.on(CardEvent.enum.CARD_TOUCH_CANCEL, this.onCardTouchCancel, this);
          this.node.off(CardEvent.enum.CARD_DRAG_START, this.onCardDragStart, this);
          this.node.off(CardEvent.enum.CARD_DRAG_MOVE, this.onCardDragMove, this);
          this.node.off(CardEvent.enum.CARD_DRAG_END, this.onCardDragEnd, this);
          this.node.off(CardEvent.enum.CARD_CLICK, this.onCardClicked, this);
          this.node.off(FlipCtrlEvent.enum.POOL_CLICKED, this.onFlipPoolClicked, this);
          director.off(GameEvent.CHANGE_CARD_THEME, this.updateCardTheme, this);
        }
        enbableTouch() {
          // this.touchBlock.active = false;
          director.emit(GameEvent.ENABLE_TOUCH);
        }
        disableTouch() {
          // this.touchBlock.active = true;
          director.emit(GameEvent.DISABLE_TOUCH);
        }
        clearDesk() {
          this.cancelAutoTools();
          const allCards = this.getAllCardsInDesk();
          allCards.forEach(card => {
            GameResManager.instance.putCardNode(card);
          });
          director.emit(GameEvent.SHOW_BTN, ParamShowBtn.HIDE);
        }
        dealCard() {
          this.setGameState(GameState.DEAL_CARDS);
          this.clearDesk();
          AudioManager.instance.playEffect(AudioUrl.DEAL_CARD);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          this._cardDealer.shuffle(this.currentStageIndex);
          const stocks = this._cardDealer.stocks;
          const tableaus = this._cardDealer.tableaus;
          this.flipCtrl.setupFlipCtrl(stocks);
          const animStartPos = this.animCanvas.getComponent(UITransform).convertToNodeSpaceAR(this.flipCtrl.getDealStartWorldPos());
          const layoutCount = tableaus.length;
          this.lockDesk();
          const promises = [];
          const specialMajorCards = [];
          for (let i = 0; i < layoutCount; i++) {
            const index = i;
            const cardsInLayout = tableaus[i];
            const cardNum = cardsInLayout.length;
            const layoutName = `layout_${index + 1}`;
            const layout = this.layoutMain.getChildByName(layoutName);
            if (layout) {
              const container = layout.getChildByName('container');
              container.removeAllChildren();
              let offsetY = 0;
              for (let j = 0; j < cardNum; j++) {
                const cardData = cardsInLayout[j];
                const card = GameResManager.instance.getCardNode();
                card.getComponent(Card).setCardData(`card_${index + 1}_${j}`, cardData);
                if (cardData.isSpecialMajor) {
                  specialMajorCards.push(card);
                }
                UIUtil.moveCardToParent(card, this.animCanvas, CardArea.ANIM_CANVAS, animStartPos);
                const targetPos = new Vec3(0, layout.getComponent(LayoutTableau).getCardPositionY(offsetY), 0);
                const animTagrgetPos = this.animCanvas.getComponent(UITransform).convertToNodeSpaceAR(container.getComponent(UITransform).convertToWorldSpaceAR(targetPos));
                offsetY += CardConstants.CardTopOffsetCovered;
                // const indexHori = j * (15 - j) / 2 + (i - j + 1);
                // LogUtil.log("indexHori is: ", indexHori);
                // const duration = UIUtil.calcMoveDuration(animStartPos, animTagrgetPos);
                const duration = 0.7;
                const promise = new Promise((resolve, reject) => {
                  tween(card).delay(i * 0.15).delay(j * 0.01).to(duration, {
                    position: animTagrgetPos
                  }).call(() => {
                    UIUtil.moveCardToParent(card, container, CardArea.TABLEAU);
                    card.getComponent(Card).setTag(layoutName);
                    card.getComponent(Card).setArea(CardArea.TABLEAU);
                    card.getComponent(Card).refreshOrigin(card.position.clone(), container);
                    card.setScale(1, 1, 1);
                    if (i === j) {
                      card.getComponent(Card).enableClick();
                      card.getComponent(Card).flip().then(() => {
                        resolve();
                      });
                    } else {
                      card.getComponent(Card).disableClick();
                      resolve();
                    }
                  }).start();
                });
                promises.push(promise);
              }
            }
          }
          Promise.all(promises).then(() => {
            this.flySpecialMajorCard(specialMajorCards).then(() => {
              this.unlockDesk();
              this.setGameState(GameState.PLAYING);
              this._toolAutoPrompt.postDelayCheck();
              let isSpecialStage = GameDataManager.instance.isSpecialStage();
              this.showTargetCard(isSpecialStage);
            });
          });
        }
        showTargetCard(isSpecial) {
          if (isSpecial) {
            let cardNodes = this.getAllCardsInDesk();
            cardNodes = cardNodes.filter(card => {
              let comp = card.getComponent(Card);
              return comp.area == CardArea.TABLEAU && comp.cardData.suit == CardSuit.Heart && comp.isCovered;
            });
            let randCardNode = cardNodes[Math.floor(Math.random() * cardNodes.length)];
            console.log('cards.length', cardNodes.length);
            if (!randCardNode) {
              console.error('no card to show');
            }
            GameDataManager.instance.data.targetCard = randCardNode.getComponent(Card).cardData;
            UIManager.instance.open(UIID.TargetPopup, false);
          }
          director.emit(GameEvent.SHOW_TARGET_CARD, isSpecial);
        }
        flySpecialMajorCard(cards) {
          if (cards.length === 0) {
            return Promise.resolve();
          }
          AudioManager.instance.playEffect(AudioUrl.SPECIAL_REWARD);
          const screenCenter = new Vec3(0, 0, 0); // 屏幕中心点（假设屏幕中心为世界坐标的 (0, 0, 0)）
          const cardSpacing = 50; // 卡牌之间的水平间距
          const rotationStep = 10; // 每张卡牌的旋转角度步长

          const promises = [];
          const totalCards = cards.length;
          const copyCard2Pos = new Map();
          const uiCanvas = director.getScene().getChildByPath('Canvas/uiCanvas');
          const mask = uiCanvas.getChildByName('mask');
          mask.active = true;
          mask.getComponent(UIOpacity).opacity = 255;
          mask.getComponent(CircularMask).initialRadius = this.node.getComponent(UITransform).height * 0.5;
          mask.getComponent(CircularMask).animate2Final(0.2);
          cards.forEach((card, index) => {
            const copyCardNode = this.animCanvas.getComponent(AnimationCanvas).getCloneAnimCard(card);
            copyCard2Pos.set(copyCardNode, copyCardNode.position.clone());
            card.active = false;

            // 计算目标位置
            const middleIndex = (totalCards - 1) / 2;
            const targetX = screenCenter.x + (index - middleIndex) * cardSpacing;
            const targetPosition = new Vec3(targetX, screenCenter.y, 0);

            // 计算旋转角度
            let targetRotation = 0;
            if (totalCards % 2 === 0) {
              if (index < middleIndex) {
                targetRotation = rotationStep * (middleIndex - index); // 左边卡牌旋转
              } else {
                targetRotation = -rotationStep * (index - middleIndex); // 右边卡牌旋转
              }
            } else {
              if (index < Math.floor(middleIndex)) {
                targetRotation = rotationStep * (Math.floor(middleIndex) - index); // 左边卡牌旋转
              } else if (index > Math.floor(middleIndex)) {
                targetRotation = -rotationStep * (index - Math.floor(middleIndex)); // 右边卡牌旋转
              }
            }

            // 动画逻辑
            const promise = new Promise(resolve => {
              tween(copyCardNode)
              // 从中间点飞到目标位置
              .to(0.2, {
                position: screenCenter,
                scale: v3(2, 2, 1)
              }).to(0.4, {
                position: targetPosition,
                angle: targetRotation
              }, {
                easing: 'quadInOut'
              }).delay(0.4).call(() => {
                resolve();
              }).start();
            });
            promises.push(promise);
          });

          // return Promise.resolve();
          return new Promise(resolve => {
            Promise.all(promises).then(() => {
              // 所有卡牌动画完成后，执行后续操作
              mask.getComponent(CircularMask).animate2Initial(0.2);
              tween(mask.getComponent(UIOpacity)).to(0.2, {
                opacity: 0
              }).call(() => {
                mask.active = false;
              }).start();
              const promisesAfter = [];
              copyCard2Pos.forEach((pos, copyCard) => {
                const promise = new Promise(resolve => {
                  tween(copyCard.getComponent(UIOpacity)).to(0.3, {
                    opacity: 0
                  }).start();
                  tween(copyCard).to(0.2, {
                    position: pos,
                    angle: 0,
                    scale: v3(1, 1, 1)
                  }, {
                    easing: 'quadOut'
                  }).call(() => {
                    GameResManager.instance.putCardNode(copyCard);
                    resolve();
                  }).start();
                });
                promisesAfter.push(promise);
              });
              Promise.all(promisesAfter).then(() => {
                cards.forEach(card => {
                  card.active = true;
                });
                resolve();
              });
            });
          });
        }
        getLastCardInFoundationSlot(slot) {
          if (typeof slot === 'string') {
            const slotName = slot;
            const slotNode = this.layoutFoundation.getChildByName(slotName);
            return this.getLastCardInFoundationSlot(slotNode);
          }
          const childNodes = slot.children;
          if (childNodes.length > 0) {
            const lastCard = childNodes[childNodes.length - 1];
            return lastCard;
          }
          return null;
        }
        onCardTouchStart(event) {
          this.promptNode.active = false;
          const cardNode = event.target;
          const cardNodesInChain = this.getCardNodesInChain(cardNode);
          cardNodesInChain.forEach(node => {
            node.getComponent(Card).actionTouchStart();
          });
        }
        onCardTouchCancel(event) {
          this.onUserAction();
          const cardNode = event.target;
          const cardNodesInChain = this.getCardNodesInChain(cardNode);
          cardNodesInChain.forEach(node => {
            if (this._dragingOriginArea != CardArea.NONE) {
              node.getComponent(Card).setArea(this._dragingOriginArea);
            }
            node.getComponent(Card).actionTouchCancel();
          });
          this._dragingOriginArea = CardArea.NONE;
          AudioManager.instance.playEffect(AudioUrl.MOVE_CARD_FAILED);
        }
        onCardDragStart(event) {
          const cardNode = event.target;
          this._dragingOriginArea = cardNode.getComponent(Card).area;
          const cardNodesInChain = this.getCardNodesInChain(cardNode);
          cardNodesInChain.forEach(node => {
            UIUtil.moveCardToParent(node, this.animCanvas, CardArea.ANIM_CANVAS);
            node.getComponent(Card).actionDragStart();
          });
        }
        onCardDragMove(event) {
          const cardNode = event.target;
          const delta = event.detail.delta;
          const cardNodesInChain = this.getCardNodesInChain(cardNode);
          cardNodesInChain.forEach(node => {
            node.getComponent(Card).actionDragMove(delta);
          });
        }
        onCardDragEnd(event) {
          this.onUserAction();
          const card = event.target;
          const cardNodesInChain = this.getCardNodesInChain(card);
          const isHandled = this.handleCardDragEnd(event);
          if (isHandled) {
            cardNodesInChain.forEach(node => {
              // node.getComponent(Card).setArea(this._dragingOriginArea);
              node.getComponent(Card).actionDragEnd();
            });
          } else {
            cardNodesInChain.forEach(node => {
              node.getComponent(Card).setArea(this._dragingOriginArea);
              node.getComponent(Card).actionTouchCancel();
            });
            AudioManager.instance.playEffect(AudioUrl.MOVE_CARD_FAILED);
          }
          this._dragingOriginArea = CardArea.NONE;
        }
        handleCardDragEnd(event) {
          const card = event.target;
          const formArea = this._dragingOriginArea;
          const detail = event.detail;
          const cardNodesInChain = this.getCardNodesInChain(card);
          if (formArea == CardArea.FOUNDATION) {
            if (card.getComponent(Card).cardPoint == CardPoint.Ace) {
              return false;
            }
          }
          const eventUIPosition = detail.position;
          const intersectsLayous = this.determinIntersectsLayous(eventUIPosition);
          if (cardNodesInChain.length == 1) {
            const intersectsSlots = this.determinIntersectsSlot(eventUIPosition);
            if (intersectsSlots.length > 0) {
              for (let i = 0; i < intersectsSlots.length; i++) {
                const slot = intersectsSlots[i];
                if (this.canMatchInFoundation(card, slot)) {
                  this.moveCard(formArea, CardArea.FOUNDATION, slot, cardNodesInChain);
                  return true;
                }
              }
            }
          }
          if (intersectsLayous.length > 0) {
            for (let i = 0; i < intersectsLayous.length; i++) {
              const layout = intersectsLayous[i];
              if (layout.getComponent(LayoutTableau).canMatch(card)) {
                // just match one layout
                this.moveCard(formArea, CardArea.TABLEAU, layout, cardNodesInChain);
                return true;
              }
            }
          }
          return false;
        }
        onCardClicked(event) {
          this.onUserAction();
          LogUtil.log('onCardClicked 11111');
          const cardNode = event.target;
          const area = cardNode.getComponent(Card).area;
          const cardsInChain = this.getCardNodesInChain(cardNode);
          if (area === CardArea.TABLEAU) {
            if (GameDataManager.instance.data.targetCard) {
              if (cardNode.getComponent(Card).cardData.point == GameDataManager.instance.data.targetCard.point && cardNode.getComponent(Card).cardData.suit == GameDataManager.instance.data.targetCard.suit) {
                UIManager.instance.open(UIID.TargetPopup, {
                  isWin: true,
                  callback: () => {
                    this.doWin();
                  }
                });
                return;
              }
            }
            if (cardsInChain.length == 1) {
              const matchedSlot = this.getMatchSlotInFoundations(cardNode);
              if (matchedSlot) {
                // ActionChain.instance.addAction(card.getComponent(Card).key, this.moveCard.bind(this, area, CardArea.FOUNDATION, matchedSlot, card));
                this.moveCard(area, CardArea.FOUNDATION, matchedSlot, [cardNode]);
                return;
              }
            }
            const matchedLayout = this.getMatchedLayoutInTableau(cardNode);
            if (matchedLayout) {
              // ActionChain.instance.addAction(card.getComponent(Card).key, this.moveCard.bind(this, area, CardArea.TABLEAU, matchedLayout, card));
              this.moveCard(area, CardArea.TABLEAU, matchedLayout, cardsInChain);
              return;
            }
          } else if (area === CardArea.STOCK_FLIPED) {
            const matchedSlot = this.getMatchSlotInFoundations(cardNode);
            if (matchedSlot) {
              // ActionChain.instance.addAction(card.getComponent(Card).key, this.moveCard.bind(this, area, CardArea.FOUNDATION, matchedSlot, card));
              this.moveCard(area, CardArea.FOUNDATION, matchedSlot, cardsInChain);
              return;
            }
            const matchedLayout = this.getMatchedLayoutInTableau(cardNode);
            if (matchedLayout) {
              // ActionChain.instance.addAction(card.getComponent(Card).key, this.moveCard.bind(this, area, CardArea.TABLEAU, matchedLayout, card));
              this.moveCard(area, CardArea.TABLEAU, matchedLayout, cardsInChain);
              return;
            }
          } else if (area == CardArea.FOUNDATION) {
            if (cardNode.getComponent(Card).cardPoint != CardPoint.Ace) {
              const matchedLayout = this.getMatchedLayoutInTableau(cardNode);
              if (matchedLayout) {
                // ActionChain.instance.addAction(card.getComponent(Card).key, this.moveCard.bind(this, area, CardArea.TABLEAU, matchedLayout, card));
                this.moveCard(area, CardArea.TABLEAU, matchedLayout, cardsInChain);
                return;
              }
            }
          }
          const cardNodesInChain = this.getCardNodesInChain(cardNode);
          cardNodesInChain.forEach(node => {
            node.getComponent(Card).clearTouchAffect();
          });
          AudioManager.instance.playEffect(AudioUrl.MOVE_CARD_FAILED);
        }
        onFlipPoolClicked(event) {
          // LogUtil.log('onFlipPoolClicked');
          this.onUserAction();
          if (event.detail.type == 'flip') {
            this.saveCurrentStep(CardArea.STOCK_COVERD, 'slot_pool', CardArea.STOCK_FLIPED, 'flip_3', event.detail.num, false);
          }
        }
        getCardNodesInChain(cardNode) {
          const card = cardNode.getComponent(Card);
          if (card.area == CardArea.TABLEAU) {
            const layout = this.getLayoutInTableau(card.tag);
            if (!layout) {
              throw new Error('getCardNodesInChain - layout is null: ' + card.tag);
            }
            return layout.getComponent(LayoutTableau).getCardNodesInChain(cardNode);
          } else if (card.area == CardArea.ANIM_CANVAS) {
            return this.animCanvas.children.filter(node => {
              const cardInAnim = node.getComponent(Card);
              return cardInAnim && cardInAnim.tag == card.tag;
            });
          } else {
            return [cardNode];
          }
        }
        getMatchSlotInFoundations(card) {
          for (let i = 0; i < this.layoutFoundation.children.length; i++) {
            const foundationSlot = this.layoutFoundation.children[i];
            if (this.canMatchInFoundation(card, foundationSlot)) {
              return foundationSlot;
            }
          }
          return null;
        }

        // return matched layout name or null
        getMatchedLayoutInTableau(card) {
          if (card.getComponent(Card).cardPoint == CardPoint.King) {
            LogUtil.log('getMatchedLayoutInTableau: King');
          }
          for (let i = 0; i < this.layoutMain.children.length; i++) {
            const layout = this.layoutMain.children[i];
            if (layout.getComponent(LayoutTableau).canMatch(card)) {
              return layout;
            }
          }
          return null;
        }
        determinIntersectsLayous(position) {
          const layouts = this.layoutMain.children;
          const intersectsLayous = [];
          const dragRect = new Rect(position.x - CardConstants.CardWidth * 0.5, position.y - CardConstants.CardHeight * 0.5, CardConstants.CardWidth, CardConstants.CardHeight);
          for (let i = 0; i < layouts.length; i++) {
            const layout = layouts[i];
            const frameRect = layout.getComponent(LayoutTableau).getCardsWorldRect();
            if (frameRect.intersects(dragRect)) {
              intersectsLayous.push(layout);
            }
          }

          // 根据x中心点距离近的排序
          const dragCenterX = position.x;
          intersectsLayous.sort((a, b) => {
            const aCenterX = a.getComponent(UITransform).convertToWorldSpaceAR(new Vec3(0, 0, 0)).x;
            const bCenterX = b.getComponent(UITransform).convertToWorldSpaceAR(new Vec3(0, 0, 0)).x;
            return Math.abs(aCenterX - dragCenterX) - Math.abs(bCenterX - dragCenterX);
          });
          return intersectsLayous;
        }
        determinIntersectsSlot(position) {
          const slots = this.layoutFoundation.children;
          const intersectsSlots = [];
          const dragRect = new Rect(position.x - CardConstants.CardWidth * 0.5, position.y - CardConstants.CardHeight * 0.5, CardConstants.CardWidth, CardConstants.CardHeight);
          for (let i = 0; i < slots.length; i++) {
            const slot = slots[i];
            const frameRect = slot.getComponent(UITransform).getBoundingBoxToWorld();
            if (frameRect.intersects(dragRect)) {
              intersectsSlots.push(slot);
            }
          }

          // 根据x中心点距离近的排序
          const dragCenterX = position.x;
          intersectsSlots.sort((a, b) => {
            const aCenterX = a.getComponent(UITransform).convertToWorldSpaceAR(new Vec3(0, 0, 0)).x;
            const bCenterX = b.getComponent(UITransform).convertToWorldSpaceAR(new Vec3(0, 0, 0)).x;
            return Math.abs(aCenterX - dragCenterX) - Math.abs(bCenterX - dragCenterX);
          });
          LogUtil.log('getIntersectsSlots', intersectsSlots.length);
          return intersectsSlots;
        }
        unCoverNode(node) {
          return node.getComponent(Card).flip().then(() => {
            let cardComp = node.getComponent(Card);
            if (cardComp.isSpecialMajor) {
              if (GameDataManager.instance.sg.state === SgState.Started) {
                UIManager.instance.open(UIID.SpecialRewardPopup, {
                  picInfo: Object.create(GameDataManager.instance.specialRewardInfo)
                });
              }
              cardComp.setSpecialMajor(false);
            }
            let targetCard = GameDataManager.instance.data.targetCard;
            if (targetCard && cardComp.cardData.point == targetCard.point && cardComp.cardData.suit == targetCard.suit) {
              this.scheduleOnce(() => {
                UIManager.instance.open(UIID.TargetPopup, true);
              }, 0.5);
            }
          });
        }

        //注意：moving的时候，如果是drag的情况，node并非是在原父节点上，而是在anmi_canvas上
        moveCard(fromArea, toArea, toParent, cardNodes) {
          if (cardNodes.length == 0) {
            return;
          }
          if (GameDataManager.instance.data.firstGameAction.move_card) {
            GameDataManager.instance.data.firstGameAction.move_card = false;
            ReportAgent.reportCustomEvent(CustomReportEvent.USER_LIFECYCLE_MILESTONE, {
              action: 'game_card_move'
            });
          }
          this.disableTools();
          const cardNode = cardNodes[0];
          const fromParentName = cardNode.getComponent(Card).tag;
          const toParentName = toParent.name;
          let willUncoverCard = false;
          if (fromArea == CardArea.TABLEAU) {
            willUncoverCard = this.removeFromTableau(cardNodes);
          } else if (fromArea == CardArea.STOCK_FLIPED) {
            this.removeFromStockFlip(cardNode);
          } else if (fromArea == CardArea.FOUNDATION) {
            director.emit(GameEvent.COLLECT_CARD, -1);
          }
          this.saveCurrentStep(fromArea, fromParentName, toArea, toParentName, cardNodes.length, willUncoverCard);
          var promise = null;
          if (toArea == CardArea.TABLEAU) {
            promise = this.moveToTableau(toParent, cardNodes);
          } else if (toArea == CardArea.FOUNDATION) {
            if (GameDataManager.instance.data.firstGameAction.move_card_to_foundation) {
              GameDataManager.instance.data.firstGameAction.move_card_to_foundation = false;
              ReportAgent.reportCustomEvent(CustomReportEvent.USER_LIFECYCLE_MILESTONE, {
                action: 'game_card_base'
              });
            }
            promise = this.addToFoundation(toParent, cardNodes);
          }
          LogUtil.log('moveCard begin', cardNodes[0].getComponent(Card).key);
          promise && promise.then(() => {
            LogUtil.log('moveCard end', cardNodes[0].getComponent(Card).key);
            this.enableTools();
            this.afterMoveCards(fromArea, toArea, toParent, cardNodes);
          });
        }
        afterMoveCards(fromArea, toArea, toParent, cardNodes) {
          if (this._state != GameState.PLAYING) {
            return;
          }
          if (toArea == CardArea.FOUNDATION) {
            BridgeUtil.vibrate(80, VibrationEffect.CLICK);
            const lastCard = cardNodes[cardNodes.length - 1];
            this.autoPickToFoundation(toParent, lastCard.getComponent(Card).cardData);
          } else {
            BridgeUtil.vibrate(30, VibrationEffect.TICK);
          }
        }
        lockDesk() {
          this.disableTools();
          this.disableTouch();
        }
        unlockDesk() {
          this.enableTools();
          this.enbableTouch();
        }
        moveToTableau(layout, cardNodes) {
          AudioManager.instance.playEffect(AudioUrl.MOVE_TO_TABLEAU);
          const layoutContainer = layout.getChildByName('container');
          const currentLength = layoutContainer.children.length;
          const layoutHeight = layout.getComponent(UITransform).height;
          const movingPromises = [];
          let offsetY = 0;
          if (currentLength > 0) {
            const lastCard = layout.getComponent(LayoutTableau).getLastCard();
            if (lastCard && !lastCard.getComponent(Card).isCovered) {
              offsetY += CardConstants.CardTopOffsetUnCovered + layoutHeight / 2 - lastCard.position.y - CardConstants.CardHeight * 0.5;
            } else {
              offsetY += CardConstants.CardTopOffsetCovered + layoutHeight / 2 - lastCard.position.y - CardConstants.CardHeight * 0.5;
            }
          }
          for (let i = 0; i < cardNodes.length; i++) {
            const nodeInChain = cardNodes[i];
            const card = nodeInChain.getComponent(Card);
            card.setArea(CardArea.TABLEAU);
            card.setTag(layout.name);
            card.disableClick();
            card.stopShake();
            const pos = new Vec3(0, layout.getComponent(LayoutTableau).getCardPositionY(offsetY), 0);
            const posInCanvas = this.animCanvas.getComponent(UITransform).convertToNodeSpaceAR(layoutContainer.getComponent(UITransform).convertToWorldSpaceAR(pos));
            offsetY += card.isCovered ? CardConstants.CardTopOffsetCovered : CardConstants.CardTopOffsetUnCovered;
            const animCard = this.animCanvas.getComponent(AnimationCanvas).getCloneAnimCard(nodeInChain);
            animCard.setSiblingIndex(i);
            UIUtil.moveCardToParent(nodeInChain, layoutContainer, CardArea.TABLEAU, pos);
            nodeInChain.active = false;
            const promise = new Promise((resolve, reject) => {
              const duration = UIUtil.calcMoveDuration(animCard.position, posInCanvas);
              tween(animCard).to(duration, {
                position: posInCanvas
              }).call(() => {
                nodeInChain.active = true;
                const card = nodeInChain.getComponent(Card);
                card.refreshOrigin(nodeInChain.position.clone(), layoutContainer);
                card.enableClick();
                resolve();
                GameResManager.instance.putCardNode(animCard);
              }).start();
            });
            movingPromises.push(promise);
          }
          return new Promise((resolve, reject) => {
            Promise.all(movingPromises).then(() => {
              resolve();
            });
          });
        }
        addToFoundation(slot, cardNodes, delay = 0, speed = GameConstants.MoveSpeed) {
          AudioManager.instance.playEffect(AudioUrl.MOVE_TO_FOUNDATION);
          director.emit(GameEvent.COLLECT_CARD, cardNodes.length);
          const movingPromises = [];
          for (let i = 0; i < cardNodes.length; i++) {
            const nodeInChain = cardNodes[i];
            const card = nodeInChain.getComponent(Card);
            card.setArea(CardArea.FOUNDATION);
            card.setTag(slot.name);
            card.disableClick();
            card.stopShake();
            const posInCanvas = this.animCanvas.getComponent(UITransform).convertToNodeSpaceAR(slot.getComponent(UITransform).convertToWorldSpaceAR(new Vec3(0, 0, 0)));
            const animCard = this.animCanvas.getComponent(AnimationCanvas).getCloneAnimCard(nodeInChain);
            UIUtil.moveCardToParent(nodeInChain, slot, CardArea.FOUNDATION, new Vec3(0, 0, 0));
            nodeInChain.active = false;
            const promise = new Promise((resolve, reject) => {
              LogUtil.log('addToFoundation tween begin', card.key, 'delay', delay);
              const duration = UIUtil.calcMoveDuration(animCard.position, posInCanvas, speed);
              tween(animCard).delay(delay).to(duration, {
                position: posInCanvas,
                scale: new Vec3(1, 1, 1)
              }).call(() => {
                nodeInChain.active = true;
                const card = nodeInChain.getComponent(Card);
                card.refreshOrigin(nodeInChain.position.clone(), slot);
                card.enableClick();
                LogUtil.log('addToFoundation tween end', card.key);
                if (card.isSpecialMinor) {
                  // pop special panel
                  let data = {
                    itemId: ItemType.MinorToken,
                    amount: RewardManager.instance.getRewardAmountWithItemId(ItemType.MinorToken)
                  };
                  UIManager.instance.open(UIID.ItemGetPopupSg, data);
                  card.setSpecialMinor(false);
                }
                resolve();
                GameResManager.instance.putCardNode(animCard);
              }).start();
            });
            movingPromises.push(promise);
          }
          return new Promise((resolve, reject) => {
            Promise.all(movingPromises).then(() => {
              LogUtil.log('addToFoundation all end');
              if (this.isStageWin()) {
                this.setGameState(GameState.WIN);
                this.doWin();
              }
              resolve();
            });
          });
        }
        addToFlipCtrl(cardNode, from) {
          const flip = this.flipCtrl.getInteractiveFlipNode(from);
          const card = cardNode.getComponent(Card);
          card.setArea(CardArea.STOCK_FLIPED);
          card.setTag(flip.name);
          card.disableClick();
          card.stopShake();
          const posInCanvas = this.animCanvas.getComponent(UITransform).convertToNodeSpaceAR(flip.getComponent(UITransform).convertToWorldSpaceAR(new Vec3(0, 0, 0)));
          const animCard = this.animCanvas.getComponent(AnimationCanvas).getCloneAnimCard(cardNode);
          UIUtil.moveCardToParent(cardNode, flip, CardArea.STOCK_FLIPED, new Vec3(0, 0, 0));
          cardNode.active = false;
          return new Promise((resolve, reject) => {
            const duration = UIUtil.calcMoveDuration(animCard.position, posInCanvas);
            tween(animCard).to(duration, {
              position: posInCanvas
            }).call(() => {
              cardNode.active = true;
              const card = cardNode.getComponent(Card);
              card.refreshOrigin(cardNode.position.clone(), flip);
              card.enableClick();
              resolve();
              GameResManager.instance.putCardNode(animCard);
            }).start();
          });
        }
        removeFromStockFlip(cardNode) {
          UIUtil.moveCardToParent(cardNode, this.animCanvas, CardArea.ANIM_CANVAS);
          const card = cardNode.getComponent(Card);
          const tag = card.tag;
          if (tag == 'slot_pool') ;else if (tag == 'flip_3') {
            // 2 -> 3
            this.flipCtrl.moveCardInFlip(1, 2);
            // 1 -> 2
            this.flipCtrl.moveCardInFlip(0, 1);
          } else if (tag == 'flip_2') {
            this.flipCtrl.moveCardInFlip(0, 1);
          } else ;
        }
        removeFromTableau(cardNodes) {
          let willUncoverCard = false;
          if (cardNodes.length == 0) {
            return willUncoverCard;
          }
          const layoutName = cardNodes[0].getComponent(Card).tag;
          const layout = this.getLayoutInTableau(layoutName);
          cardNodes.forEach(node => {
            UIUtil.moveCardToParent(node, this.animCanvas, CardArea.ANIM_CANVAS);
          });
          if (layout) {
            const lastCard = layout.getComponent(LayoutTableau).getLastCard();
            if (lastCard && lastCard.getComponent(Card).isCovered) {
              this.unCoverNode(lastCard);
              willUncoverCard = true;
            }
          }
          return willUncoverCard;
        }
        canMatchInFoundation(card, slot) {
          if (!slot) {
            for (let i = 0; i < this.layoutFoundation.children.length; i++) {
              const slot = this.layoutFoundation.children[i];
              if (this.canMatchInFoundation(card, slot)) {
                return true;
              }
            }
            return false;
          }
          const lastCard = this.getLastCardInFoundationSlot(slot);
          if (!lastCard) {
            return card.getComponent(Card).cardPoint == CardPoint.Ace;
          }
          const currentSlotName = card.getComponent(Card).tag;
          if (currentSlotName == slot.name) {
            return false;
          }
          const cardPoint = card.getComponent(Card).cardPoint;
          const cardSuit = card.getComponent(Card).cardSuit;
          if (cardSuit == lastCard.getComponent(Card).cardSuit && cardPoint == lastCard.getComponent(Card).cardPoint + 1) {
            return true;
          }
          return false;
        }
        getSlotInFundation(name) {
          return this.layoutFoundation.getChildByName(name);
        }
        getLayoutInTableau(name) {
          return this.layoutMain.getChildByName(name);
        }
        saveCurrentStep(fromArea, fromName, toArea, toName, count, uncoverd) {
          this._toolUndo.saveStep(fromArea, fromName, toArea, toName, count, uncoverd);
        }
        clearCurrentStep() {
          this._toolUndo.clearStep();
        }
        useToolMagic() {
          this.onUserAction();
          if (this._isToolsEnabled == false || this._state != GameState.PLAYING) {
            LogUtil.log('useToolMagic - not enabled');
            return Promise.resolve(false);
          }
          this.lockDesk();
          this.cancelAutoTools();
          BridgeUtil.vibrate(80, VibrationEffect.CLICK);
          AudioManager.instance.playEffect(AudioUrl.USE_MAGIC);
          const toolMagic = new ToolMagic(GameConstants.MagicToolPickCount, this);
          return toolMagic.execute().then(result => {
            this.unlockDesk();
            if (this.isStageWin()) {
              this.setGameState(GameState.WIN);
              this.doWin();
            }
            return result;
          });
        }
        useToolUndo() {
          this.onUserAction();
          if (this._isToolsEnabled == false || this._state != GameState.PLAYING) {
            return Promise.resolve(false);
          }
          this.lockDesk();
          BridgeUtil.vibrate(80, VibrationEffect.CLICK);
          this.cancelAutoTools();
          AudioManager.instance.playEffect(AudioUrl.USE_UNDO);
          return this._toolUndo.excute().then(result => {
            this.unlockDesk();
            return result;
          });
        }
        useToolAutoSolve() {
          this.onUserAction();
          LogUtil.log('useToolAutoSolve');
          if (this._isToolsEnabled == false || this._state != GameState.PLAYING) {
            LogUtil.log('useToolAutoSolve - not enabled');
            return;
          }
          director.emit(GameEvent.SHOW_BTN, ParamShowBtn.HIDE);
          this.lockDesk();
          this.cancelAutoTools();
          this._toolAutoSolve.excute().then(() => {
            this.unlockDesk();
            if (this.isStageWin()) {
              this.setGameState(GameState.WIN);
              this.doWin();
            }
          });
        }
        doWin() {
          if (this._state != GameState.WIN) {
            return;
          }
          ReportAgent.reportCustomEvent(CustomReportEvent.GAME_END, {
            mode: `${GameDataManager.instance.data.level}`
          });
          this.cancelAutoTools();
          this.lockDesk();
          AudioManager.instance.playEffect(AudioUrl.WIN_GAME);
          this._agentCelebrate.excute().then(() => {
            this.unlockDesk();
            director.emit(GameEvent.STAGE, ParamStage.WIN);
          });
        }
        doFail() {
          ReportAgent.reportCustomEvent(CustomReportEvent.GAME_END, {
            mode: `${GameDataManager.instance.data.level}`
          });
          this.cancelAutoTools();
          director.emit(GameEvent.STAGE, ParamStage.FAIL);
        }
        useToolEndGame() {
          this.doFail();
        }
        isStageWin() {
          if (this._state != GameState.PLAYING) {
            return false;
          }
          let kingCount = 0;
          for (let i = 0; i < this.layoutFoundation.children.length; i++) {
            const slot = this.layoutFoundation.children[i];
            const lastCard = this.getLastCardInFoundationSlot(slot);
            if (lastCard) {
              const card = lastCard.getComponent(Card);
              if (card.cardPoint == CardPoint.King) {
                kingCount += 1;
              }
            }
          }
          return kingCount == this.layoutFoundation.children.length;
        }
        updateCardLoctionInLayout(layoutName) {
          const promises = [];
          const layout = this.layoutMain.getChildByName(layoutName);
          const container = layout.getChildByName('container');
          const cardCount = container.children.length;
          const arrayTemp = Array.from(container.children);
          let offsetY = 0;
          for (let i = 0; i < cardCount; i++) {
            const cardNode = arrayTemp[i];
            cardNode.getComponent(Card).disableClick();
            const pos = new Vec3(0, layout.getComponent(LayoutTableau).getCardPositionY(offsetY), 0);
            offsetY += cardNode.getComponent(Card).isCovered ? CardConstants.CardTopOffsetCovered : CardConstants.CardTopOffsetUnCovered;
            const posInAnimCanvas = this.animCanvas.getComponent(UITransform).convertToNodeSpaceAR(container.getComponent(UITransform).convertToWorldSpaceAR(pos));
            const animCard = this.animCanvas.getComponent(AnimationCanvas).getCloneAnimCard(cardNode);
            animCard.setSiblingIndex(i);
            UIUtil.moveCardToParent(cardNode, container, CardArea.TABLEAU, pos);
            cardNode.active = false;
            const promise = new Promise((resolve, reject) => {
              const card = cardNode.getComponent(Card);

              // const duration = UIUtil.calcMoveDuration(animCard.position, posInAnimCanvas);
              const distance = Vec3.distance(animCard.position, posInAnimCanvas);
              const duration = distance / 500;
              tween(animCard).to(duration, {
                position: posInAnimCanvas
              }).call(() => {
                cardNode.active = true;
                card.refreshOrigin(cardNode.position.clone(), container);
                card.enableClick();
                resolve();
                GameResManager.instance.putCardNode(animCard);
              }).start();
            });
            promises.push(promise);
          }
          return new Promise((resolve, reject) => {
            Promise.all(promises).then(() => {
              resolve();
            });
          });
        }
        getAllCardsInDesk() {
          const allCards = [];
          for (const slot of this.layoutFoundation.children) {
            for (const child of slot.children) {
              allCards.push(child);
            }
          }
          for (const layout of this.layoutMain.children) {
            const container = layout.getChildByName('container');
            if (container) {
              for (const child of container.children) {
                allCards.push(child);
              }
            }
          }

          // Add cards from flipCtrl
          const allCardsInFlipCtrl = this.flipCtrl.getAllCards();
          return allCards.concat(allCardsInFlipCtrl);
        }
        disableTools() {
          this._isToolsEnabled = false;
        }
        enableTools() {
          this._isToolsEnabled = true;
        }
        autoPickToFoundation(slotNode, cardData) {
          return new Promise((resolve, reject) => {
            for (const layoutNode of this.layoutMain.children) {
              const layout = layoutNode.getComponent(LayoutTableau);
              const lastCardNode = layout.getLastCard();
              if (lastCardNode) {
                const lastCardData = lastCardNode.getComponent(Card).cardData;
                if (cardData.suit == lastCardData.suit && cardData.point == lastCardData.point - 1) {
                  const willUnCover = this.removeFromTableau([lastCardNode]);
                  this.addToFoundation(slotNode, [lastCardNode]).then(() => {
                    return this.autoPickToFoundation(slotNode, lastCardData);
                  });
                  this.saveCurrentStep(CardArea.TABLEAU, layoutNode.name, CardArea.FOUNDATION, slotNode.name, 1, willUnCover);
                }
              }
            }
            resolve();
          });
        }
        onUserAction() {
          this._toolAutoPrompt.postDelayCheck();
          this._toolAutoSolve.postDelayCheck();
        }
        cancelAutoTools() {
          this._toolAutoPrompt.cancelCheck();
          this._toolAutoSolve.cancelCheck();
        }
        updateCardTheme() {
          this.getAllCardsInDesk().forEach(card => {
            let render = card.getComponent(CardRender);
            render.renderCard();
          });
          GameResManager.instance.releasUnusedFrames();
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "layoutFlip", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "slotFree", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "layoutMain", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "layoutFoundation", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "flipCtrl", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "animCanvas", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "promptNode", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/game-res-manager.ts", ['cc', './card.ts', './card-constants.ts', './card-render.ts', './card-data.ts', './game-data-manager.ts', './log-util.ts'], function (exports) {
  var cclegacy, NodePool, resources, SpriteFrame, instantiate, Card, CardSuit, CardPoint, CardRender, CardData, GameDataManager, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      NodePool = module.NodePool;
      resources = module.resources;
      SpriteFrame = module.SpriteFrame;
      instantiate = module.instantiate;
    }, function (module) {
      Card = module.Card;
    }, function (module) {
      CardSuit = module.CardSuit;
      CardPoint = module.CardPoint;
    }, function (module) {
      CardRender = module.CardRender;
    }, function (module) {
      CardData = module.CardData;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      cclegacy._RF.push({}, "b0c08xGB3pGX4YyzcLppXbz", "game-res-manager", undefined);
      class GameResManager {
        constructor() {
          this._spriteFrames = new Map();
          this._unusedFrames = [];
          this._cardAtlas = null;
          this._nodePool = new NodePool();
          this._cardNodePrefab = null;
          this._liteCardNodePrefab = null;
          this._liteCardPool = new NodePool();
          this._rawStageDatas = [];
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new GameResManager();
          }
          return this._instance;
        }
        preload() {
          return new Promise((resolve, reject) => {
            Promise.all([this.preloadSpriteFrames(), this.preloadCardNodes(), this.preloadStageJson(),
            // this.preloadAtlas(),
            this.preloadLiteCardNodes()]).then(() => {
              resolve();
            });
          });
        }
        preloadSpriteFrames() {
          this._spriteFrames.forEach(frame => {
            this._unusedFrames.push(frame);
          });
          this._spriteFrames.clear();
          let frontId = GameDataManager.instance.data.cardFrontThemeId;
          let backId = GameDataManager.instance.data.cardBackThemeId;
          return new Promise((resolve, reject) => {
            Promise.all([this.preloadCardFront(frontId), this.preloadCardBack(backId), this.preloadBlank(), this.preloadMajorHint()]).then(() => {
              resolve();
            });
          });
        }
        preloadCardFront(themeId) {
          return new Promise((resolve, reject) => {
            resources.loadDir(`textures/card-theme/front/${themeId}`, SpriteFrame, (err, assets) => {
              if (err) {
                console.error(err);
                reject(err);
                return;
              }
              assets.forEach(spriteFrame => {
                this._spriteFrames.set(spriteFrame.name, spriteFrame);
                spriteFrame.addRef();
              });
              resolve();
            });
          });
        }
        preloadCardBack(themeId) {
          return new Promise((resolve, reject) => {
            let url = `textures/card-theme/back/${themeId}/cover_normal/spriteFrame`;
            resources.load(url, SpriteFrame, (err, frame) => {
              if (err) {
                console.error(err);
                reject(err);
                return;
              }
              this._spriteFrames.set(frame.name, frame);
              frame.addRef();
              resolve();
            });
          });
        }
        preloadMajorHint() {
          return new Promise((resolve, reject) => {
            let url = `textures/token-major/hint`;
            resources.loadDir(url, SpriteFrame, (err, assets) => {
              if (err) {
                console.error(err);
                reject(err);
                return;
              }
              assets.forEach(spriteFrame => {
                this._spriteFrames.set(spriteFrame.name, spriteFrame);
                spriteFrame.addRef();
              });
              resolve();
            });
          });
        }
        preloadBlank() {
          return new Promise((resolve, reject) => {
            let url = `textures/card-theme/common/card_blank/spriteFrame`;
            resources.load(url, SpriteFrame, (err, frame) => {
              if (err) {
                console.error(err);
                reject(err);
                return;
              }
              this._spriteFrames.set('common_blank', frame);
              frame.addRef();
              resolve();
            });
          });
        }
        getSpriteFrame(name) {
          return this._spriteFrames.get(name) || null;
        }
        releasUnusedFrames() {
          this._unusedFrames.forEach(frame => {
            frame.decRef();
          });
          this._unusedFrames = [];
        }
        preloadAtlas() {
          return new Promise((resolve, reject) => {
            resources.load('textures/card/card', (err, spriteAtlas) => {
              if (err) {
                console.error(err);
                reject(err);
                return;
              }

              // spriteAtlas.addRef();
              this._cardAtlas = spriteAtlas;
              const s = this._cardAtlas.getSpriteFrame("b1");
              resolve();
            });
          });
        }
        preloadCardNodes() {
          return new Promise((resolve, reject) => {
            resources.load('prefab/game/card', (err, prefab) => {
              if (err) {
                console.error(err);
                reject(err);
                return;
              }
              this._cardNodePrefab = prefab;
              const cacheNum = 52 * 3;
              for (let i = 0; i < cacheNum; i++) {
                const node = instantiate(prefab);
                this._nodePool.put(node);
              }
              resolve();
            });
          });
        }
        getSpiteFrameInAtlas(name) {
          if (!this._cardAtlas) {
            LogUtil.error('cardAtlas is null');
            return null;
          }
          const t = typeof this._cardAtlas;
          LogUtil.log('cardAtlas name:', name);
          return this._cardAtlas.getSpriteFrame(name);
        }
        preloadStageJson() {
          return new Promise((resolve, reject) => {
            resources.load("json/stage", (err, asset) => {
              if (err) {
                LogUtil.error(err);
                reject(err);
                return;
              }
              this._rawStageDatas = asset.json.stages;
              resolve();
            });
          });
        }
        getStageRawData(index) {
          if (index < 0 || index >= this._rawStageDatas.length) {
            return [[3, 1], [1, 3], [0, 12], [2, 7], [2, 9], [0, 13], [1, 10], [2, 1], [3, 13], [1, 6], [0, 4], [1, 7], [3, 8], [1, 1], [0, 3], [1, 5], [2, 6], [3, 7], [0, 2], [3, 3], [0, 8], [1, 9], [1, 2], [3, 11], [2, 10], [3, 2], [2, 2], [0, 1], [1, 11], [2, 12], [1, 13], [2, 4], [2, 13], [1, 12], [2, 11], [0, 10], [3, 9], [2, 8], [2, 3], [1, 4], [3, 4], [0, 5], [2, 5], [3, 5], [3, 6], [0, 6], [0, 7], [1, 8], [0, 9], [3, 10], [0, 11], [3, 12]];
          }
          return JSON.parse(this._rawStageDatas[index]);
        }
        getCardNode() {
          const node = this._nodePool.get();
          if (!node) {
            LogUtil.log('create new card node');
            const newNode = instantiate(this._cardNodePrefab);
            newNode.getComponent(Card).reset();
            // this._nodePool.put(newNode);
            return newNode;
          }

          // LogUtil.log('get card node from pool');
          node.getComponent(Card).reset();
          return node;
        }
        putCardNode(node) {
          node.getComponent(Card).reset();
          node.removeFromParent();
          node.active = false;
          this._nodePool.put(node);
        }
        preloadLiteCardNodes() {
          return new Promise((resolve, reject) => {
            resources.load('prefab/game/card', (err, prefab) => {
              if (err) {
                console.error(err);
                reject(err);
                return;
              }
              this._liteCardNodePrefab = prefab;
              const count = 52;
              for (let i = 0; i < count; i++) {
                const node = instantiate(prefab);
                this._liteCardPool.put(node);
              }
              resolve();
            });
          });
        }
        getLiteCardNode() {
          const node = this._liteCardPool.get();
          if (!node) {
            const newNode = instantiate(this._liteCardNodePrefab);
            newNode.getComponent(CardRender).renderCard(new CardData(CardSuit.Club, CardPoint.Ace, false));
            return newNode;
          }
          node.active = true;
          return node;
        }
        getAllLiteCardNodes() {
          const nodes = [];
          for (let i = 0; i < this._liteCardPool.size(); i++) {
            nodes.push(this._liteCardPool.get());
          }
          return nodes;
        }
        putLiteCardNode(node) {
          node.removeFromParent();
          node.active = false;
          this._liteCardPool.put(node);
        }
      }
      exports('GameResManager', GameResManager);
      GameResManager._instance = void 0;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/game-step.ts", ['cc', './card.ts'], function (exports) {
  var cclegacy, CardArea;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      CardArea = module.CardArea;
    }],
    execute: function () {
      cclegacy._RF.push({}, "dce74rxSEVJfK6sLGvoANng", "game-step", undefined);
      class GameStep {
        constructor(fromArea = CardArea.NONE, fromName, toArea = CardArea.NONE, toName, count = 1, uncoverd = false) {
          this.fromArea = CardArea.NONE;
          this.toArea = CardArea.NONE;
          this.fromName = "";
          this.toName = "";
          this.count = 0;
          this.uncoverd = false;
          this.fromArea = fromArea;
          this.fromName = fromName;
          this.toArea = toArea;
          this.toName = toName;
          this.count = count;
          this.uncoverd = uncoverd;
        }
        isVaild() {
          return this.fromArea != CardArea.NONE && this.toArea != CardArea.NONE && this.count > 0;
        }
      }
      exports('GameStep', GameStep);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/GKHQIDKQUTV.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      var _class;
      cclegacy._RF.push({}, "75a14RPjalLhqHcIRqqiC5L", "GKHQIDKQUTV", undefined);
      /**
       * @author : jinshui
       * @date   : 2024/6/16 0016 17:06
       */
      class GKHQIDKQUTV {
        static MSCGDWEHBPVJEQE() {
          return this.BPVANCXHADQJFIH;
        }
      }
      exports('GKHQIDKQUTV', GKHQIDKQUTV);
      _class = GKHQIDKQUTV;
      GKHQIDKQUTV.BPVANCXHADQJFIH = new _class();
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/gm-manager.ts", ['cc', './storage-manager.ts', './config.ts'], function (exports) {
  var cclegacy, director, StorageManager, ConfigEvent;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
    }, function (module) {
      StorageManager = module.StorageManager;
    }, function (module) {
      ConfigEvent = module.ConfigEvent;
    }],
    execute: function () {
      cclegacy._RF.push({}, "046833W1rRP2K11oUwnZcG3", "gm-manager", undefined);
      class GmManager {
        constructor() {
          this._RFlag = false;
          this._isSkipAd = false;
          this._isSkipLv = false;
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new GmManager();
            this._instance.init();
          }
          return this._instance;
        }
        init() {
          let data = StorageManager.instance.getJson('gm');
          if (data) {
            this._RFlag = data.RFlag;
            this._isSkipAd = data.isSkipAd;
            this._isSkipLv = data.isSkipLv;
          } else {
            this._RFlag = false;
            this._isSkipAd = false;
            this._isSkipLv = false;
          }
        }
        set RFlag(val) {
          this._RFlag = val;
          director.emit(ConfigEvent.FLAG_CHANGED);
        }
        get RFlag() {
          return this._RFlag;
        }
        set isSkipAd(val) {
          this._isSkipAd = val;
        }
        get isSkipAd() {
          return this._isSkipAd;
        }
        set isSkipLv(val) {
          this._isSkipLv = val;
        }
        get isSkipLv() {
          return this._isSkipLv;
        }
        saveData() {
          let data = {
            RFlag: this._RFlag,
            isSkipAd: this._isSkipAd,
            isSkipLv: this._isSkipLv
          };
          StorageManager.instance.set('gm', data);
        }
      }
      exports('GmManager', GmManager);
      GmManager._instance = null;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/gm-view.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './gm-manager.ts', './game-data-manager.ts', './ui-manager.ts', './ui-config.ts', './mount-manager.ts', './mount-point.ts', './connect-agent.ts', './game-constants.ts', './time-agent.ts', './config.ts', './storage-manager.ts', './audio-manager.ts', './front-line.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, Toggle, Label, _decorator, director, sys, UIView, GmManager, GameDataManager, UIManager, UIID, MountManager, MountPoint, ConnectAgent, GameEvent, TimeAgent, Config, StorageManager, AudioManager, HOT_UPDATE_TIME_COST;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      Toggle = module.Toggle;
      Label = module.Label;
      _decorator = module._decorator;
      director = module.director;
      sys = module.sys;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      GmManager = module.GmManager;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      UIID = module.UIID;
    }, function (module) {
      MountManager = module.MountManager;
    }, function (module) {
      MountPoint = module.MountPoint;
    }, function (module) {
      ConnectAgent = module.ConnectAgent;
    }, function (module) {
      GameEvent = module.GameEvent;
    }, function (module) {
      TimeAgent = module.TimeAgent;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      StorageManager = module.StorageManager;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      HOT_UPDATE_TIME_COST = module.HOT_UPDATE_TIME_COST;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _dec15, _dec16, _dec17, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _descriptor15, _descriptor16;
      cclegacy._RF.push({}, "4f8bfh6FKZOvJkcoxtG5vxi", "gm-view", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let GmView = exports('GmView', (_dec = ccclass('GmView'), _dec2 = property(Node), _dec3 = property(Toggle), _dec4 = property(Toggle), _dec5 = property(Toggle), _dec6 = property(Label), _dec7 = property(Label), _dec8 = property(Label), _dec9 = property(Label), _dec10 = property(Label), _dec11 = property(Label), _dec12 = property(Label), _dec13 = property(Label), _dec14 = property(Label), _dec15 = property(Label), _dec16 = property(Label), _dec17 = property(Label), _dec(_class = (_class2 = class GmView extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "btnLayout", _descriptor, this);
          _initializerDefineProperty(this, "toggleRFlag", _descriptor2, this);
          _initializerDefineProperty(this, "toggleSkipAd", _descriptor3, this);
          _initializerDefineProperty(this, "toggleSkipLv", _descriptor4, this);
          _initializerDefineProperty(this, "lblInvitedCode", _descriptor5, this);
          _initializerDefineProperty(this, "lblUid", _descriptor6, this);
          _initializerDefineProperty(this, "lblAid", _descriptor7, this);
          _initializerDefineProperty(this, "lblWwy", _descriptor8, this);
          _initializerDefineProperty(this, "lblSystem", _descriptor9, this);
          _initializerDefineProperty(this, "lblLangCode", _descriptor10, this);
          _initializerDefineProperty(this, "lblCountry", _descriptor11, this);
          _initializerDefineProperty(this, "lblHfTimeCost", _descriptor12, this);
          _initializerDefineProperty(this, "lblSymbol", _descriptor13, this);
          _initializerDefineProperty(this, "lblCurrency", _descriptor14, this);
          _initializerDefineProperty(this, "lblPackage", _descriptor15, this);
          _initializerDefineProperty(this, "lblUrl", _descriptor16, this);
          this.clickTimes = 0;
        }
        onOpen(fromUI, ...args) {
          let accountLayout = director.getScene().getChildByPath('Canvas/midLayer/LayoutTokenAccount');
          if (accountLayout) {
            accountLayout.active = false;
          }
          let gmMgr = GmManager.instance;
          this.toggleRFlag.isChecked = gmMgr.RFlag;
          this.toggleSkipAd.isChecked = gmMgr.isSkipAd;
          this.toggleSkipLv.isChecked = gmMgr.isSkipLv;
          this.lblUid.string = `uid: ${StorageManager.instance.getUid()}`;
          this.lblInvitedCode.string = `sid: ${GameDataManager.instance.getPlayerSid()}`;
          this.lblWwy.string = `wwy: ${GameDataManager.instance.getInviteCode()}`;
          this.lblAid.string = `aid: `;
          this.lblSystem.string = `system: ${sys.platform}`;
          this.lblLangCode.string = `langCode: ${Config.LANG_CODE}`;
          this.lblCountry.string = `country: ${Config.COUNTRY_CODE}`;
          let hfTimeCost = sys.localStorage.getItem(HOT_UPDATE_TIME_COST);
          this.lblHfTimeCost.string = `hfTimeCost: ${hfTimeCost ? hfTimeCost + 's' : 'no data'}`;
          this.lblPackage.string = `package: ${Config.PACKAGE}`;
          this.lblUrl.string = `apiUrl: ${Config.API_URL}`;
          this.addEventListeners();
        }
        onClose() {
          GameDataManager.instance.saveData(true);
          GmManager.instance.saveData();
          AudioManager.instance.save();
          this.removeEventListeners();
        }
        addEventListeners() {}
        removeEventListeners() {}
        onRFlagBtn() {
          this.toggleRFlag.isChecked = !this.toggleRFlag.isChecked;
          GmManager.instance.RFlag = this.toggleRFlag.isChecked;
        }
        onSkipAdBtn() {
          this.toggleSkipAd.isChecked = !this.toggleSkipAd.isChecked;
          GmManager.instance.isSkipAd = this.toggleSkipAd.isChecked;
        }
        onMinorBtn() {
          GameDataManager.instance.addMinorToken(100000);
        }
        onMajorBtn() {
          GameDataManager.instance.addMajorToken(1000);
        }
        onAddAdsBtn() {
          director.emit(GameEvent.PLAY_VIDEO_AD, 10);
        }
        onTimeBtn() {
          TimeAgent.instance.addOffset(24 * 3600 * 1000);
        }
        onSkipLvBtn() {
          this.toggleSkipLv.isChecked = !this.toggleSkipLv.isChecked;
          GmManager.instance.isSkipLv = this.toggleSkipLv.isChecked;
        }
        onAdTestBtn() {
          ConnectAgent.openTestAd();
        }
        onResetBtn() {
          StorageManager.instance.clear();
          GameDataManager.instance.resetData();
          MountManager.instance.notify(MountPoint.NativeNotifyResetData, null);
          AudioManager.instance.setStateDefault();
        }
        onBeyondBtn() {
          this.clickTimes++;
          if (this.clickTimes >= 5) {
            this.clickTimes = 0;
            UIManager.instance.open(UIID.BeyondPopup);
          }
          this.unschedule(this.cleanClickTimes.bind(this));
          this.scheduleOnce(this.cleanClickTimes.bind(this), 1);
        }
        cleanClickTimes() {
          this.clickTimes = 0;
        }
        onCloseBtn() {
          UIManager.instance.close(this);
        }
        onAddFragmentBtn() {
          GameDataManager.instance.addFragment(50);
        }
        onDebugBtn() {
          UIManager.instance.open(UIID.DebugInfoView);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "btnLayout", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "toggleRFlag", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "toggleSkipAd", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "toggleSkipLv", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "lblInvitedCode", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "lblUid", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "lblAid", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "lblWwy", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "lblSystem", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "lblLangCode", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "lblCountry", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "lblHfTimeCost", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class2.prototype, "lblSymbol", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class2.prototype, "lblCurrency", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor15 = _applyDecoratedDescriptor(_class2.prototype, "lblPackage", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor16 = _applyDecoratedDescriptor(_class2.prototype, "lblUrl", [_dec17], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/graph-manager.ts", ['cc', './log-util.ts', './ui-manager.ts'], function (exports) {
  var cclegacy, sys, native, resources, ImageAsset, assetManager, Texture2D, SpriteFrame, LogUtil, UIManager;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      sys = module.sys;
      native = module.native;
      resources = module.resources;
      ImageAsset = module.ImageAsset;
      assetManager = module.assetManager;
      Texture2D = module.Texture2D;
      SpriteFrame = module.SpriteFrame;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      UIManager = module.UIManager;
    }],
    execute: function () {
      cclegacy._RF.push({}, "60047f/CZpOyICSc516hrdA", "graph-manager", undefined);
      class GraphManager {
        constructor() {
          this.webCacheKeyPrefix = 'graph_cache_';
          this.nativeCacheSubFolder = 'graph_cache/';
          this.nativeCacheDir = '';
          this.isToasted = false;
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new GraphManager();
          }
          return this._instance;
        }
        init() {
          if (sys.isNative) {
            this.nativeCacheDir = native.fileUtils.getWritablePath() + this.nativeCacheSubFolder;
            if (!native.fileUtils.isDirectoryExist(this.nativeCacheDir)) {
              native.fileUtils.createDirectory(this.nativeCacheDir);
            }
          }
        }
        loadGraph(url) {
          return new Promise(async (resolve, reject) => {
            try {
              if (!this.isCached(url)) {
                console.log(`loadGraphLog-not cached-url:${url}`);
                await this.downloadAndCache(url);
              }
              const spf = await this.loadFromCache(url);
              resolve(spf);
            } catch (error) {
              LogUtil.log('GraphManager', 'loadGraph', error);
              resolve(null);
            }
          });
        }
        arrayBufferToBase64(buffer) {
          let binary = '';
          const bytes = new Uint8Array(buffer);
          const len = bytes.byteLength;
          for (let i = 0; i < len; i++) {
            binary += String.fromCharCode(bytes[i]);
          }
          return btoa(binary);
        }
        loadGraphToBase64(url) {
          if (!url || url.length === 0) {
            return Promise.resolve(null);
          }
          return new Promise(async (resolve, reject) => {
            if (sys.isNative) {
              try {
                await this.loadGraph(url);
                const cachePath = this.getNativeFullCachePath(url);
                const data = native.fileUtils.getDataFromFile(cachePath);
                // const decodedData = this.xorDecode(data);
                console.log('loadGraphToBase64 data', data.byteLength);
                if (!!data) {
                  console.log('loadGraphToBase64 22');
                  // 将arraybuffer转换为base64
                  const base64 = this.arrayBufferToBase64(data);
                  resolve(base64);
                } else {
                  console.log('loadGraphToBase64 33');
                  resolve(null);
                }
              } catch (error) {
                LogUtil.log('GraphManager', 'loadGraphToBase64', error);
                resolve(null);
              }
            } else {
              const cacheKey = this.getWebCacheKey(url);
              const data = sys.localStorage.getItem(cacheKey);
              if (data) {
                resolve(data);
              } else {
                resolve(null);
              }
            }
          });
        }
        loadLocalImageToBase64(path) {
          if (!path || path.length === 0) {
            return Promise.resolve(null);
          }
          let promise = new Promise(async (resolve, reject) => {
            resources.load(path, ImageAsset, (err, asset) => {
              if (err) {
                LogUtil.log('loadLocalImageToBase64-err:', err);
                reject(err);
                return;
              }
              resolve(asset);
            });
          });
          return new Promise(async (resolve, reject) => {
            let asset = await promise;
            let url = asset ? asset.nativeUrl : null;
            LogUtil.log('loadLocalImageToBase64-url:', url);
            if (!url) {
              resolve(null);
              return;
            }
            if (sys.isNative) {
              try {
                await this.loadGraph(url);
                const cachePath = this.getNativeFullCachePath(url);
                const data = native.fileUtils.getDataFromFile(cachePath);
                // const decodedData = this.xorDecode(data);
                console.log('loadLocalImageToBase64 data', data.byteLength);
                if (!!data) {
                  console.log('loadLocalImageToBase64 22');
                  // 将arraybuffer转换为base64
                  const base64 = this.arrayBufferToBase64(data);
                  resolve(base64);
                } else {
                  console.log('loadLocalImageToBase64 33');
                  resolve(null);
                }
              } catch (error) {
                LogUtil.log('GraphManager', 'loadLocalImageToBase64', error);
                resolve(null);
              }
            } else {
              const cacheKey = this.getWebCacheKey(url);
              const data = sys.localStorage.getItem(cacheKey);
              if (data) {
                resolve(data);
              } else {
                resolve(null);
              }
            }
          });
        }
        loadFromCache(url) {
          return new Promise((resolve, reject) => {
            if (sys.isNative) {
              const cachePath = this.getNativeFullCachePath(url);
              assetManager.loadRemote(cachePath, {
                ext: '.jpg'
              }, (err, asset) => {
                if (err) {
                  reject(err);
                  if (!this.isToasted) {
                    UIManager.instance.showToast(`Network Error`);
                    this.isToasted = true;
                    setTimeout(() => {
                      this.isToasted = false;
                    }, 500);
                  }
                  return;
                }
                const tex = new Texture2D();
                tex.image = asset;
                const spf = new SpriteFrame();
                spf.texture = tex;
                resolve(spf);
              });
            } else {
              const cacheKey = this.getWebCacheKey(url);
              const data = sys.localStorage.getItem(cacheKey);
              if (data) {
                // 将 base64 数据转换为二进制
                const binaryData = atob(data);
                const bytes = new Uint8Array(binaryData.length);
                for (let i = 0; i < binaryData.length; i++) {
                  bytes[i] = binaryData.charCodeAt(i);
                }

                // 创建 Blob 和 URL
                const blob = new Blob([bytes], {
                  type: 'image/jpeg'
                });
                const url = URL.createObjectURL(blob);

                // 使用 assetManager 加载
                assetManager.loadRemote(url, {
                  ext: '.jpg'
                }, (err, asset) => {
                  // 释放 Blob URL
                  URL.revokeObjectURL(url);
                  if (err) {
                    reject(err);
                    return;
                  }
                  const tex = new Texture2D();
                  tex.image = asset;
                  const spf = new SpriteFrame();
                  spf.texture = tex;
                  resolve(spf);
                });
              } else {
                reject(new Error('Failed to load from cache'));
              }
            }
          });
        }
        getCachedFileName(url) {
          return `graph_${this.hashString(url)}.jpg`;
        }
        hashString(str) {
          let hash = 0;
          for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = (hash << 5) - hash + char;
            hash = hash & hash;
          }
          return Math.abs(hash).toString(16);
        }
        getNativeFullCachePath(url) {
          return this.nativeCacheDir + this.getCachedFileName(url);
        }
        getWebCacheKey(url) {
          return this.webCacheKeyPrefix + this.getCachedFileName(url);
        }
        isCached(url) {
          if (sys.isNative) {
            const cachePath = this.getNativeFullCachePath(url);
            return native.fileUtils.isFileExist(cachePath);
          } else {
            const cacheKey = this.getWebCacheKey(url);
            return sys.localStorage.getItem(cacheKey) !== null;
          }
        }
        downloadAndCache(url) {
          return new Promise((resolve, reject) => {
            assetManager.loadRemote(url, {
              ext: '.bin'
            }, (err, asset) => {
              if (err) {
                reject(err);
                return;
              }
              const buffer = asset.buffer();
              const validate = asset.validate();
              if (sys.isNative) {
                this.saveNativeCache(url, buffer);
                resolve(true);
              } else {
                try {
                  this.saveWebCache(url, buffer);
                } catch (error) {
                  LogUtil.log('GraphManager', 'saveWebCache', error);
                }
                resolve(true);
              }
            });
          });
        }
        saveNativeCache(url, data) {
          const cachePath = this.getNativeFullCachePath(url);
          native.fileUtils.writeDataToFile(data, cachePath);
          console.log(`loadGraphLog-saveCache-cachePath:${cachePath}`);
        }
        saveWebCache(url, data) {
          const decodedData = this.xorDecode(data);
          if (!!decodedData && decodedData.length > 0) {
            const base64 = this.arrayBufferToBase64(decodedData);
            // const base64 = btoa(String.fromCharCode.apply(null, decodedData));
            const cacheKey = this.getWebCacheKey(url);
            sys.localStorage.setItem(cacheKey, base64);
          }
        }
        xorDecode(data) {
          const xorKey = 0x8A;
          const magicNumberLength = 4;
          const dataArray = new Uint8Array(data);
          const magicNumber = new Uint8Array([0xFA, 0xC8, 0xDF, 0xAD]);
          for (let i = 0; i < magicNumberLength; i++) {
            if (dataArray[i] !== magicNumber[i]) {
              console.error('Invalid magic number in encrypted data');
              return new Uint8Array(0);
            }
          }
          const decryptedData = new Uint8Array(dataArray.length - magicNumberLength);
          for (let i = 0; i < decryptedData.length; i++) {
            decryptedData[i] = dataArray[i + magicNumberLength] ^ xorKey;
          }
          return decryptedData;
        }
        clearCache() {
          if (sys.isNative) {
            const files = native.fileUtils.listFiles(this.nativeCacheDir);
            files.forEach(file => {
              native.fileUtils.removeFile(`${this.nativeCacheDir}${file}`);
            });
          } else {
            Object.keys(sys.localStorage).forEach(key => {
              if (key.startsWith(this.webCacheKeyPrefix)) {
                sys.localStorage.removeItem(key);
              }
            });
          }
        }
      }
      exports('GraphManager', GraphManager);
      GraphManager._instance = void 0;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/guide-popup.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './ui-manager.ts', './audio-manager.ts', './game-constants.ts', './report-agent.ts', './game-data-manager.ts', './bridge-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Sprite, SpriteFrame, Label, Node, _decorator, UIView, UIManager, AudioManager, AudioUrl, ReportAgent, CustomReportEvent, GameDataManager, BridgeUtil, VibrationEffect;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Sprite = module.Sprite;
      SpriteFrame = module.SpriteFrame;
      Label = module.Label;
      Node = module.Node;
      _decorator = module._decorator;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      AudioUrl = module.AudioUrl;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;
      cclegacy._RF.push({}, "dd1cbfs+9lKD7L9YXFwm5ya", "guide-popup", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      const TipsDescConfig = ["The goal is to build up a sequence of cards on the [Foundation] from Ace to King.", "Tap adn drag the cards in the [Tableau] from one column to another to build the sequence. Place a King in the empty column.", "Cards in columns must be placed in descending order and must alternate between red and black.", "Once there are no more cards available to move, tap the deck in [Stock] to draw more cards."];
      let guide_popup = exports('guide_popup', (_dec = ccclass('guide_popup'), _dec2 = property(Sprite), _dec3 = property([SpriteFrame]), _dec4 = property(Label), _dec5 = property(Node), _dec6 = property(Node), _dec(_class = (_class2 = class guide_popup extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "sprtGuideTips", _descriptor, this);
          _initializerDefineProperty(this, "framesGuideTips", _descriptor2, this);
          _initializerDefineProperty(this, "lblDesc", _descriptor3, this);
          _initializerDefineProperty(this, "btnPre", _descriptor4, this);
          _initializerDefineProperty(this, "btnNext", _descriptor5, this);
          this.stepId = void 0;
        }
        onOpen(fromUI, ...args) {
          AudioManager.instance.playEffect(AudioUrl.SHOW_POPUP);
          BridgeUtil.vibrate(30, VibrationEffect.CLICK);
          this.setGuideStep(0);
        }
        onClose() {
          if (GameDataManager.instance.data.gamesPlayed === 0) {
            ReportAgent.reportCustomEvent(CustomReportEvent.WWY_GAME_LIFE_KEY_NODE, {
              step: 'guide_end'
            });
          }
        }
        setGuideStep(step) {
          if (step < 0 || step > TipsDescConfig.length - 1) return;
          this.stepId = step;
          this.lblDesc.string = TipsDescConfig[step];
          this.sprtGuideTips.spriteFrame = this.framesGuideTips[step];
          this.btnPre.active = step > 0;
          this.btnNext.getComponentInChildren(Label).string = step < TipsDescConfig.length - 1 ? 'Next' : 'End';
        }
        onPreBtn() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          this.setGuideStep(this.stepId - 1);
        }
        onNextBtn() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          if (this.stepId < TipsDescConfig.length - 1) {
            this.setGuideStep(this.stepId + 1);
          } else {
            UIManager.instance.close(this);
          }
        }
        onCloseBtn() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          UIManager.instance.close(this);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "sprtGuideTips", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "framesGuideTips", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "lblDesc", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "btnPre", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "btnNext", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/guide-tips.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './ui-manager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, Label, _decorator, tween, UITransform, UIOpacity, UIView, UIManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      Label = module.Label;
      _decorator = module._decorator;
      tween = module.tween;
      UITransform = module.UITransform;
      UIOpacity = module.UIOpacity;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      UIManager = module.UIManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "d99d7yAYodKO5652kXkG8x0", "guide-tips", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let GuideTips = exports('GuideTips', (_dec = ccclass('GuideTips'), _dec2 = property(Node), _dec3 = property(Node), _dec4 = property(Label), _dec(_class = (_class2 = class GuideTips extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "handTips", _descriptor, this);
          _initializerDefineProperty(this, "blockLayer", _descriptor2, this);
          _initializerDefineProperty(this, "lblTips", _descriptor3, this);
          this.clickCallback = null;
          this.external = null;
        }
        onOpen(fromUI, ...args) {
          let data = args[0];
          this.handTips.active = true;
          tween(this.handTips).stop();
          let lPos = this.getComponent(UITransform).convertToNodeSpaceAR(data.wPos);
          this.handTips.setPosition(lPos);
          this.handTips.getComponent(UITransform).priority = 2;
          if (data.moveBy) {
            tween(this.handTips).delay(0.5).by(data.moveTime, {
              position: data.moveBy
            }, {
              easing: 'sineOut'
            }).delay(0.5).call(() => {
              this.handTips.setPosition(lPos);
            }).union().repeatForever().start();
          }
          this.blockLayer.active = data.force;
          if (this.blockLayer.active) {
            this.blockLayer.getComponent(UIOpacity).opacity = data.moveBy ? 0 : 153;
          }
          this.clickCallback = data.callback;
          if (data.desc) {
            this.lblTips.node.active = true;
            this.lblTips.string = data.desc.text ? data.desc.text : '';
            this.lblTips.node.setPosition(data.desc.pos);
          } else {
            this.lblTips.node.active = false;
          }
          if (data.external) {
            this.external = data.external.node;
            this.node.addChild(this.external);
            this.external.setPosition(this.getComponent(UITransform).convertToNodeSpaceAR(data.external.wPos));
            this.external.getComponent(UITransform).priority = 1;
          }
        }
        onClose() {
          if (this.external) {
            this.external.removeFromParent();
            this.external = null;
          }
          tween(this.handTips).stop();
          this.clickCallback = null;
        }
        onClickBlockLayer() {
          this.clickCallback && this.clickCallback();
          UIManager.instance.hideGuide();
        }
        onClickTipsArea() {
          this.clickCallback && this.clickCallback();
          UIManager.instance.hideGuide();
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "handTips", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "blockLayer", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "lblTips", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/home-view.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './game-data-manager.ts', './timer-displayer.ts', './ui-manager.ts', './ui-config.ts', './reward-type-define.ts', './game-desk.ts', './game-constants.ts', './audio-manager.ts', './reward-manager.ts', './mount-manager.ts', './gm-manager.ts', './mount-point.ts', './time-agent.ts', './config.ts', './report-agent.ts', './bridge-util.ts', './stage.ts', './game-data-type-define.ts', './ad-manager.ts', './loading-manager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Button, Node, Label, _decorator, director, UIView, GameDataManager, TimerDisplayer, UIManager, UIID, ItemType, GameDesk, AudioUrl, GameEvent, ParamShowBtn, ParamStage, ActionType, AudioManager, RewardManager, MountManager, GmManager, MountPoint, TimeAgent, ConfigEvent, Config, ReportAgent, CustomReportEvent, LoadingTaskType, BridgeUtil, VibrationEffect, Stage, SgState, AdManager, LoadingManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Button = module.Button;
      Node = module.Node;
      Label = module.Label;
      _decorator = module._decorator;
      director = module.director;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      TimerDisplayer = module.TimerDisplayer;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      UIID = module.UIID;
    }, function (module) {
      ItemType = module.ItemType;
    }, function (module) {
      GameDesk = module.GameDesk;
    }, function (module) {
      AudioUrl = module.AudioUrl;
      GameEvent = module.GameEvent;
      ParamShowBtn = module.ParamShowBtn;
      ParamStage = module.ParamStage;
      ActionType = module.ActionType;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      RewardManager = module.RewardManager;
    }, function (module) {
      MountManager = module.MountManager;
    }, function (module) {
      GmManager = module.GmManager;
    }, function (module) {
      MountPoint = module.MountPoint;
    }, function (module) {
      TimeAgent = module.TimeAgent;
    }, function (module) {
      ConfigEvent = module.ConfigEvent;
      Config = module.Config;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
      LoadingTaskType = module.LoadingTaskType;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }, function (module) {
      Stage = module.Stage;
    }, function (module) {
      SgState = module.SgState;
    }, function (module) {
      AdManager = module.AdManager;
    }, function (module) {
      LoadingManager = module.LoadingManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12;
      cclegacy._RF.push({}, "e8c1egJBQxJxYGqnpbFb4Mk", "home-view", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let HomeView = exports('HomeView', (_dec = ccclass('HomeView'), _dec2 = property({
        type: Button
      }), _dec3 = property({
        type: Button
      }), _dec4 = property({
        type: Button
      }), _dec5 = property({
        type: Button
      }), _dec6 = property({
        type: Button
      }), _dec7 = property({
        type: Button
      }), _dec8 = property(TimerDisplayer), _dec9 = property(Node), _dec10 = property(Label), _dec11 = property(Node), _dec12 = property(Node), _dec13 = property(Node), _dec(_class = (_class2 = class HomeView extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "btnThemes", _descriptor, this);
          _initializerDefineProperty(this, "btnMagic", _descriptor2, this);
          _initializerDefineProperty(this, "btnUndo", _descriptor3, this);
          _initializerDefineProperty(this, "btnAutoSolve", _descriptor4, this);
          _initializerDefineProperty(this, "btnEndGame", _descriptor5, this);
          _initializerDefineProperty(this, "btnHome", _descriptor6, this);
          _initializerDefineProperty(this, "timer", _descriptor7, this);
          _initializerDefineProperty(this, "btnSkipLv", _descriptor8, this);
          _initializerDefineProperty(this, "lblLv", _descriptor9, this);
          _initializerDefineProperty(this, "targetTips", _descriptor10, this);
          _initializerDefineProperty(this, "btnIllustration", _descriptor11, this);
          _initializerDefineProperty(this, "btnAlbum", _descriptor12, this);
          this.gameDesk = null;
          this.bgId = '';
          this.bottomLayout = null;
        }
        onLoad() {
          let canvas = director.getScene().getChildByName("Canvas");
          this.gameDesk = canvas.getComponentInChildren(GameDesk);
        }
        onEnable() {
          director.on(ConfigEvent.FLAG_CHANGED, this.updateDisplay, this);
        }
        onDisable() {
          director.off(ConfigEvent.FLAG_CHANGED, this.updateDisplay, this);
        }
        onOpen(fromUI, ...args) {
          this.updateDisplay();
          this.addEventListeners();
          this.targetTips.active = false;
          if (!AudioManager.instance.switchMusic) {
            this.scheduleOnce(() => {
              AudioManager.instance.stopMusic();
            }, 0.5);
          } else {
            AudioManager.instance.playMusicLoop(AudioUrl.BGM);
          }
          let gdManager = GameDataManager.instance;
          gdManager.updateLoginDayNum(TimeAgent.instance.getTime());
          let data = gdManager.data;
          this.lblLv.string = `Level\n${data.level}`;
          MountManager.instance.notify(MountPoint.NativeCheckLocalCache, null);
          if (GameDataManager.instance.sg.state === SgState.Started) {
            if (data.signInData.startTime === 0) {
              data.signInData.startTime = TimeAgent.instance.getTime();
            }
            if (data.lastLoginTime > 0) {
              this.gameDesk.startStage();
            } else {
              UIManager.instance.open(UIID.GuidePopup);
            }
          }
        }
        onTop(preID, ...args) {
          this.updateDisplay();
          let gdManager = GameDataManager.instance;
          console.log(`onTop-preID:${preID}`);
          switch (preID) {
            case UIID.SignInPopup:
            case UIID.GuidePopup:
              break;
            case UIID.VictoryPopupSg:
              break;
            case UIID.PictureSelectView:
              {
                if (gdManager.data.selectedSgPicture && this.bgId !== gdManager.data.selectedSgPicture.id) {
                  this.bgId = gdManager.data.selectedSgPicture.id;
                  let stage = director.getScene().getChildByName('Canvas').getComponent(Stage);
                  stage && stage.updateBg();
                  this.lblLv.string = `Level\n${GameDataManager.instance.data.level}`;
                }
                MountManager.instance.notify(MountPoint.NativeCheckLocalCache, null);
                if (RewardManager.instance.isShowRatingPopup()) {
                  gdManager.data.levelShowRating = gdManager.data.level;
                  gdManager.saveData();
                  UIManager.instance.open(UIID.RatingPopup);
                } else {
                  this.gameDesk.startStage();
                }
                return;
              }
            case UIID.RatingPopup:
              {
                this.gameDesk.startStage();
                return;
              }
            case UIID.RewardGetPopup:
              {
                let delay = 2;
                if (GameDataManager.instance.sg.state === SgState.Started) {
                  this.scheduleOnce(() => {
                    this.showPictureObtainPopup();
                  }, delay);
                }
                return;
              }
          }
        }
        onClose() {
          this.removeEventListeners();
        }
        addEventListeners() {
          director.on(GameEvent.SHOW_BTN, this.updateBottomLayout, this);
          director.on(GameEvent.STAGE, this.onGameStageChange, this);
          director.on(GameEvent.PLAY_VIDEO_AD, this.onPlayVideoAd, this);
          director.on(GameEvent.COLLECT_CARD, this.onCollectCardEvent, this);
          director.on(GameEvent.SHOW_TARGET_CARD, this.onShowTargetCard, this);
        }
        removeEventListeners() {
          director.off(GameEvent.SHOW_BTN, this.updateBottomLayout, this);
          director.off(GameEvent.STAGE, this.onGameStageChange, this);
          director.off(GameEvent.PLAY_VIDEO_AD, this.onPlayVideoAd, this);
          director.off(GameEvent.SHOW_TARGET_CARD, this.onShowTargetCard, this);
        }
        updateDisplay() {
          let gameDataMgr = GameDataManager.instance;
          let {
            toolMagicNum,
            toolUndoNum
          } = gameDataMgr.data;
          this.setMagicCount(toolMagicNum);
          this.setUndoCount(toolUndoNum);
          this.btnSkipLv.active = GmManager.instance.isSkipLv;
          let accountLayout = director.getScene().getChildByPath('Canvas/midLayer/LayoutTokenAccount');
          if (accountLayout) {
            accountLayout.active = true;
          }
        }
        setMagicCount(val) {
          let lbl = this.btnMagic.node.getChildByName('Bubble').getComponentInChildren(Label);
          lbl.string = val > 0 ? val.toString() : '+';
        }
        setUndoCount(val) {
          let lbl = this.btnUndo.node.getChildByName('Bubble').getComponentInChildren(Label);
          lbl.string = val > 0 ? val.toString() : '+';
        }
        updateBottomLayout(param) {
          if (this.bottomLayout === param) {
            return;
          }
          this.bottomLayout = param;
          this.btnIllustration.active = this.bottomLayout == ParamShowBtn.HIDE;
          this.btnThemes.node.active = this.bottomLayout == ParamShowBtn.HIDE;
          this.btnHome.node.active = this.bottomLayout == ParamShowBtn.HIDE;
          if (this.bottomLayout == ParamShowBtn.SHOW_AUTO) {
            this.onBtnAutoSolve();
          }
          this.btnEndGame.node.active = this.bottomLayout == ParamShowBtn.SHOW_END;
        }
        onGameStageChange(param, isNextStage = false) {
          let gdManager = GameDataManager.instance;
          switch (param) {
            case ParamStage.START:
              {
                this.timer.startCountUp();
                if (GameDataManager.instance.sg.state === SgState.Started) {
                  this.preloadGraphFrame();
                }
              }
              break;
            case ParamStage.WIN:
              {
                this.timer.stopCountUp();
                let score = this.timer.getCurrentTime();
                ReportAgent.reportCustomEvent(CustomReportEvent.LEVEL_UPGRADE, {
                  compsteps: '2',
                  extranum: gdManager.data.level,
                  comptime: score,
                  Compnum: 0
                });
                if (GameDataManager.instance.data.firstGameAction.win_stage) {
                  GameDataManager.instance.data.firstGameAction.win_stage = false;
                  ReportAgent.reportCustomEvent(CustomReportEvent.USER_LIFECYCLE_MILESTONE, {
                    action: 'level_win_term_first'
                  });
                }
                gdManager.data.targetCard = null;
                gdManager.data.level++;
                gdManager.data.gamesPlayed++;
                gdManager.data.gamesWon++;
                gdManager.data.winPencent = parseFloat((gdManager.data.gamesWon / gdManager.data.gamesPlayed).toFixed(2));
                if (score < gdManager.data.bestTime || gdManager.data.bestTime == 0) {
                  gdManager.data.bestTime = score;
                }
                gdManager.data.avgTime = parseFloat(((gdManager.data.avgTime * (gdManager.data.gamesWon - 1) + score) / gdManager.data.gamesWon).toFixed(2));
                if (++gdManager.data.curWinStreak > gdManager.data.maxWinStreak) {
                  gdManager.data.maxWinStreak = gdManager.data.curWinStreak;
                }
                let time = TimeAgent.instance.getTime();
                let curDate = new Date(time);
                let lastDate = new Date(gdManager.data.lastWinDate);
                if (curDate.toDateString() != lastDate.toDateString()) {
                  gdManager.data.lastWinDate = time;
                  MountManager.instance.notify(MountPoint.NativeNotifyProgressChange, {
                    actionType: ActionType.Play,
                    count: 1
                  });
                }
                UIManager.instance.open(UIID.VictoryPopupSg, {
                  score: score
                });
              }
              break;
            case ParamStage.FAIL:
              {
                this.timer.stopCountUp();
                gdManager.data.targetCard = null;
                gdManager.data.gamesPlayed++;
                gdManager.data.winPencent = parseFloat((gdManager.data.gamesWon / gdManager.data.gamesPlayed).toFixed(2));
                ReportAgent.reportCustomEvent(CustomReportEvent.LEVEL_UPGRADE, {
                  compsteps: '3',
                  extranum: gdManager.data.level,
                  comptime: this.timer.getCurrentTime(),
                  Compnum: 0
                });
                if (gdManager.data.curWinStreak > 0) {
                  this.gameDesk.startStage();
                } else {
                  isNextStage ? this.gameDesk.onGoNextStage() : this.gameDesk.startStage();
                }
              }
              break;
          }
          gdManager.saveData();
        }
        onShowTargetCard(isSpecial) {
          if (isSpecial) {
            let lbl = this.targetTips.getChildByName("LabelPoint").getComponent(Label);
            let cardData = GameDataManager.instance.data.targetCard;
            if (cardData) {
              switch (cardData.point) {
                case 1:
                  lbl.string = 'A';
                  break;
                case 11:
                  lbl.string = 'J';
                  break;
                case 12:
                  lbl.string = 'Q';
                  break;
                case 13:
                  lbl.string = 'K';
                  break;
                default:
                  {
                    lbl.string = `${cardData.point}`;
                  }
                  break;
              }
            }
          }
          this.targetTips.active = isSpecial;
        }
        onPlayVideoAd(count) {
          MountManager.instance.notify(MountPoint.NativeNotifyProgressChange, {
            actionType: ActionType.Ad,
            count: count
          });
          GameDataManager.instance.onPlayVideoAd(count);
        }
        onCollectCardEvent(num) {
          let gdMgr = GameDataManager.instance;
          let cfg = RewardManager.instance.getConfig();
          if (cfg) {
            let rewardNum = cfg.action.card_collect;
            gdMgr.addMinorToken(rewardNum * num);
          }
        }
        onMoreGameBtn() {
          this.onClickBtn();
          UIManager.instance.open(UIID.MoreGameView);
        }
        onHomeBtn() {
          this.onClickBtn();
          UIManager.instance.open(UIID.PausedPopupSg);
        }
        onBtnTheme() {
          this.onClickBtn();
          UIManager.instance.open(UIID.CardThemeView);
        }
        async onBtnMagic() {
          this.onClickBtn();
          let data = GameDataManager.instance.data;
          if (data.toolMagicNum > 0) {
            let result = await this.gameDesk.useToolMagic();
            if (result) {
              data.toolMagicNum--;
              this.setMagicCount(data.toolMagicNum);
            }
          } else {
            UIManager.instance.open(UIID.ItemObtainPopupSg, {
              itemId: ItemType.Magic
            });
          }
        }
        async onBtnUndo() {
          this.onClickBtn();
          let gdManager = GameDataManager.instance;
          if (gdManager.data.toolUndoNum > 0) {
            let result = await this.gameDesk.useToolUndo();
            if (result) {
              gdManager.data.toolUndoNum--;
              this.setUndoCount(gdManager.data.toolUndoNum);
            } else {
              UIManager.instance.showToast(`No step back`);
            }
          } else {
            UIManager.instance.open(UIID.ItemObtainPopupSg, {
              itemId: ItemType.Undo
            });
          }
        }
        onBtnAutoSolve() {
          this.onClickBtn();
          this.gameDesk.useToolAutoSolve();
          this.timer.stopCountUp();
        }
        onBtnEndGame() {
          this.onClickBtn();
          this.gameDesk.useToolEndGame();
        }
        onBtnIllustration() {
          this.onClickBtn();
          if (GameDataManager.instance.sg.state === SgState.Started) {
            // open illustration view
            UIManager.instance.open(UIID.IllustrationViewSg);
            let isOpenInter = false;
            let config = RewardManager.instance.getConfig();
            console.log(`config: ${config}`);
            if (config) {
              let info = config.ad.inter.page.tab_illustration;
              console.log(`info: ${JSON.stringify(info)}`);
              GameDataManager.instance.data.interAdWeight += info.weight;
              isOpenInter = info.is_play;
            }
            console.log(`isOpenInter: ${isOpenInter}`);
            if (isOpenInter) {
              AdManager.instance.openInterstitialAd('tab_illustration', null);
            }
          } else {
            UIManager.instance.open(UIID.IllustrationView);
          }
        }
        onBtnAlbum() {
          if (GameDataManager.instance.sg.state === SgState.Started) {
            // open album view
            UIManager.instance.open(UIID.AlbumView);
            let isOpenInter = false;
            let config = RewardManager.instance.getConfig();
            console.log(`config: ${config}`);
            if (config) {
              let info = config.ad.inter.page.tab_album;
              console.log(`info: ${JSON.stringify(info)}`);
              GameDataManager.instance.data.interAdWeight += info.weight;
              isOpenInter = info.is_play;
            }
            console.log(`isOpenInter: ${isOpenInter}`);
            if (isOpenInter) {
              AdManager.instance.openInterstitialAd('tab_album', null);
            }
          }
        }
        onBtnChapter() {
          this.onClickBtn();
          UIManager.instance.open(UIID.ChapterView);
        }
        onSkipLvBtn() {
          this.onGameStageChange(ParamStage.WIN);
        }
        onRFlagChanged() {
          this.updateDisplay();
        }
        onClickBtn() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
        }
        showPictureObtainPopup() {
          let picInfo = GameDataManager.instance.data.selectedSgPicture;
          if (!picInfo) {
            this.backToStart();
            return;
          }
          UIManager.instance.open(UIID.PictureObtainPopup, {
            albumId: null,
            picInfo: picInfo,
            showCloseBtn: true,
            isCloseDirectly: false
          });
          if (GameDataManager.instance.sg.state === SgState.Started) {
            GameDataManager.instance.data.selectedSgPicture = null;
          }
        }
        backToStart() {
          UIManager.instance.closeAll();
          if (GameDataManager.instance.sg.state === SgState.Started) {
            director.loadScene('map-sg');
          }
        }
        async preloadGraphFrame() {
          let gdMgr = GameDataManager.instance;
          if (!gdMgr.specialRewardInfo) {
            gdMgr.specialRewardInfo = gdMgr.getAvailablePictureList(1, false, gdMgr.data.selectedSgPicture)[0];
            if (!gdMgr.specialRewardInfo) {
              gdMgr.specialRewardInfo = gdMgr.getAvailablePictureList(1, true, gdMgr.data.selectedSgPicture)[0];
            }
          }
          if (gdMgr.specialRewardInfo) {
            // special A_s
            LoadingManager.instance.loadGraph(gdMgr.specialRewardInfo, 4, false, LoadingTaskType.SPECIAL_B);
            LoadingManager.instance.loadGraph(gdMgr.specialRewardInfo, 4, true, LoadingTaskType.SPECIAL_A);
          }

          // special B_s
          if (gdMgr.data.selectedSgPicture) {
            LoadingManager.instance.loadGraph(gdMgr.data.selectedSgPicture, 4, false, LoadingTaskType.LEVEL_WIN_B);
            LoadingManager.instance.loadGraph(gdMgr.data.selectedSgPicture, 4, false, LoadingTaskType.LEVEL_WIN_A);
          }

          // selected A_t
          MountManager.instance.notify(MountPoint.NativeCheckLocalCache, null);
        }
        onContactBtn() {
          this.onClickBtn();
          let now = new Date(TimeAgent.instance.getTime());
          let sid = GameDataManager.instance.getPlayerSid();
          let title = `【De-Stress Solitaire】Feedback and Suggestions`;
          let content = `Please enter your feedback or problems!\nWe will respond and handle them quickly!\nVersion:${Config.GAME_VERSION} / ${GameDataManager.instance.getInviteCode()} / ${sid}`;
          BridgeUtil.sendMail(Config.MAIL, title, content);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "btnThemes", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "btnMagic", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "btnUndo", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "btnAutoSolve", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "btnEndGame", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "btnHome", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "timer", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "btnSkipLv", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "lblLv", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "targetTips", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "btnIllustration", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "btnAlbum", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/http-agent.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "673d7lmwFdJ6rhuSagoe8Up", "http-agent", undefined);
      class HttpError extends Error {
        get status() {
          var _this$response;
          return ((_this$response = this.response) == null ? void 0 : _this$response.status) || 0;
        }
        get statusText() {
          var _this$response2;
          return ((_this$response2 = this.response) == null ? void 0 : _this$response2.statusText) || '';
        }
        get headers() {
          var _this$response3;
          return ((_this$response3 = this.response) == null ? void 0 : _this$response3.headers) || null;
        }
        constructor(...args) {
          if (args.length == 1) {
            super(args[0]);
            this.response = void 0;
          } else if (args.length == 2) {
            if (args[1] instanceof Response) {
              super(args[0]);
              this.response = void 0;
              this.response = args[1];
            } else {
              super(args[1]);
              this.response = void 0;
              this.name = args[0];
            }
          } else {
            super(args[1]);
            this.response = void 0;
            this.name = args[0];
            this.response = args[2];
          }
          console.error('HttpError:', this.name, this.message, this.response);
        }
      }
      exports('HttpError', HttpError);
      HttpError.TIMEOUT = 'TIMEOUT';
      HttpError.ABORT_TIMEOUT = 'ABORT_TIMEOUT';
      HttpError.NETWORK_ERROR = 'NETWORK_ERROR';
      HttpError.UNKNOWN = 'UNKNOWN';
      class HttpAgent {
        static async request(url, method, headers, timeout = 0, params) {
          const promises = [];
          let timeoutHandle = 0;
          if (timeout > 0) {
            const timeoutPromise = new Promise((_, reject) => {
              if (timeout > 0) {
                timeoutHandle = setTimeout(() => {
                  timeoutHandle = 0;
                  reject(new HttpError(HttpError.TIMEOUT, `Request timed out after ${timeout / 1000}s`));
                }, timeout);
              }
            });
            promises.push(timeoutPromise);
          }
          const fetchPromise = fetch(url, {
            // signal: signal,
            cache: 'no-store',
            // 或 'reload'
            method: method,
            headers: headers,
            body: params ? JSON.stringify(params) : undefined
          }).then(response => {
            if (timeoutHandle > 0) {
              clearTimeout(timeoutHandle);
              timeoutHandle = 0;
            }
            if (!response.ok) {
              throw new HttpError(HttpError.NETWORK_ERROR, response.statusText, response);
            }
            const contentType = response.headers.get('Content-Type');
            if (contentType && contentType.includes('application/json')) {
              return response.json();
            } else {
              return response.text();
            }
          }).catch(error => {
            if (timeoutHandle > 0) {
              clearTimeout(timeoutHandle);
              timeoutHandle = 0;
            }
            if (error instanceof HttpError) {
              return Promise.reject(error);
            }
            const message = error instanceof Error ? error.message : String(error);
            return Promise.reject(new HttpError(HttpError.NETWORK_ERROR, message));
          });
          promises.push(fetchPromise);
          return Promise.race(promises).catch(error => {
            return Promise.reject(error);
          });
        }
      }
      exports('HttpAgent', HttpAgent);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/i18n-agent.ts", ['cc', './log-util.ts'], function (exports) {
  var cclegacy, resources, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      resources = module.resources;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      cclegacy._RF.push({}, "84f7b8/5XhOvZ1Qapw5/R5C", "i18n-agent", undefined);
      class i18n {
        static t(param) {
          if (i18nAgent._current && i18nAgent._current[param]) {
            return i18nAgent._current[param];
          } else {
            LogUtil.warn('i18nAgent: not found key:', param);
          }
          return param;
        }
      }
      exports('i18n', i18n);
      class i18nAgent {
        static loadLangJson() {
          return new Promise((resolve, reject) => {
            resources.load("json/i18n", (err, asset) => {
              if (err) {
                console.error(err);
                reject(err);
                return;
              }
              this._rawAsset = asset;
              asset.addRef();
              LogUtil.log('preload json:', asset.json);
              resolve();
            });
          });
        }
        static setLangCode(code) {
          if (this._langList.indexOf(code) >= 0) {
            this._langCode = code;
          }
          this._current = this._rawAsset.json[this._langCode];
          LogUtil.log('setLangCode:', this._langCode, this._current);
        }
      }
      exports('i18nAgent', i18nAgent);
      i18nAgent._rawAsset = null;
      i18nAgent._current = null;
      i18nAgent._langCode = 'en';
      i18nAgent._langList = ['en', 'es', 'fr', 'de', 'it', 'ja', 'ko', 'pt', 'ru'];
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/i18n-label.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './i18n-agent.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, _decorator, Component, Label, i18n;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
      Label = module.Label;
    }, function (module) {
      i18n = module.i18n;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "8b49fXwfFFG5pXE2rtSBL9C", "i18n-label", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let i8nLabel = exports('i8nLabel', (_dec = ccclass('i8nLabel'), _dec2 = property(String), _dec3 = property(Boolean), _dec(_class = (_class2 = class i8nLabel extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "key", _descriptor, this);
          _initializerDefineProperty(this, "freshOnEnable", _descriptor2, this);
        }
        onLoad() {
          this.updateLabel();
        }
        onEnable() {
          if (this.freshOnEnable) {
            this.updateLabel();
          }
        }
        updateLabel() {
          if (this.key) {
            this.getComponent(Label).string = i18n.t(this.key);
          }
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "key", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "freshOnEnable", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return false;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/illustraion-item.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './res-util.ts', './ui-manager.ts', './ui-config.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, Sprite, _decorator, Component, SpriteFrame, ResUtil, UIManager, UIID;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      Sprite = module.Sprite;
      _decorator = module._decorator;
      Component = module.Component;
      SpriteFrame = module.SpriteFrame;
    }, function (module) {
      ResUtil = module.ResUtil;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      UIID = module.UIID;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "de095vw+EFI0a4wx7vQ4M4B", "illustraion-item", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let IllustraionItem = exports('IllustraionItem', (_dec = ccclass('IllustraionItem'), _dec2 = property(Node), _dec3 = property(Sprite), _dec(_class = (_class2 = class IllustraionItem extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "favorite", _descriptor, this);
          _initializerDefineProperty(this, "pic", _descriptor2, this);
          this.url = '';
        }
        init(url, data) {
          this.url = url;
          ResUtil.load(this.pic.node, url, SpriteFrame, (err, frame) => {
            if (err) {
              console.error(err);
            } else {
              this.pic.spriteFrame = frame;
            }
          });
          this.isFavorite = data.isFavorite;
        }
        set isFavorite(val) {
          this.favorite.active = val;
        }
        get isFavorite() {
          return this.favorite.active;
        }
        onClickItem() {
          UIManager.instance.open(UIID.PictureView, this.url);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "favorite", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "pic", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/item-get-popup.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './reward-type-define.ts', './game-data-manager.ts', './res-loader.ts', './audio-manager.ts', './game-constants.ts', './res-util.ts', './bridge-util.ts', './game-data-type-define.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Sprite, SpriteFrame, Node, Label, _decorator, UITransform, director, UIView, ItemType, GameDataManager, resLoader, AudioManager, AudioUrl, GameEvent, ResUtil, BridgeUtil, VibrationEffect, SgState;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Sprite = module.Sprite;
      SpriteFrame = module.SpriteFrame;
      Node = module.Node;
      Label = module.Label;
      _decorator = module._decorator;
      UITransform = module.UITransform;
      director = module.director;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      ItemType = module.ItemType;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      resLoader = module.resLoader;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      AudioUrl = module.AudioUrl;
      GameEvent = module.GameEvent;
    }, function (module) {
      ResUtil = module.ResUtil;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }, function (module) {
      SgState = module.SgState;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;
      cclegacy._RF.push({}, "15a36yqr0ROFK3JRvsDPEw9", "item-get-popup", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let ItemGetPopup = exports('ItemGetPopup', (_dec = ccclass('ItemGetPopup'), _dec2 = property(Sprite), _dec3 = property([SpriteFrame]), _dec4 = property(Sprite), _dec5 = property(Node), _dec6 = property(Node), _dec7 = property(Label), _dec(_class = (_class2 = class ItemGetPopup extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "sprtTitle", _descriptor, this);
          _initializerDefineProperty(this, "sprtTitleFrames", _descriptor2, this);
          _initializerDefineProperty(this, "sprtItem", _descriptor3, this);
          _initializerDefineProperty(this, "tokenMajor", _descriptor4, this);
          _initializerDefineProperty(this, "tokenMinor", _descriptor5, this);
          _initializerDefineProperty(this, "lblNum", _descriptor6, this);
          this.popupArgs = void 0;
        }
        onOpen(fromUI, ...args) {
          AudioManager.instance.playEffect(AudioUrl.SHOW_ITEM_GET);
          BridgeUtil.vibrate(30, VibrationEffect.CLICK);
          this.popupArgs = args[0];
          let itemId = this.popupArgs.itemId;

          //title
          // this.sprtTitle.spriteFra me = itemId > 1? this.sprtTitleFrames[1] : this.sprtTitleFrames[0];

          if (GameDataManager.instance.sg.state === SgState.Started) {
            resLoader.load('bundle-sg', `texture/reward/item-icon/item-${itemId}/spriteFrame`, (err, frame) => {
              this.sprtItem.spriteFrame = frame;
              ResUtil.assignWith(frame, this.node, true);
            });
          }
          switch (itemId) {
            case ItemType.Magic:
            case ItemType.Undo:
              {
                this.tokenMajor.active = false;
                this.tokenMinor.active = false;
                this.lblNum.string = `x${this.popupArgs.amount}`;
              }
              break;
            case ItemType.MajorToken:
              {
                this.tokenMajor.active = true;
                this.tokenMinor.active = false;
                this.lblNum.string = `${GameDataManager.instance.getCurrency()}${this.popupArgs.amount}`;
              }
              break;
            case ItemType.MinorToken:
              {
                this.tokenMajor.active = false;
                this.tokenMinor.active = true;
                this.lblNum.string = `x${this.popupArgs.amount}`;
              }
              break;
          }
        }
        onClose() {
          let gdMgr = GameDataManager.instance;
          let node = this.sprtItem.node;
          let startPos = node.parent.getComponent(UITransform).convertToWorldSpaceAR(node.position);
          switch (this.popupArgs.itemId) {
            case ItemType.Magic:
              {
                director.emit(GameEvent.ITEM_GAIN_ANIM, startPos, 1, ItemType.Magic);
              }
              break;
            case ItemType.Undo:
              {
                director.emit(GameEvent.ITEM_GAIN_ANIM, startPos, 1, ItemType.Undo);
              }
              break;
            case ItemType.MajorToken:
              {
                gdMgr.addMajorToken(this.popupArgs.amount);
                director.emit(GameEvent.ITEM_GAIN_ANIM, startPos, 10, ItemType.MajorToken);
              }
              break;
            case ItemType.MinorToken:
              {
                gdMgr.addMinorToken(this.popupArgs.amount);
                director.emit(GameEvent.ITEM_GAIN_ANIM, startPos, 10, ItemType.MinorToken);
              }
              break;
          }
          GameDataManager.instance.saveData(true);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "sprtTitle", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "sprtTitleFrames", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "sprtItem", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "tokenMajor", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "tokenMinor", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "lblNum", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/item-obtain-popup.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './res-loader.ts', './game-data-manager.ts', './ui-manager.ts', './reward-manager.ts', './reward-type-define.ts', './ui-config.ts', './audio-manager.ts', './game-constants.ts', './res-util.ts', './mount-manager.ts', './mount-point.ts', './log-util.ts', './report-agent.ts', './ad-manager.ts', './bridge-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Sprite, Node, Label, _decorator, RichText, ProgressBar, UIView, resLoader, GameDataManager, UIManager, RewardManager, ItemType, UIID, AudioManager, AudioUrl, ResUtil, MountManager, MountPoint, LogUtil, ReportAgent, CustomReportEvent, AdManager, BridgeUtil, VibrationEffect;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Sprite = module.Sprite;
      Node = module.Node;
      Label = module.Label;
      _decorator = module._decorator;
      RichText = module.RichText;
      ProgressBar = module.ProgressBar;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      resLoader = module.resLoader;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      RewardManager = module.RewardManager;
    }, function (module) {
      ItemType = module.ItemType;
    }, function (module) {
      UIID = module.UIID;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      AudioUrl = module.AudioUrl;
    }, function (module) {
      ResUtil = module.ResUtil;
    }, function (module) {
      MountManager = module.MountManager;
    }, function (module) {
      MountPoint = module.MountPoint;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
    }, function (module) {
      AdManager = module.AdManager;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6;
      cclegacy._RF.push({}, "5aa1aXZKhpBWY1Vszz0m3SC", "item-obtain-popup", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let ItemObtainPopup = exports('ItemObtainPopup', (_dec = ccclass('ItemObtainPopup'), _dec2 = property(Sprite), _dec3 = property(Node), _dec4 = property(Node), _dec5 = property(Label), _dec6 = property(Label), _dec7 = property(Node), _dec(_class = (_class2 = class ItemObtainPopup extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "sprtItem", _descriptor, this);
          _initializerDefineProperty(this, "layout1", _descriptor2, this);
          _initializerDefineProperty(this, "layout2", _descriptor3, this);
          _initializerDefineProperty(this, "lblItemAount", _descriptor4, this);
          _initializerDefineProperty(this, "lblPrice", _descriptor5, this);
          _initializerDefineProperty(this, "btnClaim2", _descriptor6, this);
          this.itemId = 0;
          this.amount = 0;
        }
        onOpen(fromUI, ...args) {
          AudioManager.instance.playEffect(AudioUrl.SHOW_ITEM_OBTAIN);
          BridgeUtil.vibrate(30, VibrationEffect.CLICK);
          let data = args[0];
          this.itemId = data.itemId;

          // item
          // if (this.itemId == ItemType.MajorToken) {
          //     //card
          //     let card = GameDataManager.instance.getMajorTokenType();
          //     resLoader.load(`textures/token-major/small/card-${card}/spriteFrame`, (err, frame) => {
          //         this.sprtItem.spriteFrame = frame;
          //         ResUtil.assignWith(frame, this.node, true);
          //     });
          // }else{

          // }

          resLoader.load(`textures/ui/reward/item-icon/item-${this.itemId}/spriteFrame`, (err, frame) => {
            this.sprtItem.spriteFrame = frame;
            ResUtil.assignWith(frame, this.node, true);
          });

          // layout
          if (this.itemId > 1) {
            this.layout1.active = true;
            this.layout2.active = false;
            this.initLayout1();
          } else {
            this.layout2.active = true;
            this.layout1.active = false;
            this.initLayout2();
          }
          this.reportAdBtnEvent(false);
        }
        initLayout1() {
          let lblDesc = this.layout1.getChildByName(`LabelDesc`).getComponent(Label);
          let config = RewardManager.instance.getConfig().tool;
          switch (this.itemId) {
            case ItemType.Magic:
              {
                lblDesc.string = 'Use it to move the lowest number card at the card deck or line area to [foundation]!';
                this.lblPrice.string = `${config.magic.price_by_minor}`;
                this.lblItemAount.string = `x${config.magic.paid_amount}`;
              }
              break;
            case ItemType.Undo:
              {
                lblDesc.string = 'Use it to undo the last move!';
                this.lblPrice.string = `${config.undo.price_by_minor}`;
                this.lblItemAount.string = `x${config.undo.paid_amount}`;
              }
              break;
          }
        }
        onBtnWatchAd() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          this.reportAdBtnEvent(true);
          AdManager.instance.openVideoAd('ItemObtainPopup', (entry, success) => {
            success && this.onObtainToolSuccess();
          });
        }
        onBtnPay() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          let gdMgr = GameDataManager.instance;
          let account = gdMgr.getMinorToken();
          let rewardMgr = RewardManager.instance;
          let price = RewardManager.instance.getToolPrice(this.itemId);
          if (account > price) {
            gdMgr.addMinorToken(0 - price);
            this.scheduleOnce(this.onObtainToolSuccess, 0.5);
          } else {
            UIManager.instance.showToast("Your current balance is insufficient.");
          }
        }
        onObtainToolSuccess() {
          let gdMgr = GameDataManager.instance;
          let rewardMgr = RewardManager.instance;
          switch (this.itemId) {
            case ItemType.Magic:
              {
                gdMgr.data.toolMagicNum += rewardMgr.getToolNum(ItemType.Magic, false);
              }
              break;
            case ItemType.Undo:
              {
                gdMgr.data.toolUndoNum += rewardMgr.getToolNum(ItemType.Undo, false);
              }
              break;
          }
          UIManager.instance.close(this);
          let data = {
            itemId: this.itemId,
            amount: rewardMgr.getToolNum(this.itemId, false)
          };
          UIManager.instance.open(UIID.ItemGetPopupSg, data);
        }
        initLayout2() {
          let layoutRewardNum = this.layout2.getChildByName('LayoutRewardNum');
          let coin = layoutRewardNum.getChildByName('Coin');
          let card = layoutRewardNum.getChildByName('Card');
          let lblNum = layoutRewardNum.getComponentInChildren(Label);
          let lblDesc = this.layout2.getChildByName('LabelDesc').getComponent(RichText);
          let progress = this.layout2.getComponentInChildren(ProgressBar);
          this.amount = RewardManager.instance.getRewardAmountWithItemId(this.itemId) / 2;
          this.amount = parseFloat(this.amount.toFixed(2));
          switch (this.itemId) {
            case ItemType.MajorToken:
              {
                coin.active = false;
                card.active = true;
                let cur = GameDataManager.instance.getCurrency();
                lblNum.string = `${cur}${this.amount}`;
                let account = GameDataManager.instance.getMajorToken();
                let amountList = MountManager.instance.notify(MountPoint.NativeNotifyRedeemAount, null);
                let total = 0;
                if (amountList.length > 0) {
                  total = amountList[0];
                } else {
                  LogUtil.error('ItemObtainPopup-initLayout2, get nextRedeemAmount Error');
                }
                let diff = total - account - this.amount;
                if (diff > 0) {
                  //show progress
                  progress.node.active = true;
                  progress.progress = 1 - diff / total;
                  progress.getComponentInChildren(Label).string = `${(total - diff).toFixed(2)}/${total}`;
                  lblDesc.node.active = true;
                  lblDesc.string = `Collect more <color=#FF0000>${diff.toFixed(2)}</color> to redeem gift card`;
                } else {
                  progress.node.active = false;
                  lblDesc.node.active = false;
                }
              }
              break;
            case ItemType.MinorToken:
              {
                coin.active = true;
                card.active = false;
                lblNum.string = `X ${this.amount}`;
                progress.node.active = false;
                lblDesc.node.active = true;
                lblDesc.string = `Collect more Coin to redeem gift card`;
              }
              break;
          }
        }
        onBtnClaim1() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          this.reportAdBtnEvent(true);

          // play ad video
          AdManager.instance.openVideoAd('ItemObtainPopup', (entry, success) => {
            if (success) {
              this.onObtainTokenSuccess(true);
            }
          });
        }
        onBtnClaim2() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          this.scheduleOnce(() => {
            this.onObtainTokenSuccess(false);
          }, 0.5);
        }
        onObtainTokenSuccess(isDouble) {
          UIManager.instance.close(this);
          let data = {
            itemId: this.itemId,
            amount: this.amount * (isDouble ? 2 : 1)
          };
          UIManager.instance.open(UIID.ItemGetPopupSg, data);
        }
        onCloseBtn() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          UIManager.instance.close(this);
        }
        reportAdBtnEvent(isClick) {
          let page = '';
          switch (this.itemId) {
            case ItemType.MajorToken:
              page = 'lucky_cards';
              break;
            case ItemType.MinorToken:
              page = 'lucky_coins';
              break;
            case ItemType.Magic:
              page = 'magic_prop';
              break;
            case ItemType.Undo:
              page = 'undo_prop';
              break;
          }
          if (page !== '') {
            if (isClick) {
              ReportAgent.reportCustomEvent(CustomReportEvent.AD_EVENT_DISTRIBUTED, {
                reward_page_click: page
              });
            } else {
              ReportAgent.reportCustomEvent(CustomReportEvent.AD_EVENT_DISTRIBUTED, {
                reward_page_show: page
              });
            }
          }
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "sprtItem", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "layout1", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "layout2", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "lblItemAount", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "lblPrice", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "btnClaim2", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/KENOHXMVJJSH.ts", ['cc', './SVDMRMIFJDYHRX.ts', './PQBRALKRA.ts', './AQKTRMDQJQQBTDC.ts', './WBKIRV.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, PQBRALKRA, AQKTRMDQJQQBTDC, PSWZDFV;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      PQBRALKRA = module.PQBRALKRA;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      PSWZDFV = module.PSWZDFV;
    }],
    execute: function () {
      cclegacy._RF.push({}, "c4f4az36KFLRK7wDPbx5dwU", "KENOHXMVJJSH", undefined);
      class KENOHXMVJJSH extends SVDMRMIFJDYHRX {
        constructor(...args) {
          super(...args);
          this.PMXFKTRKLKUEVKLE = void 0;
          // 可订阅的商品信息
          this.HZYXBZZCPQQBMT = [];
          // 已经内购的订单信息
          this.AWDIHT = [];
          // 可订阅的商品
          this.IXXUJYGWCF = [];
          // 已经订阅的订单信息
          this.ZFBETVBESZU = [];
          this.ZODOIGROFDROP = false;
          this.KXPGUGKFMZCVTIX = false;
          this.LAMGJA = false;
          this.ZYVIYFGRA = false;
        }
        TGQXAKDAHFFVG() {
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.WQVUMO, this.WQVUMO, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.ONGWOOBCA, this.ONGWOOBCA, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.GVZGWMMHXJEWOSEP, this.GVZGWMMHXJEWOSEP, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.UVNOCVGJE, this.UVNOCVGJE, this);
        }
        QIZLFVUQ() {}
        UQXLUYM(PYGPRHHLLOGJEROQ) {
          this.PMXFKTRKLKUEVKLE = PYGPRHHLLOGJEROQ;
        }
        GMKDDMWDSNPUI() {
          if (PQBRALKRA.OTORTMMYVD) {
            return false;
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().GMKDDMWDSNPUI();
        }
        RRUWUVYQ(XNFWLZDKNEA) {
          if (PQBRALKRA.OTORTMMYVD) {
            return false;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().RRUWUVYQ(XNFWLZDKNEA);
        }

        /**
         * 调出 订阅/内购 购买界面
         * @param WFWKYY, [内购/订阅]商品id
         * @param HMESZBR 自定义id
         * @constructor
         */
        MSNKSNM(WFWKYY, HMESZBR = "") {
          if (PQBRALKRA.OTORTMMYVD) {
            return false;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().MSNKSNM(WFWKYY, HMESZBR);
        }

        /**
         * 调出 订阅优惠  购买界面
         * @param WFWKYY, [内购/订阅]商品id
         * @param HMESZBR 自定义id
         * @param ZMRFXFMBU 优惠计划id
         * @param RKEKGN 优惠阶段id
         * @constructor
         */
        VAUYGPMBKOFFKTU(WFWKYY, HMESZBR = "", ZMRFXFMBU, RKEKGN) {
          if (PQBRALKRA.OTORTMMYVD) {
            return false;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().VAUYGPMBKOFFKTU(WFWKYY, HMESZBR, ZMRFXFMBU, RKEKGN);
        }
        WQVUMO(ICLLMTBOICCIAPM) {
          // console.log(`onBillingIapItemDetails...`);
          let list = [];
          try {
            // var result = this.ZYSDBZW(ICLLMTBOICCIAPM)
            if (ICLLMTBOICCIAPM != null) {
              list = JSON.parse(ICLLMTBOICCIAPM);
            }
          } catch (e) {}
          this.HZYXBZZCPQQBMT = list;
          // if (list != null && list.length > 0) {
          //     console.log(`onBillingIapItemDetails  id ${list[0].id}`);
          // }
          if (this.PMXFKTRKLKUEVKLE != null) {
            this.PMXFKTRKLKUEVKLE.WQVUMO(list);
            this.ZODOIGROFDROP = false;
          } else {
            this.ZODOIGROFDROP = true;
          }
        }
        ONGWOOBCA(ICLLMTBOICCIAPM) {
          // console.log(`onBillingIapUnconsumedItemUpdated... `);
          // this.SdkLog(`${this.TAG} onBillingIapUnconsumedItemUpdated... ${args}`);
          let list = [];
          try {
            // var result = this.ZYSDBZW(ICLLMTBOICCIAPM)
            if (ICLLMTBOICCIAPM != null) {
              list = JSON.parse(ICLLMTBOICCIAPM);
            }
          } catch (e) {
            console.log("IapUnconsumed json parse error");
          }
          this.AWDIHT = list;
          if (this.PMXFKTRKLKUEVKLE != null) {
            this.PMXFKTRKLKUEVKLE.ONGWOOBCA(list);
            this.KXPGUGKFMZCVTIX = false;
          } else {
            this.KXPGUGKFMZCVTIX = true;
          }
        }

        // ZYSDBZW(input: string): string {
        //         // 将 Base64 转换回原始字符串
        //         return decodeURIComponent(escape(atob(input)));
        // }

        GVZGWMMHXJEWOSEP(ICLLMTBOICCIAPM) {
          //console.log(`onBillingSubscribeItemDetails...`+ ICLLMTBOICCIAPM);
          // this.SdkLog(`${this.TAG} onBillingSubscribeItemDetails...${args}`);
          let list = [];
          try {
            // var result = this.ZYSDBZW(ICLLMTBOICCIAPM)
            if (ICLLMTBOICCIAPM != null) {
              list = JSON.parse(ICLLMTBOICCIAPM);
            }
          } catch (e) {}
          this.IXXUJYGWCF = list;
          if (this.PMXFKTRKLKUEVKLE != null) {
            this.PMXFKTRKLKUEVKLE.GVZGWMMHXJEWOSEP(list);
            this.LAMGJA = false;
          } else {
            this.LAMGJA = true;
          }
        }
        UVNOCVGJE(ICLLMTBOICCIAPM) {
          // console.log(`onBillingSubscribeUpdated...`);
          // this.SdkLog(`${this.TAG} onBillingSubscribeUpdated...${args}`);
          let list = [];
          try {
            // var result = this.ZYSDBZW(ICLLMTBOICCIAPM)
            if (ICLLMTBOICCIAPM != null) {
              list = JSON.parse(ICLLMTBOICCIAPM);
            }
          } catch (e) {}
          this.ZFBETVBESZU = list;
          if (this.PMXFKTRKLKUEVKLE != null) {
            this.PMXFKTRKLKUEVKLE.UVNOCVGJE(list);
            this.ZYVIYFGRA = false;
          } else {
            this.ZYVIYFGRA = true;
          }
        }
      }
      exports('KENOHXMVJJSH', KENOHXMVJJSH);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/layout-tableau.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './card-constants.ts', './card.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, _decorator, Component, UITransform, Vec3, Rect, CardPoint, CardConstants, Card;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      _decorator = module._decorator;
      Component = module.Component;
      UITransform = module.UITransform;
      Vec3 = module.Vec3;
      Rect = module.Rect;
    }, function (module) {
      CardPoint = module.CardPoint;
      CardConstants = module.CardConstants;
    }, function (module) {
      Card = module.Card;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "663871/57tJXbtp/AAdI8xh", "layout-tableau", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let LayoutTableau = exports('LayoutTableau', (_dec = ccclass('LayoutTableau'), _dec2 = property(Node), _dec(_class = (_class2 = class LayoutTableau extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "container", _descriptor, this);
        }
        start() {}
        update(deltaTime) {}
        clear() {
          this.container.removeAllChildren();
        }
        getLastCard() {
          const childNodes = this.container.children;
          if (childNodes.length > 0) {
            const lastCard = childNodes[childNodes.length - 1];
            return lastCard;
          }
          return null;
        }
        canMatch(card) {
          const currentLayoutName = card.getComponent(Card).tag;
          if (currentLayoutName == this.node.name) {
            return false;
          }
          const cardData = card.getComponent(Card).cardData;
          const lastCard = this.getLastCard();
          if (!lastCard) {
            return cardData.point == CardPoint.King;
          }
          const lastCardData = lastCard.getComponent(Card).cardData;
          return cardData.matchLessThan(lastCardData);
        }
        getCardPositionY(offsetY) {
          const layoutHeight = this.getComponent(UITransform).height;
          const y = layoutHeight * 0.5 - CardConstants.CardHeight * 0.5 - offsetY;
          return y;
        }
        calcCardsHeight() {
          const cardCount = this.container.children.length;
          if (cardCount == 0) {
            return CardConstants.CardHeight;
          }
          let offset = 0;
          for (let i = 0; i < cardCount - 1; i++) {
            const card = this.container.children[i];
            const cardComponent = card.getComponent(Card);
            if (cardComponent.isCovered) {
              offset += CardConstants.CardTopOffsetCovered;
            } else {
              offset += CardConstants.CardTopOffsetUnCovered;
            }
          }
          const layoutHeight = CardConstants.CardHeight + offset;
          return layoutHeight;
        }
        getCardsWorldRect() {
          const wrapSize = this.getComponent(UITransform).contentSize;
          const realHeight = this.calcCardsHeight();
          var leftBottom = new Vec3(0, wrapSize.height - realHeight, 0);
          var leftBottom = this.getComponent(UITransform).convertToWorldSpaceAR(leftBottom).subtract(new Vec3(wrapSize.width * 0.5, wrapSize.height * 0.5, 0));
          return new Rect(leftBottom.x, leftBottom.y, this.getComponent(UITransform).width, realHeight);
        }
        getCardNodesInChain(cardNode) {
          const cardNodes = [];
          const currentIndex = this.container.children.indexOf(cardNode);
          if (currentIndex == -1) {
            throw new Error('cardNode is not in the container');
          }
          for (let i = currentIndex; i < this.container.children.length; i++) {
            const card = this.container.children[i];
            cardNodes.push(card);
          }
          return cardNodes;
        }
        getAllCards() {
          return this.container.children;
        }
        getPrevCard(cardNode) {
          const currentIndex = this.container.children.indexOf(cardNode);
          if (currentIndex == -1) {
            throw new Error('cardNode is not in the container');
          }
          if (currentIndex == 0) {
            return null;
          }
          return this.container.children[currentIndex - 1];
        }
      }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "container", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/LIGHOZ.ts", ['cc', './SVDMRMIFJDYHRX.ts', './WBKIRV.ts', './PZCMUYBUB.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, PSWZDFV, PZCMUYBUB;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      PSWZDFV = module.PSWZDFV;
    }, function (module) {
      PZCMUYBUB = module.PZCMUYBUB;
    }],
    execute: function () {
      cclegacy._RF.push({}, "f8a3b1pRahN6biT4ON+B7wW", "LIGHOZ", undefined);
      class LIGHOZ extends SVDMRMIFJDYHRX {
        constructor(...args) {
          super(...args);
          this.MHWGVOX = null;
          this.PACDIXBIRS = false;
          this.JDWTMRORCA = null;
          this.PZIHESOKERFKOGDI = false;
        }
        TGQXAKDAHFFVG() {
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.DHLOALGFTSBMQN, this.DHLOALGFTSBMQN, this);
        }
        QIZLFVUQ() {}
        DHLOALGFTSBMQN(ICLLMTBOICCIAPM) {
          try {
            this.JDWTMRORCA = PZCMUYBUB.MSCGDWEHBPVJEQE().ZYSDBZW(ICLLMTBOICCIAPM);
            // this.JDWTMRORCA = atob(ICLLMTBOICCIAPM);
            if (this.MHWGVOX != null) {
              this.MHWGVOX.DHLOALGFTSBMQN(this.JDWTMRORCA);
              this.PZIHESOKERFKOGDI = false;
            } else {
              this.PZIHESOKERFKOGDI = true;
            }
          } catch (e) {}
        }
        WACDGNFXPISMP(PYGPRHHLLOGJEROQ) {
          this.MHWGVOX = PYGPRHHLLOGJEROQ;
          if (this.PACDIXBIRS) {
            this.MHWGVOX.DHLOALGFTSBMQN(this.JDWTMRORCA);
          }
        }
      }
      exports('LIGHOZ', LIGHOZ);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/loading-anim.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Animation, _decorator, Component, director;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Animation = module.Animation;
      _decorator = module._decorator;
      Component = module.Component;
      director = module.director;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "b33a5wrNO9NG6bzM/r+6hLw", "loading-anim", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let LoadingAnimId = exports('LoadingAnimId', /*#__PURE__*/function (LoadingAnimId) {
        LoadingAnimId["Open"] = "loading-start-effect";
        LoadingAnimId["Loading"] = "loading-effect";
        LoadingAnimId["End"] = "loading-end-effect";
        return LoadingAnimId;
      }({}));
      const EVENT_LOADING_END_COMPLETED = exports('EVENT_LOADING_END_COMPLETED', 'eventLoadingEndCompleted');
      let LoadingAnim = exports('LoadingAnim', (_dec = ccclass('LoadingAnim'), _dec2 = property(Animation), _dec(_class = (_class2 = class LoadingAnim extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "anim", _descriptor, this);
        }
        onStartCompleted() {
          this.anim.play(LoadingAnimId.Loading);
        }
        onEndCompleted() {
          director.emit(EVENT_LOADING_END_COMPLETED);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "anim", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/loading-flow.ts", ['cc', './graph-manager.ts', './game-constants.ts', './game-data-manager.ts', './report-agent.ts'], function (exports) {
  var cclegacy, director, GraphManager, GameEvent, GameDataManager, LoadingTaskType, LoadingTaskReportInfo, LoadingTaskState, ReportAgent, CustomReportEvent;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
    }, function (module) {
      GraphManager = module.GraphManager;
    }, function (module) {
      GameEvent = module.GameEvent;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      LoadingTaskType = module.LoadingTaskType;
      LoadingTaskReportInfo = module.LoadingTaskReportInfo;
      LoadingTaskState = module.LoadingTaskState;
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
    }],
    execute: function () {
      cclegacy._RF.push({}, "1a129ti3opJuq0yoDRuROlY", "loading-flow", undefined);
      let FlowState = exports('FlowState', /*#__PURE__*/function (FlowState) {
        FlowState[FlowState["Loading"] = 0] = "Loading";
        FlowState[FlowState["Pause"] = 1] = "Pause";
        return FlowState;
      }({}));
      class LoadingTask {
        constructor(info, graphType, taskType) {
          this.taskType = LoadingTaskType.SELECT_A;
          this.info = null;
          this.graphType = 0;
          this.info = info;
          this.graphType = graphType;
          this.taskType = taskType;
        }
      }
      exports('LoadingTask', LoadingTask);
      class LoadingFlow {
        constructor() {
          this._state = FlowState.Pause;
          this._currentTask = null;
          this.taskQueue = [];
        }
        set state(value) {
          this._state = value;
        }
        get state() {
          return this._state;
        }
        updateForLoading() {
          if (this._currentTask == null && this.taskQueue.length > 0) {
            this.doLoading();
          }
        }
        async load(task) {
          let idx = this.taskQueue.indexOf(task);
          if (idx >= 0) return;
          this.taskQueue.push(task);
          if (this._state === FlowState.Loading && this._currentTask == null) {
            this.doLoading(task);
          }
        }
        async doLoading(task) {
          this._currentTask = this.taskQueue.shift();
          let taskInfo = new LoadingTaskReportInfo(this._currentTask.info.id, this._currentTask.taskType, LoadingTaskState.START, Date.now(), 0, GameDataManager.instance.data.level);
          ReportAgent.reportCustomEvent(CustomReportEvent.LOADING_GRAPH_TASK, taskInfo);
          let url = "";
          switch (this._currentTask.graphType) {
            case 2:
              url = this._currentTask.info.url_A_t;
              break;
            case 3:
              url = this._currentTask.info.url_A_s;
              break;
            case 4:
              url = this._currentTask.info.url_B_s;
              break;
          }
          console.log(`LoadingGraph-Start:${url}`);
          let spf = await GraphManager.instance.loadGraph(url);
          if (spf && spf.isValid) {
            taskInfo.state = LoadingTaskState.SUCCESS;
          } else {
            taskInfo.state = LoadingTaskState.FAIL;
          }
          let timeStamp = taskInfo.time_stamp;
          taskInfo.time_stamp = Date.now();
          taskInfo.duration = Math.floor((taskInfo.time_stamp - timeStamp) / 1000);
          setTimeout(() => {
            ReportAgent.reportCustomEvent(CustomReportEvent.LOADING_GRAPH_TASK, taskInfo);
          }, 100);
          director.emit(GameEvent.LOAD_GRAPH_COPMPLETED, this._currentTask);
          console.log(`LoadingGraph-End:${url}`);
          this._currentTask = null;
        }
      }
      exports('LoadingFlow', LoadingFlow);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/loading-manager.ts", ['cc', './game-constants.ts', './loading-flow.ts', './game-data-manager.ts'], function (exports) {
  var cclegacy, director, GameEvent, LoadingFlow, LoadingTask, FlowState, GameDataManager;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
    }, function (module) {
      GameEvent = module.GameEvent;
    }, function (module) {
      LoadingFlow = module.LoadingFlow;
      LoadingTask = module.LoadingTask;
      FlowState = module.FlowState;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }],
    execute: function () {
      cclegacy._RF.push({}, "f0302ON6r9P/o54vnNhNyZo", "loading-manager", undefined);
      class LoadingManager {
        constructor() {
          // 小图加载流
          this.flow_t = null;
          // 大图加载流
          this.flow_s = null;
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new LoadingManager();
            this._instance.init();
          }
          return this._instance;
        }
        init() {
          this.flow_t = new LoadingFlow();
          this.flow_s = new LoadingFlow();
          director.on(GameEvent.LOAD_GRAPH_COPMPLETED, this.onLoadGraphCompleted, this);
          setInterval(this.update.bind(this), 100);
        }
        loadGraph(info, type, isCover, taskType) {
          let task = null;
          switch (type) {
            case 2:
              {
                // 小图
                task = new LoadingTask(info, type, taskType);
                if (this.flow_s.state != FlowState.Loading) {
                  this.flow_t.state = FlowState.Loading;
                }
                this.flow_t.load(task);
              }
              break;
            case 3:
            case 4:
              {
                // 展示大图
                task = new LoadingTask(info, type, taskType);
                this.flow_s.state = FlowState.Loading;
                this.flow_t.state = FlowState.Pause;
                this.flow_s.load(task);
              }
              break;
          }
        }
        update() {
          if (this.flow_s.state === FlowState.Loading) {
            this.flow_s.updateForLoading();
          } else if (this.flow_t.state === FlowState.Loading) {
            this.flow_t.updateForLoading();
          }
        }
        onLoadGraphCompleted(task) {
          switch (task.graphType) {
            case 2:
              {
                let info = task.info;
                let gdMgr = GameDataManager.instance;
                if (info.isAd) {
                  let idx = gdMgr.sg.unselectedSpecialPicInfoList.findIndex(item => item.id == info.id);
                  if (idx == -1) {
                    gdMgr.sg.unselectedSpecialPicInfoList.push(info);
                  }
                } else {
                  let idx = gdMgr.sg.unselectedNormalPicInfoList.findIndex(item => item.id == info.id);
                  if (idx == -1) {
                    gdMgr.sg.unselectedNormalPicInfoList.push(info);
                  }
                }
                let data = gdMgr.getPictureData(info.id);
                data.isCached = true;
                console.log(`LoadingGraph-:${info.id} is cached`);
                if (this.flow_t.taskQueue.length == 0) {
                  this.flow_t.state = FlowState.Pause;
                }
              }
              break;
            case 3:
            case 4:
              {
                if (this.flow_s.taskQueue.length == 0) {
                  this.flow_s.state = FlowState.Pause;
                  if (this.flow_t.taskQueue.length > 0) {
                    this.flow_t.state = FlowState.Loading;
                  }
                }
              }
              break;
          }
        }
        pauseLoading() {
          this.flow_s.state = FlowState.Pause;
          this.flow_t.state = FlowState.Pause;
        }
        resumeLoading() {
          if (this.flow_s.taskQueue.length > 0) {
            this.flow_s.state = FlowState.Loading;
          } else if (this.flow_t.taskQueue.length > 0) {
            this.flow_t.state = FlowState.Loading;
          }
        }
      }
      exports('LoadingManager', LoadingManager);
      LoadingManager._instance = null;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/loading-view.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './ui-manager.ts', './loading-anim.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Label, Animation, _decorator, director, UIView, UIManager, EVENT_LOADING_END_COMPLETED, LoadingAnimId;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Label = module.Label;
      Animation = module.Animation;
      _decorator = module._decorator;
      director = module.director;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      EVENT_LOADING_END_COMPLETED = module.EVENT_LOADING_END_COMPLETED;
      LoadingAnimId = module.LoadingAnimId;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "c5c581y5H1HRbOesDAgpiUM", "loading-view", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      const TIME_OUT = 10;
      let LoadingView = exports('LoadingView', (_dec = ccclass('loading'), _dec2 = property({
        type: Label
      }), _dec3 = property(Animation), _dec(_class = (_class2 = class LoadingView extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "lblDesc", _descriptor, this);
          _initializerDefineProperty(this, "animLoading", _descriptor2, this);
          this.customCloseCallback = null;
        }
        onOpen(fromUI, ...args) {
          let data = args[0];
          if (!data) {
            return;
          }
          this.lblDesc.string = data ? data.desc : '';
          if (typeof data.displayTime === 'number') {
            this.customCloseCallback = data.onClose;
            this.scheduleOnce(() => {
              this.closeUI();
            }, data.displayTime);
          } else {
            this.scheduleOnce(() => {
              UIManager.instance.showToast(`Network Error`);
              this.closeUI();
            }, TIME_OUT);
          }
          if (data.promise instanceof Promise) {
            data.promise.then(() => {
              this.closeUI();
            }).catch(() => {
              UIManager.instance.showToast(`Network Error`);
              this.closeUI();
            });
          }
          director.on(EVENT_LOADING_END_COMPLETED, this.onEndCompleted, this);
        }
        onOpenAniOver() {
          this.animLoading.play(LoadingAnimId.Open);
        }
        onClose() {
          director.off(EVENT_LOADING_END_COMPLETED, this.onEndCompleted, this);
        }
        closeUI() {
          this.animLoading.play(LoadingAnimId.End);
        }
        onEndCompleted() {
          UIManager.instance.close(this);
          this.customCloseCallback && this.customCloseCallback();
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "lblDesc", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "animLoading", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/log-util.ts", ['cc', './config.ts'], function (exports) {
  var cclegacy, Config;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      Config = module.Config;
    }],
    execute: function () {
      cclegacy._RF.push({}, "b2046RFYbpF8qcEi34Rn0Fo", "log-util", undefined);
      class LogUtil {
        static log(...args) {
          if (Config.DEBUG) {
            console.log('[LOG]', ...args);
          }
        }
        static warn(...args) {
          if (Config.DEBUG) {
            console.warn('[WARN]', ...args);
          }
        }
        static error(...args) {
          console.error('[ERROR]', ...args); // 错误日志始终打印
        }
      }

      exports('LogUtil', LogUtil);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/main", ['./front-line.ts', './version-example.ts', './version-manager.ts', './welcome-hf-A.ts', './welcome-hf-B.ts', './ad-agent.ts', './ad-manager.ts', './bridge-event.ts', './bridge-manager.ts', './bridge-util.ts', './audio-effect-pool.ts', './audio-effect.ts', './audio-manager.ts', './audio-music.ts', './config-agent.ts', './data-agent.ts', './storage-manager.ts', './union-fetch-agent.ts', './gm-manager.ts', './time-agent.ts', './graph-manager.ts', './loading-flow.ts', './loading-manager.ts', './mount-manager.ts', './mount-pod.ts', './mount-point.ts', './http-agent.ts', './request-manager.ts', './res-keeper.ts', './res-leak-checker.ts', './res-loader.ts', './res-util.ts', './action-chain.ts', './bg-adapter.ts', './btn-effect.ts', './ui-manager.ts', './ui-screen-adapter.ts', './ui-view.ts', './animation-util.ts', './array-util.ts', './bezier-util.ts', './common-util.ts', './debug-util.ts', './log-util.ts', './object-util.ts', './random-util.ts', './safe-area-util.ts', './string-util.ts', './svg-util.ts', './ui-util.ts', './circular-mask.ts', './progress-bar-ctrl.ts', './round-rect-mask.ts', './bundle-conifg.ts', './config.ts', './default-config.ts', './text-config.ts', './ui-config.ts', './connect-agent.ts', './native-agent.ts', './sdk-agent.ts', './animation-canvas.ts', './card-constants.ts', './card-data.ts', './card-dealer.ts', './card-render.ts', './card.ts', './celebrate-agent.ts', './flip-ctrl.ts', './game-constants.ts', './game-data-manager.ts', './game-data-type-define.ts', './game-desk.ts', './game-res-manager.ts', './game-step.ts', './layout-tableau.ts', './step-checker.ts', './tool-agent.ts', './tool-auto-check-end.ts', './tool-auto-prompt.ts', './tool-auto-solve.ts', './tool-magic.ts', './tool-undo.ts', './i18n-agent.ts', './i18n-label.ts', './report-agent.ts', './reward-manager.ts', './reward-type-define.ts', './map.ts', './stage.ts', './welcome.ts', './AQKTRMDQJQQBTDC.ts', './FJOIKK.ts', './CCIOERS.ts', './CIVTVAVXRORTVD.ts', './FSIOKP.ts', './BSCTBWK.ts', './SVDMRMIFJDYHRX.ts', './OBGMYUHSPZ.ts', './AHGNGYYNSSRZ.ts', './AKHOCOQOOYH.ts', './CryptoES.mjs_cjs=&original=.js', './GKHQIDKQUTV.ts', './KENOHXMVJJSH.ts', './LIGHOZ.ts', './MEMINEFUZFGAOP.ts', './MNDOCJRWDSHZ.ts', './MNQRQYTLR.ts', './MYKRDT.ts', './OULQSMFSYRNMXWT.ts', './PQBRALKRA.ts', './QLHROXRCFBPYKY.ts', './RHNDXTSQQCUFJ.ts', './RTONERXYWGCD.ts', './SDYSTNCVGG.ts', './TAMEBDDEGGUCY.ts', './TBGHTYXGU.ts', './VBWBHDOLKCQNA.ts', './YJPHBDNICBXPNH.ts', './CJXOHZKFR.ts', './PZCMUYBUB.ts', './WBKIRV.ts', './TTINOQH.ts', './card-theme-item.ts', './card-theme-view.ts', './ad-btn.ts', './debug-info-view.ts', './gm-view.ts', './guide-tips.ts', './loading-anim.ts', './loading-view.ts', './major-token-tab.ts', './reflect-effect-mask.ts', './star-layout.ts', './timer-displayer.ts', './toast.ts', './token-account.ts', './guide-popup.ts', './home-view.ts', './menu-popup.ts', './more-game-view.ts', './policy-popup.ts', './rating-popup.ts', './target-popup.ts', './token-account-layout.ts', './under-view.ts', './victory-popup.ts', './illustraion-item.ts', './picture-view.ts', './plot-view.ts', './drift-bubble.ts', './item-get-popup.ts', './item-obtain-popup.ts', './reward-anim-controller.ts', './reward-get-popup.ts', './shuffle-anim-controller.ts', './sign-in-item.ts', './sign-in-popup.ts', './progress-effect.ts', './star-effect.ts'], function () {
  return {
    setters: [null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null],
    execute: function () {}
  };
});

System.register("chunks:///_virtual/major-token-tab.ts", ['cc', './game-data-manager.ts', './res-loader.ts', './res-util.ts', './game-constants.ts'], function (exports) {
  var cclegacy, Component, director, Sprite, _decorator, GameDataManager, resLoader, ResUtil, GameEvent;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Component = module.Component;
      director = module.director;
      Sprite = module.Sprite;
      _decorator = module._decorator;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      resLoader = module.resLoader;
    }, function (module) {
      ResUtil = module.ResUtil;
    }, function (module) {
      GameEvent = module.GameEvent;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "c549dkSbOtA+IuBSaEYDklT", "major-token-tab", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let MajorTokenTab = exports('MajorTokenTab', (_dec = ccclass('MajorTokenTab'), _dec(_class = class MajorTokenTab extends Component {
        constructor(...args) {
          super(...args);
          this.type = void 0;
        }
        onEnable() {
          this.updateTokenType(GameDataManager.instance.getMajorTokenType());
          director.on(GameEvent.CHANGE_CARD_THEME, this.updateTokenType, this);
        }
        onDisable() {
          director.off(GameEvent.CHANGE_CARD_THEME, this.updateTokenType, this);
        }
        updateTokenType(type) {
          let sprite = this.getComponent(Sprite);
          if (this.type != type) {
            this.type = type;
            resLoader.load(`textures/token-major/tab/tab-${type}/spriteFrame`, (err, frame) => {
              sprite.spriteFrame = frame;
              this.type = type;
              ResUtil.assignWith(frame, this.node, true);
            });
          }
        }
      }) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/map.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-manager.ts', './ui-config.ts', './game-data-manager.ts', './game-constants.ts', './audio-manager.ts', './mount-manager.ts', './mount-point.ts', './graph-manager.ts', './config.ts', './bg-adapter.ts', './game-data-type-define.ts', './ui-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Sprite, ParticleSystem2D, _decorator, Component, director, Node, sys, Vec3, UIManager, UICF, UIID, GameDataManager, AudioUrl, AudioManager, MountManager, MountPoint, GraphManager, ConfigEvent, Config, BgAdapter, SgState, UIUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Sprite = module.Sprite;
      ParticleSystem2D = module.ParticleSystem2D;
      _decorator = module._decorator;
      Component = module.Component;
      director = module.director;
      Node = module.Node;
      sys = module.sys;
      Vec3 = module.Vec3;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      UICF = module.UICF;
      UIID = module.UIID;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      AudioUrl = module.AudioUrl;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      MountManager = module.MountManager;
    }, function (module) {
      MountPoint = module.MountPoint;
    }, function (module) {
      GraphManager = module.GraphManager;
    }, function (module) {
      ConfigEvent = module.ConfigEvent;
      Config = module.Config;
    }, function (module) {
      BgAdapter = module.BgAdapter;
    }, function (module) {
      SgState = module.SgState;
    }, function (module) {
      UIUtil = module.UIUtil;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "bad8cruugNKaZRRCxLapQHa", "map", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let Map = exports('Map', (_dec = ccclass('Map'), _dec2 = property(Sprite), _dec3 = property(ParticleSystem2D), _dec(_class = (_class2 = class Map extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "sprBg", _descriptor, this);
          _initializerDefineProperty(this, "ptclClick", _descriptor2, this);
        }
        onEnable() {
          // director.on(GameEvent.CHANGE_MAP_BG, this.updateBg, this);
          director.on(ConfigEvent.FLAG_CHANGED, this.onFlagChanged, this);
          this.node.on(Node.EventType.TOUCH_END, this.onTouchEnd, this, true);
        }
        onDisable() {
          // director.off(GameEvent.CHANGE_MAP_BG, this.updateBg, this);
          director.off(ConfigEvent.FLAG_CHANGED, this.onFlagChanged, this);
          this.node.off(Node.EventType.TOUCH_END, this.onTouchEnd, this, true);
        }
        onLoad() {
          let constNode = director.getScene().getChildByName('Const');
          if (!constNode) {
            constNode = new Node();
            constNode.name = 'Const';
            director.getScene().addChild(constNode);
          }
          director.addPersistRootNode(constNode);
          MountManager.instance.notify(MountPoint.NotifyWebContReady, {
            node: constNode
          });
          this.updateBg();
        }
        start() {
          if (!AudioManager.instance.switchMusic) {
            this.scheduleOnce(() => {
              AudioManager.instance.stopMusic();
            }, 0.5);
          } else {
            AudioManager.instance.playMusicLoop(AudioUrl.BGM);
          }
          MountManager.instance.notify(MountPoint.StageInitUIConf, UICF);
          UIManager.instance.initUIConf(UICF);
          UIManager.instance.setLayer();
          // this.schedule(() => {
          //     UIManager.instance.showDebugInfoToast();
          // }, 5)

          if (sys.isBrowser) {
            Config.setRFlag(true);
          }
          let gdMgr = GameDataManager.instance;
          let sgState = gdMgr.sg.state;
          if (sgState === SgState.Started) {
            if (gdMgr.sg.isPlayPlots || gdMgr.data.isPlayPlots) {
              UIManager.instance.open(UIID.StartViewSg);
            } else {
              UIManager.instance.open(UIID.PlotView);
            }
          }
          this.onFlagChanged();
        }
        onDestroy() {
          this.unscheduleAllCallbacks();
        }
        onTouchEnd(event) {
          if (!this.ptclClick) return;
          let sPos = event.getLocation();
          let lPos = UIUtil.convertScreenPosToLocal(new Vec3(sPos.x, sPos.y, 0), this.ptclClick.node.parent, this.node);
          this.ptclClick.resetSystem();
          this.ptclClick.node.setPosition(lPos);
          this.ptclClick.node.active = true;
        }
        async updateBg() {
          if (GameDataManager.instance.sg.state === SgState.Started) {
            // 根据逻辑选择bg
            let bgInfo = GameDataManager.instance.getRandomBgInfo();
            if (!bgInfo) {
              let adapter = this.sprBg.getComponent(BgAdapter);
              adapter && adapter.updateSize();
              return;
            }
            let data = GameDataManager.instance.getPictureData(bgInfo.id);
            let url = data.isLocked ? bgInfo.url_A_s : bgInfo.url_B_s;
            let bgSpf = await GraphManager.instance.loadGraph(url);
            if (bgSpf && bgSpf.isValid) {
              this.sprBg.spriteFrame = bgSpf;
              let adapter = this.sprBg.getComponent(BgAdapter);
              adapter && adapter.updateSize();
            }
          }
        }
        async onFlagChanged() {
          if (GameDataManager.instance.sg.state === SgState.Unready) {
            MountManager.instance.notify(MountPoint.NativeCheckLocalCache, null);
            console.log('Map-loadSg--start');
            let gdMgr = GameDataManager.instance;
            let cacheSize = 8;
            let needNum_n = cacheSize - gdMgr.sg.unselectedNormalPicInfoList.length;
            needNum_n = Math.min(needNum_n, 4);
            let count_n = 0;
            let list = [];
            if (needNum_n > 0) {
              let list_n = gdMgr.getUncachedPictureList(needNum_n, false);
              if (list_n.length < needNum_n) {
                let promiseFetch = MountManager.instance.notify(MountPoint.RemoteFetchIllustration, {
                  total: 10,
                  adCount: 0
                })[0];
                if (promiseFetch instanceof Promise) {
                  await promiseFetch;
                }
                list_n = gdMgr.getUncachedPictureList(needNum_n, false);
              }
              list = list.concat(list_n);
              if (Config.DEBUG) {
                count_n = list.length;
                UIManager.instance.showToast(`Map-LoadSg:n-${count_n}`);
              }
            }
            let needNum_s = cacheSize - gdMgr.sg.unselectedSpecialPicInfoList.length - needNum_n;
            needNum_s = Math.min(needNum_s, 4);
            let count_s = 0;
            if (needNum_s > 0) {
              let list_s = gdMgr.getUncachedPictureList(needNum_s, true);
              if (list_s.length < needNum_s) {
                let promiseFetch = MountManager.instance.notify(MountPoint.RemoteFetchIllustration, {
                  total: 10,
                  adCount: 0
                })[0];
                if (promiseFetch instanceof Promise) {
                  await promiseFetch;
                }
                list_s = gdMgr.getUncachedPictureList(needNum_s, true);
              }
              list = list.concat(list_s);
              if (Config.DEBUG) {
                count_s = list.length;
                UIManager.instance.showToast(`Map-LoadSg:s-${count_s}`);
              }
            }
            let promisePreload = MountManager.instance.notify(MountPoint.NativeNotifyLoadPicture, {
              infoList: list,
              type: 2,
              taskId: `welcome-pics`
            })[0];
            await promisePreload;
          }
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "sprBg", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "ptclClick", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MEMINEFUZFGAOP.ts", ['cc', './AQKTRMDQJQQBTDC.ts', './WBKIRV.ts', './SVDMRMIFJDYHRX.ts', './PQBRALKRA.ts'], function (exports) {
  var cclegacy, AQKTRMDQJQQBTDC, PSWZDFV, SVDMRMIFJDYHRX, PQBRALKRA;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      PSWZDFV = module.PSWZDFV;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      PQBRALKRA = module.PQBRALKRA;
    }],
    execute: function () {
      cclegacy._RF.push({}, "9b74ak+BslAlrRiipItrDUH", "MEMINEFUZFGAOP", undefined);
      class HttpRequestTempData {
        constructor() {
          this.msgId = void 0;
          this.data = void 0;
        }
      }
      exports('HttpRequestTempData', HttpRequestTempData);
      class MEMINEFUZFGAOP extends SVDMRMIFJDYHRX {
        constructor(...args) {
          super(...args);
          this.CCPRNHJHRVVLKN = 1;
          this.AKCCULRR = {};
        }
        TGQXAKDAHFFVG() {
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.LQOAQXAMP, this.LQOAQXAMP, this);
        }
        QIZLFVUQ() {}
        LQOAQXAMP(ICLLMTBOICCIAPM) {
          try {
            let result = atob(ICLLMTBOICCIAPM);
            let data = JSON.parse(result);
            let id = data.msgId;
            let listener = this.AKCCULRR[`${id}`];
            if (listener != null && data.data != null) {
              let dataResult = atob(data.data);
              listener.LOOAKODVFPSLJZUK(dataResult);
            }
          } catch (e) {}
        }
        GHHSHXQQFZCP(XCCJOIFFXZSMLHIV = null, queryParams = null, PYGPRHHLLOGJEROQ) {
          this.RFFCNTYYDMN("get", XCCJOIFFXZSMLHIV, queryParams, PYGPRHHLLOGJEROQ);
        }
        VWDVAXBMTVOTE(LXHMYPLVY, MZNNJGSYJLP = null, PYGPRHHLLOGJEROQ) {
          let headers = {
            "X-Forwarded": LXHMYPLVY
          };
          this.RFFCNTYYDMN("get", headers, MZNNJGSYJLP, PYGPRHHLLOGJEROQ);
        }
        MJSBQKZWJE(XCCJOIFFXZSMLHIV = null, VOHDKJYJVKD = null, PYGPRHHLLOGJEROQ) {
          this.RFFCNTYYDMN("post", XCCJOIFFXZSMLHIV, VOHDKJYJVKD, PYGPRHHLLOGJEROQ);
        }
        JULVWZIHBP(LXHMYPLVY, TBFDFUQHZQYB = null, PYGPRHHLLOGJEROQ) {
          let headers = {
            "X-Forwarded": LXHMYPLVY
          };
          this.RFFCNTYYDMN("post", headers, TBFDFUQHZQYB, PYGPRHHLLOGJEROQ);
        }
        RFFCNTYYDMN(EYAVKOOZUR, XCCJOIFFXZSMLHIV = {}, QYAQVVYEJXYTTJBV = {}, PYGPRHHLLOGJEROQ) {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          this.CCPRNHJHRVVLKN += 1;
          this.AKCCULRR[`${this.CCPRNHJHRVVLKN}`] = PYGPRHHLLOGJEROQ;
          let headerStr = "{}";
          if (XCCJOIFFXZSMLHIV != null) {
            headerStr = JSON.stringify(XCCJOIFFXZSMLHIV);
          }
          let paramsStr = "{}";
          if (QYAQVVYEJXYTTJBV != null) {
            paramsStr = JSON.stringify(QYAQVVYEJXYTTJBV);
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().RFFCNTYYDMN(this.CCPRNHJHRVVLKN, EYAVKOOZUR, headerStr, paramsStr);
        }
      }
      exports('MEMINEFUZFGAOP', MEMINEFUZFGAOP);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/menu-popup.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './game-data-manager.ts', './string-util.ts', './audio-manager.ts', './ui-manager.ts', './ui-config.ts', './game-constants.ts', './bridge-util.ts', './config.ts', './time-agent.ts', './reward-manager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Sprite, SpriteFrame, Label, _decorator, director, UIView, GameDataManager, StringUtil, AudioManager, UIManager, UIID, AudioUrl, GameEvent, ParamStage, BridgeUtil, VibrationEffect, Config, TimeAgent, RewardManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Sprite = module.Sprite;
      SpriteFrame = module.SpriteFrame;
      Label = module.Label;
      _decorator = module._decorator;
      director = module.director;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      StringUtil = module.StringUtil;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      UIID = module.UIID;
    }, function (module) {
      AudioUrl = module.AudioUrl;
      GameEvent = module.GameEvent;
      ParamStage = module.ParamStage;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      TimeAgent = module.TimeAgent;
    }, function (module) {
      RewardManager = module.RewardManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12;
      cclegacy._RF.push({}, "7391cOOuMlC1Lf/AchlVNp5", "menu-popup", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let MenuPopup = exports('MenuPopup', (_dec = ccclass('MenuPopup'), _dec2 = property({
        type: Sprite
      }), _dec3 = property({
        type: Sprite
      }), _dec4 = property({
        type: Sprite
      }), _dec5 = property({
        type: [SpriteFrame]
      }), _dec6 = property({
        type: Label
      }), _dec7 = property({
        type: Label
      }), _dec8 = property({
        type: Label
      }), _dec9 = property({
        type: Label
      }), _dec10 = property({
        type: Label
      }), _dec11 = property({
        type: Label
      }), _dec12 = property({
        type: Label
      }), _dec13 = property({
        type: Label
      }), _dec(_class = (_class2 = class MenuPopup extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "sprdMusicBtn", _descriptor, this);
          _initializerDefineProperty(this, "sprdEffectBtn", _descriptor2, this);
          _initializerDefineProperty(this, "sprdVibrationBtn", _descriptor3, this);
          _initializerDefineProperty(this, "frameListBtn", _descriptor4, this);
          _initializerDefineProperty(this, "lblGamesPlayed", _descriptor5, this);
          _initializerDefineProperty(this, "lblGamesWon", _descriptor6, this);
          _initializerDefineProperty(this, "lblWinPercent", _descriptor7, this);
          _initializerDefineProperty(this, "lblCurWinStreak", _descriptor8, this);
          _initializerDefineProperty(this, "lblMaxWinStreak", _descriptor9, this);
          _initializerDefineProperty(this, "lblBestTime", _descriptor10, this);
          _initializerDefineProperty(this, "lblAvgTime", _descriptor11, this);
          _initializerDefineProperty(this, "lblVersion", _descriptor12, this);
          this.clickTimes = 0;
        }
        onOpen(fromUI, ...args) {
          AudioManager.instance.playEffect(AudioUrl.SHOW_POPUP);
          BridgeUtil.vibrate(30, VibrationEffect.CLICK);
          let data = GameDataManager.instance.data;
          this.lblGamesPlayed.string = data.gamesPlayed.toString();
          this.lblGamesWon.string = data.gamesWon.toString();
          this.lblWinPercent.string = (data.winPencent * 100).toFixed(0) + '%';
          this.lblCurWinStreak.string = data.curWinStreak.toString();
          this.lblMaxWinStreak.string = data.maxWinStreak.toString();
          this.lblVersion.string = `v-${Config.GAME_VERSION}`;
          if (data.bestTime > 0) {
            this.lblBestTime.string = StringUtil.timeFormat(data.bestTime);
          } else {
            this.lblBestTime.string = '--';
          }
          if (data.avgTime > 0) {
            this.lblAvgTime.string = StringUtil.timeFormat(data.avgTime);
          } else {
            this.lblAvgTime.string = '--';
          }
          this.setMusicBtnState(AudioManager.instance.switchMusic);
          this.setEffectBtnState(AudioManager.instance.switchEffect);
          this.setVibrationBtnState(AudioManager.instance.switchVibration);
        }
        onClose() {
          GameDataManager.instance.saveData();
        }
        setMusicBtnState(isOn) {
          let idx = isOn ? 0 : 1;
          this.sprdMusicBtn.spriteFrame = this.frameListBtn[idx];
        }
        setEffectBtnState(isOn) {
          let idx = isOn ? 0 : 1;
          this.sprdEffectBtn.spriteFrame = this.frameListBtn[idx];
        }
        setVibrationBtnState(isOn) {
          let idx = isOn ? 0 : 1;
          this.sprdVibrationBtn.spriteFrame = this.frameListBtn[idx];
        }
        onMusicBtn() {
          let audioMgr = AudioManager.instance;
          this.onClickBtn();
          audioMgr.switchMusic = !audioMgr.switchMusic;
          if (audioMgr.switchMusic) {
            audioMgr.playMusicLoop(AudioUrl.BGM);
          }
          this.setMusicBtnState(audioMgr.switchMusic);
        }
        onSoundEffectBtn() {
          let audioMgr = AudioManager.instance;
          this.onClickBtn();
          audioMgr.switchEffect = !audioMgr.switchEffect;
          this.setEffectBtnState(audioMgr.switchEffect);
        }
        onVibration() {
          let audioMgr = AudioManager.instance;
          this.onClickBtn();
          audioMgr.switchVibration = !audioMgr.switchVibration;
          this.setVibrationBtnState(audioMgr.switchVibration);
        }
        onGuideBtn() {
          this.onClickBtn();
          UIManager.instance.open(UIID.GuidePopup);
        }
        onContactBtn() {
          this.onClickBtn();
          let now = new Date(TimeAgent.instance.getTime());
          let sid = GameDataManager.instance.getPlayerSid();
          let title = `【De-Stress Solitaire】Feedback and Suggestions`;
          let content = `Please enter your feedback or problems!\nWe will respond and handle them quickly!\nVersion:${Config.GAME_VERSION} / ${GameDataManager.instance.getInviteCode()} / ${sid}`;
          BridgeUtil.sendMail(Config.MAIL, title, content);
        }
        onPolicyBtn() {
          this.onClickBtn();
          UIManager.instance.open(UIID.PolicyPopup);
        }
        onCloseBtn() {
          this.onClickBtn();
          UIManager.instance.close(this);
        }
        onGmBtn() {
          let config = RewardManager.instance.getConfig();
          if (!config) {
            console.log('onGmBtn-config is null');
            return;
          }
          if (config.gm.is_gm || Config.DEBUG) {
            this.clickTimes++;
            if (this.clickTimes >= 5) {
              this.clickTimes = 0;
              UIManager.instance.open(UIID.GmView);
            }
            this.unschedule(this.cleanClickTimes.bind(this));
            this.scheduleOnce(this.cleanClickTimes.bind(this), 1);
          }
        }
        cleanClickTimes() {
          this.clickTimes = 0;
        }
        onRestartBtn() {
          this.onClickBtn();
          director.emit(GameEvent.STAGE, ParamStage.FAIL, false);
          UIManager.instance.close(this);
        }
        onNewGameBtn() {
          this.onClickBtn();
          director.emit(GameEvent.STAGE, ParamStage.FAIL, true);
          UIManager.instance.close(this);
        }
        onClickBtn() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "sprdMusicBtn", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "sprdEffectBtn", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "sprdVibrationBtn", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "frameListBtn", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "lblGamesPlayed", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "lblGamesWon", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "lblWinPercent", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "lblCurWinStreak", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "lblMaxWinStreak", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "lblBestTime", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "lblAvgTime", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class2.prototype, "lblVersion", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MNDOCJRWDSHZ.ts", ['cc', './SVDMRMIFJDYHRX.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }],
    execute: function () {
      cclegacy._RF.push({}, "1d9a2etcIZPFbDCyM+lNsa6", "MNDOCJRWDSHZ", undefined);
      class MNDOCJRWDSHZ extends SVDMRMIFJDYHRX {
        TGQXAKDAHFFVG() {}
        QIZLFVUQ() {
          // console.log('SDK MNDOCJRWDSHZ');
        }
      }
      exports('MNDOCJRWDSHZ', MNDOCJRWDSHZ);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MNQRQYTLR.ts", ['cc', './SVDMRMIFJDYHRX.ts', './WBKIRV.ts', './CCIOERS.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, PSWZDFV, CCIOERS;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      PSWZDFV = module.PSWZDFV;
    }, function (module) {
      CCIOERS = module.CCIOERS;
    }],
    execute: function () {
      cclegacy._RF.push({}, "d06dbSKSTdOna1YTVNwVQGi", "MNQRQYTLR", undefined);
      class MNQRQYTLR extends SVDMRMIFJDYHRX {
        constructor(...args) {
          super(...args);
          this.SATOYUPFPFTZ = null;
          this.BSHTPUTYI = false;
          this.PACDIXBIRS = false;
        }
        TGQXAKDAHFFVG() {
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.GGOEUNELMFVB, this.GGOEUNELMFVB, this);
        }
        QIZLFVUQ() {}
        GGOEUNELMFVB(theme) {
          // 游戏主题打点
          this.BSHTPUTYI = theme.toUpperCase() == "#FF0000";
          let eventName = "sdk_theme_stuff";
          let step = this.BSHTPUTYI ? "game_on" : "game_off";
          let property = {
            "step": step
          };
          CCIOERS.MSCGDWEHBPVJEQE().QQUEEYIFYIE().OASGKQN(eventName, property);
          // 外部回调
          if (this.SATOYUPFPFTZ != null) {
            this.SATOYUPFPFTZ.GGOEUNELMFVB(this.BSHTPUTYI);
            this.PACDIXBIRS = false;
          } else {
            this.PACDIXBIRS = true;
          }
        }
        OQBJDNV(PYGPRHHLLOGJEROQ) {
          this.SATOYUPFPFTZ = PYGPRHHLLOGJEROQ;
          if (this.PACDIXBIRS) {
            this.SATOYUPFPFTZ.GGOEUNELMFVB(this.BSHTPUTYI);
          }
        }
      }
      exports('MNQRQYTLR', MNQRQYTLR);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/more-game-view.ts", ['cc', './ui-view.ts', './ui-manager.ts', './audio-manager.ts', './game-constants.ts', './mount-manager.ts', './mount-point.ts', './log-util.ts', './bridge-util.ts'], function (exports) {
  var cclegacy, WebView, _decorator, UIView, UIManager, AudioManager, AudioUrl, MountManager, MountPoint, LogUtil, BridgeUtil, VibrationEffect;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      WebView = module.WebView;
      _decorator = module._decorator;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      AudioUrl = module.AudioUrl;
    }, function (module) {
      MountManager = module.MountManager;
    }, function (module) {
      MountPoint = module.MountPoint;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "702d3mCuJ9B/JJied0YGuwM", "more-game-view", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let MoreGameView = exports('MoreGameView', (_dec = ccclass('MoreGameView'), _dec(_class = class MoreGameView extends UIView {
        onOpen(fromUI, ...args) {
          if (this.refreshWebview()) {
            LogUtil.error(`More Game Url Error`);
            UIManager.instance.close(this);
          }
        }
        onBackBtn() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          UIManager.instance.close(this);
        }
        onRefreshBtn() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
          this.refreshWebview();
        }
        refreshWebview() {
          let list = MountManager.instance.notify(MountPoint.GetMoreGameUrl, null);
          let wv = this.getComponentInChildren(WebView);
          if (list.length > 0 && list[0] != '') {
            wv.url = list[0];
            return true;
          }
          return false;
        }
      }) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/mount-manager.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "dd5ecjMiNFPpJXk07D9c5Lp", "mount-manager", undefined);
      class MountManager {
        constructor() {
          this._mountData = new Map();
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new MountManager();
          }
          return this._instance;
        }
        has(mountPoint) {
          return this._mountData.has(mountPoint);
        }
        notify(mountPoint, data) {
          const result = [];
          const pods = this._mountData.get(mountPoint);
          if (pods) {
            pods.forEach(pod => {
              if (pod.onMountPoint) {
                const rt = pod.onMountPoint(mountPoint, data);
                if (rt) {
                  result.push(rt);
                }
              }
            });
          }
          return result;
        }
        mount(mountPoint, pod) {
          const pods = this._mountData.get(mountPoint);
          if (pods) {
            pods.push(pod);
          } else {
            this._mountData.set(mountPoint, [pod]);
          }
        }
        unMount(mountPoint, pod) {
          const podins = this._mountData.get(mountPoint);
          if (podins) {
            const index = podins.indexOf(pod);
            if (index >= 0) {
              podins.splice(index, 1);
            }
          }
        }
      }
      exports('MountManager', MountManager);
      MountManager._instance = void 0;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/mount-pod.ts", ['cc'], function () {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "fce41/+mo5NJKPz3n/MZjBs", "mount-pod", undefined);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/mount-point.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "6deeaizJJdFXYOjD2af+SEO", "mount-point", undefined);
      let MountPoint = exports('MountPoint', /*#__PURE__*/function (MountPoint) {
        MountPoint["RemoteWebConfigUpdated"] = "RemoteWebConfigUpdated";
        MountPoint["RemoteStoreConfigUpdated"] = "RemoteStoreConfigUpdated";
        MountPoint["RemoteStoreDataUpdated"] = "RemoteStoreDataUpdated";
        MountPoint["NativeNotifyPageRc"] = "NativeNotifyPageRc";
        MountPoint["NotifyWebContReady"] = "NotifyWebContReady";
        MountPoint["NativeNotifyCurrency"] = "NativeNotifyCurrency";
        MountPoint["NativeNotifyIsRedeem"] = "NativeNotifyIsRedeem";
        MountPoint["NativeNotifyRedeemAount"] = "NativeNotifyRedeemAount";
        MountPoint["NativeNotifyProgressChange"] = "NativeNotifyProgressChange";
        MountPoint["NativeNotifyResetData"] = "NativeNotifyResetData";
        MountPoint["RemoteFetchIllustration"] = "NativeFetchIllustration";
        MountPoint["NativeCheckLocalCache"] = "NativeCheckLocalCache";
        MountPoint["NativeNotifyGetIllustration"] = "NativeNotifyGetIllustration";
        MountPoint["NativeNotifyLoadPicture"] = "NativeNotifyLoadPicture";
        MountPoint["NativeNotifyGetPreloadTaskState"] = "NativeNotifyGetPreloadTaskState";
        MountPoint["NativeNotifyGetShowPageFrame"] = "NativeNotifyGetShowPageFrame";
        MountPoint["HasStore"] = "HasStore";
        MountPoint["StageInitUIConf"] = "StageInitUIConf";
        MountPoint["RFlagChanged"] = "RFlagChanged";
        MountPoint["GetMoreGameUrl"] = "GetMoreGameUrl";
        return MountPoint;
      }({}));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/MYKRDT.ts", ['cc', './SVDMRMIFJDYHRX.ts', './AQKTRMDQJQQBTDC.ts', './PQBRALKRA.ts', './WBKIRV.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, AQKTRMDQJQQBTDC, PQBRALKRA, PSWZDFV;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      PQBRALKRA = module.PQBRALKRA;
    }, function (module) {
      PSWZDFV = module.PSWZDFV;
    }],
    execute: function () {
      cclegacy._RF.push({}, "3279ckYxd9Hb42TrjlUXa65", "MYKRDT", undefined);
      class MYKRDT extends SVDMRMIFJDYHRX {
        constructor(...args) {
          super(...args);
          this.PYGPRHHLLOGJEROQ = void 0;
        }
        BWLBATDR(listener) {
          this.PYGPRHHLLOGJEROQ = listener;
        }
        WBZHMHO() {
          if (PQBRALKRA.OTORTMMYVD) {
            return false;
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().WBZHMHO();
        }
        UENVUHZR(gameEntry) {
          if (PQBRALKRA.OTORTMMYVD) {
            return false;
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().UENVUHZR(gameEntry);
        }
        TGQXAKDAHFFVG() {
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.NPQULXODN, this.NPQULXODN, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.ARRVSYWBB, this.ARRVSYWBB, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.RYODTT, this.MWVVSALVOCLVENY, this);
        }
        QIZLFVUQ() {}
        NPQULXODN(ICLLMTBOICCIAPM) {
          try {
            let data = JSON.parse(ICLLMTBOICCIAPM);
            if (this.PYGPRHHLLOGJEROQ != null) {
              this.PYGPRHHLLOGJEROQ.CNOJWNVFLPGXXR(data);
            }
          } catch (e) {}
        }
        ARRVSYWBB(ICLLMTBOICCIAPM) {
          try {
            let data = JSON.parse(ICLLMTBOICCIAPM);
            if (this.PYGPRHHLLOGJEROQ != null) {
              this.PYGPRHHLLOGJEROQ.RIVCSELYPVW(data);
            }
          } catch (e) {}
        }
        MWVVSALVOCLVENY(ICLLMTBOICCIAPM) {
          try {
            let data = JSON.parse(ICLLMTBOICCIAPM);
            if (this.PYGPRHHLLOGJEROQ != null) {
              this.PYGPRHHLLOGJEROQ.AYTXJJFAIJFT(data);
            }
          } catch (e) {}
        }
      }
      exports('MYKRDT', MYKRDT);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/native-agent.ts", ['cc'], function (exports) {
  var cclegacy, native;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      native = module.native;
    }],
    execute: function () {
      cclegacy._RF.push({}, "2eb7dfo4xVMCpzfDZzYbb/U", "native-agent", undefined);
      class NativeAgent {
        static dispatchEventToNative(event, data) {
          if (native && native.jsbBridgeWrapper) {
            native.jsbBridgeWrapper.dispatchEventToNative(event, data || "");
          }
        }
      }
      exports('NativeAgent', NativeAgent);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/OBGMYUHSPZ.ts", ['cc', './AKHOCOQOOYH.ts'], function (exports) {
  var cclegacy, AKHOCOQOOYH;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      AKHOCOQOOYH = module.AKHOCOQOOYH;
    }],
    execute: function () {
      cclegacy._RF.push({}, "4fa22Lb6uNI8KNP6OYEQ18k", "OBGMYUHSPZ", undefined);
      class OBGMYUHSPZ {
        static QFGQDPW(funcName, param) {
          console.log("QFGQDPW", "funcName: " + funcName + "  param:" + param);
          AKHOCOQOOYH.MSCGDWEHBPVJEQE().onGameMethodPost(funcName, param);
        }
      }
      exports('OBGMYUHSPZ', OBGMYUHSPZ);
      window.OBGMYUHSPZ = OBGMYUHSPZ;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/object-util.ts", ['cc', './log-util.ts'], function (exports) {
  var cclegacy, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      exports({
        ArrayType: ArrayType,
        ClassType: ClassType,
        MapType: MapType
      });
      cclegacy._RF.push({}, "034e5pJflRAnZxSFdivZNGM", "object-util", undefined);

      // 类型元数据装饰器
      function ClassType(type) {
        return function (target, propertyKey) {
          if (!target.constructor.__typeInfo__) {
            target.constructor.__typeInfo__ = new Map();
          }
          target.constructor.__typeInfo__.set(propertyKey, type);
        };
      }

      // 数组类型元数据装饰器
      function ArrayType(type) {
        return function (target, propertyKey) {
          if (!target.constructor.__arrayTypeInfo__) {
            target.constructor.__arrayTypeInfo__ = new Map();
          }
          target.constructor.__arrayTypeInfo__.set(propertyKey, type);
        };
      }
      function MapType(keyType, valueType) {
        return function (target, propertyKey) {
          if (!target.constructor.__mapTypeInfo__) {
            target.constructor.__mapTypeInfo__ = new Map();
          }
          target.constructor.__mapTypeInfo__.set(propertyKey, {
            keyType,
            valueType
          });
        };
      }
      class ObjectUtil {
        static fromPlain(targetClass, plain) {
          return ObjectUtil.restoreObject(targetClass, plain);
        }
        static fromString(targetClass, text) {
          try {
            const jsonObj = JSON.parse(text);
            return this.restoreObject(targetClass, jsonObj);
          } catch (error) {
            LogUtil.error('ObjectUtil fromString Failed to parse JSON:', error);
            return new targetClass();
          }
        }

        /**
         * 将 JSON 对象与类型化对象的默认值进行合并
         * 如果 JSON 对象没有某个字段，使用类型化对象的默认值
         * 如果 JSON 对象有类型化对象没有的字段，则忽略
         * @param targetClass 目标类型构造函数
         * @param jsonData JSON 对象数据
         * @returns 合并后的类型化对象
         */
        static mergeWithDefaults(targetClass, jsonData) {
          // 创建默认实例
          const defaultInstance = new targetClass();
          if (!jsonData || typeof jsonData !== 'object') {
            return defaultInstance;
          }

          // 获取类型元数据
          const typeInfo = targetClass.prototype.constructor.__typeInfo__ || new Map();
          const arrayTypeInfo = targetClass.prototype.constructor.__arrayTypeInfo__ || new Map();
          const mapTypeInfo = targetClass.prototype.constructor.__mapTypeInfo__ || new Map();

          // 遍历默认实例的所有属性
          for (const key in defaultInstance) {
            // 检查 JSON 数据中是否有对应字段
            if (jsonData.hasOwnProperty(key)) {
              const jsonValue = jsonData[key];
              if (jsonValue === null || jsonValue === undefined) {
                // JSON 中值为 null 或 undefined，使用默认值
                continue;
              }

              // 处理 Map 类型（使用 @MapType 装饰器的字段）
              const mapType = mapTypeInfo.get(key);
              if (mapType) {
                const {
                  keyType,
                  valueType
                } = mapType;
                const resultObj = {};

                // 处理对象格式 { key: value, key: value }
                if (typeof jsonValue === 'object' && !Array.isArray(jsonValue)) {
                  for (const [k, v] of Object.entries(jsonValue)) {
                    const restoredKey = this.restoreValue(keyType, k);
                    const restoredValue = this.restoreValue(valueType, v);
                    resultObj[restoredKey] = restoredValue;
                  }
                }
                defaultInstance[key] = resultObj;
                continue;
              }

              // 处理数组类型
              const arrayType = arrayTypeInfo.get(key);
              if (arrayType && Array.isArray(jsonValue)) {
                defaultInstance[key] = jsonValue.map(item => this.restoreObject(arrayType, item));
                continue;
              }

              // 处理对象类型
              const type = typeInfo.get(key);
              if (type && typeof jsonValue === 'object' && !Array.isArray(jsonValue)) {
                defaultInstance[key] = this.restoreObject(type, jsonValue);
                continue;
              }

              // 处理基本类型
              defaultInstance[key] = jsonValue;
            }
            // 如果 JSON 中没有对应字段，保持默认值不变
          }

          return defaultInstance;
        }
        static restoreObject(targetClass, data) {
          const instance = new targetClass();
          if (!data || typeof data !== 'object') {
            return instance;
          }

          // 获取类型元数据
          const typeInfo = targetClass.prototype.constructor.__typeInfo__ || new Map();
          const arrayTypeInfo = targetClass.prototype.constructor.__arrayTypeInfo__ || new Map();
          const mapTypeInfo = targetClass.prototype.constructor.__mapTypeInfo__ || new Map();
          for (const key in data) {
            const value = data[key];
            if (value === null || value === undefined) {
              continue;
            }

            // 检查是否是 Map 类型
            const mapType = mapTypeInfo.get(key);
            if (mapType) {
              const map = new Map();
              const {
                keyType,
                valueType
              } = mapType;

              // 处理 Map 数据
              if (Array.isArray(value)) {
                // 如果是数组格式 [[key, value], [key, value]]
                for (const [k, v] of value) {
                  const restoredKey = this.restoreValue(keyType, k);
                  const restoredValue = this.restoreValue(valueType, v);
                  map.set(restoredKey, restoredValue);
                }
              } else if (typeof value === 'object') {
                // 如果是对象格式 { key: value, key: value }
                for (const [k, v] of Object.entries(value)) {
                  const restoredKey = this.restoreValue(keyType, k);
                  const restoredValue = this.restoreValue(valueType, v);
                  map.set(restoredKey, restoredValue);
                }
              }
              instance[key] = map;
              continue;
            }

            // 处理其他类型
            if (typeof value === 'object') {
              if (Array.isArray(value)) {
                const arrayType = arrayTypeInfo.get(key);
                if (arrayType) {
                  instance[key] = value.map(item => this.restoreObject(arrayType, item));
                } else {
                  instance[key] = value;
                }
              } else {
                const type = typeInfo.get(key);
                if (type) {
                  instance[key] = this.restoreObject(type, value);
                } else {
                  instance[key] = value;
                }
              }
            } else {
              instance[key] = value;
            }
          }
          return instance;
        }
        static restoreValue(type, value) {
          if (value === null || value === undefined) {
            return value;
          }
          if (type === String) {
            return String(value);
          } else if (type === Number) {
            return Number(value);
          } else if (type === Boolean) {
            return Boolean(value);
          } else if (typeof value === 'object') {
            // 对于复杂对象类型，使用 restoreObject 方法
            return this.restoreObject(type, value);
          }
          return value;
        }
      }
      exports('ObjectUtil', ObjectUtil);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/OULQSMFSYRNMXWT.ts", ['cc', './SVDMRMIFJDYHRX.ts', './WBKIRV.ts', './CJXOHZKFR.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, PSWZDFV, CJXOHZKFR;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      PSWZDFV = module.PSWZDFV;
    }, function (module) {
      CJXOHZKFR = module.CJXOHZKFR;
    }],
    execute: function () {
      cclegacy._RF.push({}, "bcebdWXEERBMrBhkjFymROM", "OULQSMFSYRNMXWT", undefined);
      class OULQSMFSYRNMXWT extends SVDMRMIFJDYHRX {
        constructor(...args) {
          super(...args);
          this.NQLWJJIPLLZROJ = null;
          this.PACDIXBIRS = false;
          this.DTCCFOADPUHFJSAD = "";
        }
        TGQXAKDAHFFVG() {
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.TRCAMWXHVKVILMO, this.TRCAMWXHVKVILMO, this);
        }
        QIZLFVUQ() {}
        TRCAMWXHVKVILMO(ICLLMTBOICCIAPM) {
          CJXOHZKFR.VFTLWTDIPJAH();
          this.DTCCFOADPUHFJSAD = ICLLMTBOICCIAPM;
          if (this.NQLWJJIPLLZROJ != null) {
            this.NQLWJJIPLLZROJ.TRCAMWXHVKVILMO(this.DTCCFOADPUHFJSAD);
            this.PACDIXBIRS = false;
          } else {
            this.PACDIXBIRS = true;
          }
        }
        OOAMLKPOOJQXYVF(PYGPRHHLLOGJEROQ) {
          this.NQLWJJIPLLZROJ = PYGPRHHLLOGJEROQ;
          if (this.PACDIXBIRS) {
            this.NQLWJJIPLLZROJ.TRCAMWXHVKVILMO(this.DTCCFOADPUHFJSAD);
          }
        }
      }
      exports('OULQSMFSYRNMXWT', OULQSMFSYRNMXWT);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/picture-view.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './game-data-manager.ts', './ui-manager.ts', './audio-manager.ts', './game-constants.ts', './bridge-util.ts', './res-util.ts', './log-util.ts', './ui-config.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Sprite, SpriteFrame, Label, _decorator, director, UIView, GameDataManager, UIManager, AudioManager, AudioUrl, BridgeUtil, VibrationEffect, ResUtil, LogUtil, UIID;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Sprite = module.Sprite;
      SpriteFrame = module.SpriteFrame;
      Label = module.Label;
      _decorator = module._decorator;
      director = module.director;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      AudioUrl = module.AudioUrl;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }, function (module) {
      ResUtil = module.ResUtil;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      UIID = module.UIID;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "eefc74xjmVKep4kUSQm+nRz", "picture-view", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let picture_view = exports('picture_view', (_dec = ccclass('picture_view'), _dec2 = property(Sprite), _dec3 = property(Sprite), _dec4 = property([SpriteFrame]), _dec5 = property(Label), _dec(_class = (_class2 = class picture_view extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "sprPicture", _descriptor, this);
          _initializerDefineProperty(this, "sprLike", _descriptor2, this);
          _initializerDefineProperty(this, "framesLike", _descriptor3, this);
          _initializerDefineProperty(this, "lblTitle", _descriptor4, this);
          this._isFavorite = false;
          this.url = "";
        }
        onOpen(fromUI, ...args) {
          let accountLayout = director.getScene().getChildByPath('Canvas/midLayer/LayoutTokenAccount');
          if (accountLayout) {
            accountLayout.active = false;
          }
          let url = args[0];
          this.url = url;
          ResUtil.load(this.sprPicture.node, url, SpriteFrame, (err, frame) => {
            if (err) {
              console.error(err);
            } else {
              this.sprPicture.spriteFrame = frame;
            }
          });
          let picData = GameDataManager.instance.data.chapterData.chapterPictures[url];
          if (picData) {
            this.isFavorite = picData.isFavorite;
          } else {
            this.isFavorite = false;
          }
          switch (fromUI) {
            case UIID.ChapterDetailView:
              this.lblTitle.string = 'Chapter';
              this.sprLike.node.active = false;
              break;
            case UIID.HomeView:
              this.lblTitle.string = 'Get';
              this.sprLike.node.active = true;
              break;
            case UIID.IllustrationView:
              this.lblTitle.string = 'Illustration';
              break;
          }
        }
        onClose() {
          GameDataManager.instance.saveData(true);
        }
        set isFavorite(value) {
          this._isFavorite = value;
          this.sprLike.spriteFrame = this.framesLike[value ? 1 : 0];
          let illustrationData = GameDataManager.instance.data.illustrationData.find(item => item.url === this.url);
          if (illustrationData) {
            illustrationData.data.isFavorite = value;
          }
        }
        get isFavorite() {
          return this._isFavorite;
        }
        onCloseBtn() {
          this.onClickBtn();
          UIManager.instance.close(this);
        }
        onLikeBtn() {
          this.onClickBtn();
          this.isFavorite = !this.isFavorite;
          let data = GameDataManager.instance.data.illustrationData.find(item => item.url === this.url);
          if (data) {
            data.data.isFavorite = this.isFavorite;
          }
        }
        onDownloadBtn() {
          this.onClickBtn();
          let url = this.url.replace('/spriteFrame', '');
          let promise = new Promise((resolve, reject) => {
            BridgeUtil.saveToAlbum(url).then(success => {
              if (success) {
                UIManager.instance.showToast('Download To Album Success');
                resolve(true);
              } else {
                LogUtil.error('download to album failed');
                reject(false);
              }
            });
          });
          UIManager.instance.open(UIID.Loading, {
            promise: promise
          });
        }
        onClickBtn() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "sprPicture", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "sprLike", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "framesLike", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "lblTitle", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/plot-view.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './ui-manager.ts', './ui-config.ts', './game-data-manager.ts', './game-data-type-define.ts', './report-agent.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, _decorator, director, UIOpacity, tween, Button, UIView, UIManager, UIID, GameDataManager, SgState, ReportAgent, CustomReportEvent;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      _decorator = module._decorator;
      director = module.director;
      UIOpacity = module.UIOpacity;
      tween = module.tween;
      Button = module.Button;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      UIID = module.UIID;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      SgState = module.SgState;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "3ca4eoaAK1E465avChykdIP", "plot-view", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let PlotView = exports('PlotView', (_dec = ccclass('PlotView'), _dec2 = property(Node), _dec3 = property(Node), _dec4 = property(Node), _dec(_class = (_class2 = class PlotView extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "page1", _descriptor, this);
          _initializerDefineProperty(this, "page2", _descriptor2, this);
          _initializerDefineProperty(this, "nextBtn", _descriptor3, this);
          this.plots = [];
          this.curPlotId = -1;
          this.plotShowTime = 0;
        }
        onOpen(fromUI, ...args) {
          let accountLayout = director.getScene().getChildByPath('Canvas/midLayer/LayoutTokenAccount');
          if (accountLayout) {
            accountLayout.active = false;
          }
          for (let i = 0; i < this.page1.children.length; i++) {
            const plot = this.page1.getChildByName(`Plot${i}`);
            this.plots.push(plot);
            plot.active = false;
          }
          for (let i = 0; i < this.page2.children.length; i++) {
            const plot = this.page2.getChildByName(`Plot${i + 4}`);
            this.plots.push(plot);
            plot.active = false;
          }
          this.page1.active = true;
          this.page2.active = false;
          this.nextBtn.active = false;
          this.showPlot(0);
        }
        onClose() {
          GameDataManager.instance.saveData();
        }
        update(dt) {
          if (this.page1.active && this.curPlotId < 3 || this.page2.active && this.curPlotId < 7) {
            this.plotShowTime += dt;
            if (this.plotShowTime > 1.5) {
              this.showPlot(++this.curPlotId);
              this.plotShowTime = 0;
            }
          }
        }
        onBtnNext() {
          if (this.page1.active) {
            this.page1.active = false;
            this.page2.active = true;
            this.nextBtn.active = false;
            this.showPlot(4);
          } else if (this.page2.active) {
            UIManager.instance.close(this);
            if (GameDataManager.instance.sg.state === SgState.Started) {
              UIManager.instance.open(UIID.DescriptionView);
            }
          }
        }
        onClickPage() {
          if (this.page1.active && this.curPlotId < 3 || this.page2.active && this.curPlotId < 7) {
            this.next();
          }
        }
        next() {
          let plot = this.plots[this.curPlotId];
          if (plot) {
            let comp = plot.getComponent(UIOpacity);
            tween(comp).stop();
            comp.opacity = 255;
            if (this.curPlotId == 3 || this.curPlotId == 7) {
              this.nextBtn.active = true;
            }
          }
          this.showPlot(++this.curPlotId);
          this.plotShowTime = 0;
        }
        showPlot(id) {
          let plot = this.plots[id];
          if (!plot) {
            console.error(`Plot with id ${id} not found.`);
            return;
          }
          switch (id) {
            case 0:
              ReportAgent.reportCustomEvent(CustomReportEvent.USER_LIFECYCLE_MILESTONE, {
                action: 'star_illustration_one'
              });
              break;
            case 1:
              ReportAgent.reportCustomEvent(CustomReportEvent.USER_LIFECYCLE_MILESTONE, {
                action: 'star_illustration_two'
              });
              break;
          }
          this.curPlotId = id;
          let uiOpacity = plot.getComponent(UIOpacity);
          uiOpacity.opacity = 0;
          plot.active = true;
          plot.getComponent(Button).interactable = false;
          tween(uiOpacity).to(1, {
            opacity: 255
          }).call(() => {
            plot.getComponent(Button).interactable = true;
            if (id == 3 || id == 7) {
              this.nextBtn.active = true;
            }
          }).start();
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "page1", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "page2", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "nextBtn", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/policy-popup.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './ui-manager.ts', './bridge-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, WebView, _decorator, sys, UIView, UIManager, BridgeUtil, VibrationEffect;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      WebView = module.WebView;
      _decorator = module._decorator;
      sys = module.sys;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "f55e2Q2QxFCZaeqZ67O6k8v", "policy-popup", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let PolicyPopup = exports('PolicyPopup', (_dec = ccclass('PolicyPopup'), _dec2 = property(WebView), _dec(_class = (_class2 = class PolicyPopup extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "wv", _descriptor, this);
        }
        onOpen(fromUI, ...args) {
          BridgeUtil.vibrate(30, VibrationEffect.CLICK);
          switch (sys.platform) {
            case sys.Platform.IOS:
              this.wv.url = 'https://docs.google.com/document/d/10ki2wFkMihuepvPD8VjLZT08aO2UXBkddAA5t4vddto/edit?h&tab=t.0';
              this.wv.evaluateJS("mx:pop");
              break;
            case sys.Platform.ANDROID:
              this.wv.url = 'https://sahibedit.biz/privacy.html';
              break;
          }
        }
        onCloseBtn() {
          UIManager.instance.close(this);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "wv", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PQBRALKRA.ts", ['cc'], function (exports) {
  var cclegacy, sys;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      sys = module.sys;
    }],
    execute: function () {
      cclegacy._RF.push({}, "c3c80QukPtMiLxEX6EjeDLH", "PQBRALKRA", undefined);
      class PQBRALKRA {
        static WTPEMNO() {
          if (sys.os === sys.OS.ANDROID) {
            this.OTORTMMYVD = false;
            console.log(`[SDK] start Android`);
          } else {
            // console.log(`[SDK] start editor`);
            this.OTORTMMYVD = true;
          }
        }
      }
      exports('PQBRALKRA', PQBRALKRA);
      PQBRALKRA.OTORTMMYVD = true;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/progress-bar-ctrl.ts", ['cc'], function (exports) {
  var cclegacy, Component, UITransform, Widget, ProgressBar, _decorator;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Component = module.Component;
      UITransform = module.UITransform;
      Widget = module.Widget;
      ProgressBar = module.ProgressBar;
      _decorator = module._decorator;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "89eb2HwPCJPfKmJnDrXLiPX", "progress-bar-ctrl", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let ProgressBarCtrl = exports('ProgressBarCtrl', (_dec = ccclass('ProgressBar'), _dec(_class = class ProgressBarCtrl extends Component {
        constructor(...args) {
          super(...args);
          this.total = 100;
          this.accumulated = 10;
          this.lockAt = 10;
          this.step = 0.8;
          this.slownCut = 0.35;
          this.callback = null;
          this.slownBegin = 0;
          this.slownEnd = 0;
        }
        start() {
          this.setProgress(this.accumulated / this.total);
        }
        update(deltaTime) {
          this.stepProgress();
        }
        setConfig(callback, slownBegin = 0, slwonEnd = 0) {
          this.callback = callback;
          this.slownBegin = slownBegin;
          this.slownEnd = slwonEnd;
        }
        lock(val) {
          this.lockAt = val;
        }
        getCurrentLock() {
          return this.lockAt;
        }
        unlock() {
          this.lockAt = this.total;
        }
        slownDownIfNeed() {
          if (this.slownBegin <= 0 && this.slownEnd <= 0) {
            return;
          }
          if (this.accumulated < this.slownBegin || this.accumulated > this.slownEnd) {
            return;
          }
          this.accumulated -= this.slownCut;
          if (this.accumulated < 10) {
            this.accumulated = 10;
          }
          return this.accumulated;
        }
        stepProgress() {
          this.accumulated += this.step;
          this.slownDownIfNeed();
          if (this.accumulated > this.total) {
            this.accumulated = this.total;
          }
          if (this.accumulated > this.lockAt) {
            this.accumulated = this.lockAt;
          }
          const proregss = this.accumulated / this.total;
          this.setProgress(proregss);
          // this.updateBubble(proregss);
          if (this.accumulated == this.total) {
            this.callback && this.callback();
            this.callback = null;
          }
        }
        updateBubble(progress) {
          const bubbleNode = this.node.getChildByName('bubble');
          if (bubbleNode) {
            const alignLeft = progress * this.node.getComponent(UITransform).width - 80;
            bubbleNode.getComponent(Widget).left = alignLeft;
          }
        }
        setProgress(progress) {
          if (progress < 0) {
            progress = 0;
          } else if (progress > 1) {
            progress = 1;
          }
          this.getComponent(ProgressBar).progress = progress;
        }
      }) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/progress-effect.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, Label, _decorator, Component, tween, Vec3;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      Label = module.Label;
      _decorator = module._decorator;
      Component = module.Component;
      tween = module.tween;
      Vec3 = module.Vec3;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "ad681Fl/VhMRIHQZb7+64Np", "progress-effect", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      const Y_0 = -530;
      const Y_1 = -190;
      let ProgressEffect = exports('ProgressEffect', (_dec = ccclass('ProgressEffect'), _dec2 = property(Node), _dec3 = property(Label), _dec(_class = (_class2 = class ProgressEffect extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "bar", _descriptor, this);
          _initializerDefineProperty(this, "lbl", _descriptor2, this);
          this._progress = 0;
        }
        set progress(val) {
          let x = this.bar.position.x;
          this._progress = val;
          this._progress = Math.max(this._progress, 0);
          this._progress = Math.min(this._progress, 100);
          this.lbl.string = `${this._progress.toFixed(0)}%`;
          if (this._progress === 0) {
            this.bar.setPosition(x, Y_0);
          } else if (this._progress === 100) {
            this.bar.setPosition(x, Y_1);
          } else {
            let y = Y_0 + (Y_1 - Y_0) * this._progress / 100;
            this.bar.setPosition(x, y);
          }
        }
        onDisable() {
          tween(this.bar).stop();
          this.progress = 0;
        }
        toProgress(progress, onComplete = null) {
          if (progress < this._progress) {
            return;
          }
          let delta = progress - this._progress;
          let deltaY = (Y_1 - Y_0) * delta / 100;
          let dur = 2 * delta / 100;
          let deltaX = this.bar.position.x > 0 ? -300 : 300;
          deltaY = Math.min(Y_1 - this.bar.position.y, deltaY);
          tween(this.bar).stop();
          tween(this.bar).by(dur, {
            position: new Vec3(deltaX, deltaY)
          }).start();
          tween({
            value: this._progress
          }).stop();
          tween({
            value: this._progress
          }).to(dur, {
            value: progress
          }, {
            onUpdate: tweenObj => {
              this.progress = tweenObj.value;
              this.lbl.string = `${tweenObj.value.toFixed(0)}%`;
            }
          }).call(() => {
            this.lbl.string = `${progress.toFixed(0)}%`;
            if (progress == 100 && onComplete) {
              onComplete();
            }
          }).start();
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "bar", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "lbl", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/PZCMUYBUB.ts", ['cc', './CIVTVAVXRORTVD.ts'], function (exports) {
  var cclegacy, sys, CIVTVAVXRORTVD;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      sys = module.sys;
    }, function (module) {
      CIVTVAVXRORTVD = module.CIVTVAVXRORTVD;
    }],
    execute: function () {
      var _class;
      cclegacy._RF.push({}, "e8027YvlhxDkZQaTF4MQX9m", "PZCMUYBUB", undefined);
      class PZCMUYBUB {
        constructor() {
          this.OPQJAPSE = null;
          this.AADYMSBRA = {};
          this.javaKeys = ["boolean", "byte", "char", "double", "false", "float", "int", "long", "new", "short", "true", "void", "instanceof", "break", "case", "catch", "continue", "default", "do", "else", "for", "if", "return", "switch", "try", "while", "finally", "throw", "this", "super", "abstract", "final", "native", "private", "protected", "public", "static", "synchronized", "transient", "volatile", "class", "extends", "implements", "interface", "package", "import", "throws", "true", "false", "null"];
        }
        static MSCGDWEHBPVJEQE() {
          if (this.BPVANCXHADQJFIH.OPQJAPSE == null) {
            this.BPVANCXHADQJFIH.OPQJAPSE = CIVTVAVXRORTVD.OPQJAPSE;
          }
          return this.BPVANCXHADQJFIH;
        }
        IYYWPVKZ(RRLNPL) {
          // console.log(`package: ${RRLNPL}`)
          if (RRLNPL != null && RRLNPL != undefined && RRLNPL != "") {
            let newMethods = this.GOWIAQNRFYRLNEUA(RRLNPL, this.OPQJAPSE);
            if (!(sys.os === sys.OS.ANDROID || sys.os === sys.OS.IOS)) {
              console.log(newMethods);
            }
            if (this.OPQJAPSE.length != newMethods.length) {
              // 制造崩溃
              this.OKQWGITGGGQM("proguard-rules error...");
              return;
            }
            for (let i = 0; i < this.OPQJAPSE.length; i++) {
              this.AADYMSBRA[`${this.OPQJAPSE[i]}`] = newMethods[i];
            }
          }
        }
        SDFLIQOQYBBXD(RRLNPL) {
          let config = CIVTVAVXRORTVD.UPNVTHPQOSZT;
          let java_list = config[`cocos`];
          let doc = [];
          for (let i = 0; i < java_list.length; i++) {
            let md5 = this.NBCWWYDVHXYP(RRLNPL + java_list[i][`version`]);
            let pg_start = java_list[i][`pg_start`];
            let len = parseInt(md5.slice(0, 1), 16) % 5;
            if (len <= 2) {
              len = 2;
            }
            let arr = [];
            for (let i = 0; i < len; i++) {
              arr.push(md5.slice(i * 2, i * 2 + 2));
            }
            let pg_arr = [];
            for (let s of arr) {
              pg_arr.push(this.TXAKXSZWANUGWER(parseInt(s, 16)));
            }
            let pg = pg_start;
            if (pg.length > 0) {
              pg_arr.unshift(pg);
            }
            let target_package_name = pg_arr.slice(0, pg_arr.length - 1).join(".");
            let target_class_name = pg_arr[pg_arr.length - 1];
            doc[i] = `${java_list[i][`title`]}: ${target_package_name}.${target_class_name}`;
          }
          let doc_content = 'wawayu_sdk_doc start*********************\n*********************\n';
          for (let s of doc) {
            doc_content += s + '\n';
          }
          doc_content += '*********************\nwawayu_sdk_doc end*********************';
          console.log(doc_content);
          return doc_content;
        }
        YFQWTUEZ(FEPEVIW) {
          let method = this.AADYMSBRA[`${FEPEVIW}`];
          if (method != null && method != undefined && method != "") {
            return method;
          }
          return FEPEVIW;
        }
        OKQWGITGGGQM(GKNEFOTPIEE) {
          console.log(GKNEFOTPIEE);
          let a = [3];
          a[5] = 2;
        }
        NBCWWYDVHXYP(NAGEQH) {
          let md5 = CryptoES.MD5(NAGEQH).toString();
          return md5;
        }
        FRKERNIVZMGZCWK(XMZXJKZSXNGIR) {
          // let uniqueElements = new Set(lst);
          // // 判断数组长度和集合长度是否相等
          // if (lst.length === uniqueElements.size) {
          //     return false;
          // } else {
          //     return true;
          // }
          let isDup = false;
          let arr = [];
          for (let i = 0; i < XMZXJKZSXNGIR.length; i++) {
            if (arr.indexOf(XMZXJKZSXNGIR[i]) >= 0) {
              isDup = true;
              break;
            } else {
              arr.push(XMZXJKZSXNGIR[i]);
            }
          }
          return isDup;
        }
        GOWIAQNRFYRLNEUA(RRLNPL, XQHYZXTHORTN) {
          if (this.FRKERNIVZMGZCWK(XQHYZXTHORTN)) {
            this.OKQWGITGGGQM(" has duplicates method");
            return [];
          }
          let temp = this.AIZRCIXAD(RRLNPL, XQHYZXTHORTN, 1);
          return temp;
        }
        TXAKXSZWANUGWER(SBKURNYKQLTLIPIV) {
          let code = '';
          if (SBKURNYKQLTLIPIV < 26) {
            code = String.fromCharCode(SBKURNYKQLTLIPIV + 97);
          } else {
            code = this.TXAKXSZWANUGWER(Math.floor(SBKURNYKQLTLIPIV / 26) - 1) + this.TXAKXSZWANUGWER(SBKURNYKQLTLIPIV % 26);
          }
          if (this.javaKeys.indexOf(code) >= 0) {
            code = 'a' + code;
          }
          return code;
        }
        AIZRCIXAD(RRLNPL, DNDVMTZHDLVANJ, NLZHFEXR = 1) {
          let temp = [];
          for (let ele of DNDVMTZHDLVANJ) {
            let com_str = `${RRLNPL}${ele}`;
            // md5后，截取前10位转成数字对10求余得到截取后面的字符，得到末尾字符转数字后得到混淆字典
            // @ts-ignore
            let md5Str = this.NBCWWYDVHXYP(com_str);
            let start_16 = md5Str.slice(0, 6);
            let length = parseInt(start_16, 16) % 10;
            if (length <= NLZHFEXR) {
              length = NLZHFEXR;
            }
            let end_16 = md5Str.slice(-length);
            let v = parseInt(end_16, 16);
            let code = this.TXAKXSZWANUGWER(v);
            temp.push(code);
          }
          // 如果有相同，增加概率递归
          if (this.FRKERNIVZMGZCWK(temp)) {
            NLZHFEXR += 1;
            temp = this.AIZRCIXAD(RRLNPL, DNDVMTZHDLVANJ, NLZHFEXR);
          }
          return temp;
        }
        ZYSDBZW(input) {
          // 将 Base64 转换回原始字符串
          return decodeURIComponent(escape(atob(input)));
        }
      }
      exports('PZCMUYBUB', PZCMUYBUB);
      _class = PZCMUYBUB;
      PZCMUYBUB.BPVANCXHADQJFIH = new _class();
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/QLHROXRCFBPYKY.ts", ['cc', './WBKIRV.ts', './SVDMRMIFJDYHRX.ts'], function (exports) {
  var cclegacy, PSWZDFV, SVDMRMIFJDYHRX;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      PSWZDFV = module.PSWZDFV;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }],
    execute: function () {
      cclegacy._RF.push({}, "5aa30eG91hFwK9zlWNt7OJV", "QLHROXRCFBPYKY", undefined);
      class QLHROXRCFBPYKY extends SVDMRMIFJDYHRX {
        constructor(...args) {
          super(...args);
          this.KPFQFX = null;
          this.PZIHESOKERFKOGDI = false;
          this.JDWTMRORCA = null;
        }
        TGQXAKDAHFFVG() {
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.XPYABAKW, this.XPYABAKW, this);
        }
        QIZLFVUQ() {}
        XPYABAKW(JDWTMRORCA) {
          try {
            this.JDWTMRORCA = atob(JDWTMRORCA);
            if (this.KPFQFX != null) {
              this.KPFQFX.XPYABAKW(this.JDWTMRORCA);
              this.PZIHESOKERFKOGDI = false;
            } else {
              this.PZIHESOKERFKOGDI = true;
            }
          } catch (e) {}
        }
        VKDRJVL(PYGPRHHLLOGJEROQ) {
          this.KPFQFX = PYGPRHHLLOGJEROQ;
          if (this.PZIHESOKERFKOGDI) {
            this.KPFQFX.XPYABAKW(this.JDWTMRORCA);
            this.PZIHESOKERFKOGDI = false;
          }
        }
      }
      exports('QLHROXRCFBPYKY', QLHROXRCFBPYKY);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/random-util.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "8af13WFEz5MbZY1fSiMOa9e", "random-util", undefined);
      class RandomUtil {
        static random(arg1, arg2) {
          if (typeof arg1 === 'number' && typeof arg2 === 'number') {
            return this.randomNumber(arg1, arg2);
          } else if (Array.isArray(arg1)) {
            if (Array.isArray(arg2)) {
              return this.randomInArrayByWeightArray(arg1, arg2);
            } else if (typeof arg2 === 'string') {
              return this.randomInArrayByWeightKey(arg1, arg2);
            } else if (typeof arg2 === 'number') {
              return this.randomElementsInArray(arg1, arg2);
            } else {
              return this.randomElementInArray(arg1);
            }
          } else {
            return this.randomString(arg1);
          }
        }
        static randomString(length) {
          const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
          let result = '';
          for (let i = 0; i < length; i++) {
            const randomIndex = Math.floor(Math.random() * characters.length);
            result += characters.charAt(randomIndex);
          }
          return result;
        }
        static randomNumber(start, end) {
          return Math.floor(Math.random() * (end - start + 1) + start);
        }
        static randomInArrayByWeightArray(values, weights) {
          if (weights.length !== values.length) {
            return this.randomElementInArray(values);
          }
          const index = this.randomIndexByWeight(weights);
          return values[index];
        }
        static randomInArrayByWeightKey(values, weightKey) {
          const weights = values.map(value => value[weightKey] || 0);
          return this.randomInArrayByWeightArray(values, weights);
        }
        static randomIndexByWeight(weights) {
          const sum = weights.reduce((acc, cur) => acc + cur, 0);
          let random = Math.random() * sum;
          for (let i = 0; i < weights.length; i++) {
            random -= weights[i];
            if (random < 0) {
              return i;
            }
          }
          return this.randomNumber(0, weights.length - 1);
        }
        static randomElementInArray(values) {
          return values[this.randomNumber(0, values.length - 1)];
        }
        static randomElementsInArray(arr, count) {
          if (count == 1) {
            return [this.randomElementInArray(arr)];
          }
          if (count >= arr.length) {
            return this.shuffle(this.shuffle(arr));
          }
          const shuffled = arr.slice(); // 创建副本以避免修改原数组
          for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1)); // 生成 [0, i] 范围内的随机索引
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; // 交换元素
          }

          return shuffled.slice(0, count);
        }
        static shuffle(arr) {
          const shuffled = arr.slice(); // 创建副本以避免修改原数组
          for (let i = shuffled.length - 1; i > 0; i--) {
            const j = Math.floor(Math.random() * (i + 1)); // 生成 [0, i] 范围内的随机索引
            [shuffled[i], shuffled[j]] = [shuffled[j], shuffled[i]]; // 交换元素
          }

          return shuffled;
        }
      }
      exports('RandomUtil', RandomUtil);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/rating-popup.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './ui-manager.ts', './audio-manager.ts', './game-constants.ts', './game-data-manager.ts', './bridge-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Label, Node, SpriteFrame, Sprite, _decorator, NodeEventType, UIView, UIManager, AudioManager, AudioUrl, GameDataManager, BridgeUtil, VibrationEffect;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Label = module.Label;
      Node = module.Node;
      SpriteFrame = module.SpriteFrame;
      Sprite = module.Sprite;
      _decorator = module._decorator;
      NodeEventType = module.NodeEventType;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      AudioUrl = module.AudioUrl;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5;
      cclegacy._RF.push({}, "4f4deJbCvhAepgy/ireSPDL", "rating-popup", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let RatingPopup = exports('RatingPopup', (_dec = ccclass('RatingPopup'), _dec2 = property(Label), _dec3 = property(Node), _dec4 = property([SpriteFrame]), _dec5 = property(Sprite), _dec6 = property([SpriteFrame]), _dec(_class = (_class2 = class RatingPopup extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "lblTitle", _descriptor, this);
          _initializerDefineProperty(this, "layout", _descriptor2, this);
          _initializerDefineProperty(this, "sprtStarFrames", _descriptor3, this);
          _initializerDefineProperty(this, "sprtBtnOk", _descriptor4, this);
          _initializerDefineProperty(this, "sprtBtnOkFrames", _descriptor5, this);
          this.ratingNum = 0;
          this.sprtStars = [];
        }
        onOpen(fromUI, ...args) {
          AudioManager.instance.playEffect(AudioUrl.SHOW_POPUP);
          BridgeUtil.vibrate(30, VibrationEffect.CLICK);
          let container = this.layout.getChildByName('StarContainer');
          for (let i = 0; i < container.children.length; i++) {
            let starNode = container.getChildByName(`Star${i}`);
            starNode.on(NodeEventType.TOUCH_START, () => {
              this.setRatingNum(i + 1);
            });
            this.sprtStars.push(starNode.getComponent(Sprite));
          }
          this.lblTitle.string = 'HAVE FUN';
          this.setRatingNum(0);
        }
        onClose() {
          this.sprtStars.forEach(star => {
            star.node.off(NodeEventType.TOUCH_START);
          });
        }
        setRatingNum(val) {
          for (let i = 0; i < this.sprtStars.length; i++) {
            this.sprtStars[i].spriteFrame = i < val ? this.sprtStarFrames[1] : this.sprtStarFrames[0];
          }
          this.sprtBtnOk.spriteFrame = this.sprtBtnOkFrames[val > 0 ? 1 : 0];
          this.ratingNum = val;
        }
        onOKBtn() {
          this.onBtnClicked();
          let gdManager = GameDataManager.instance;
          let uiMgr = UIManager.instance;
          if (this.ratingNum < 1) {
            uiMgr.showToast('Select a star rating and try again.');
          } else {
            if (this.ratingNum > 4) {
              BridgeUtil.openRating();
            } else {
              uiMgr.showToast('Thank you for your evaluation, we will continue to work hard');
            }
            gdManager.data.levelShowRating = -1;
            gdManager.saveData();
            uiMgr.close(this);
          }
        }
        onBtnClicked() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "lblTitle", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "layout", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "sprtStarFrames", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "sprtBtnOk", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "sprtBtnOkFrames", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/reflect-effect-mask.ts", ['cc'], function (exports) {
  var cclegacy, Component, macro, tween, Vec3, _decorator;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Component = module.Component;
      macro = module.macro;
      tween = module.tween;
      Vec3 = module.Vec3;
      _decorator = module._decorator;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "7dfd1b8YEhI+rkKENPb0c8U", "reflect-effect-mask", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let ReflectEffectMask = exports('ReflectEffectMask', (_dec = ccclass('ReflectEffectMask'), _dec(_class = class ReflectEffectMask extends Component {
        onEnable() {
          this.schedule(() => {
            this.playAnim();
          }, 5, macro.REPEAT_FOREVER);
        }
        onDisable() {
          this.unschedule(this.playAnim);
        }
        playAnim() {
          let shine = this.node.getChildByName('Shine');
          shine.active = true;
          let size = 90;
          shine.setPosition(0 - size, size, 0);
          tween(shine).to(1, {
            position: new Vec3(size, 0 - size, 0)
          }).call(() => {
            shine.active = false;
          }).start();
        }
      }) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/report-agent.ts", ['cc', './connect-agent.ts', './game-data-manager.ts', './CJXOHZKFR.ts'], function (exports) {
  var cclegacy, ConnectAgent, GameDataManager, CJXOHZKFR;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      ConnectAgent = module.ConnectAgent;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      CJXOHZKFR = module.CJXOHZKFR;
    }],
    execute: function () {
      cclegacy._RF.push({}, "33cf49fcRFCT4xfEtsIGqj+", "report-agent", undefined); // import { GameSDKCore } from "../connect/sdk/RoundPro/GameSDKCore";
      let MajorTokenReportEvent = exports('MajorTokenReportEvent', /*#__PURE__*/function (MajorTokenReportEvent) {
        MajorTokenReportEvent[MajorTokenReportEvent["SHOW_ACCOUNT"] = 0] = "SHOW_ACCOUNT";
        MajorTokenReportEvent[MajorTokenReportEvent["SHOW_REWARD"] = 1] = "SHOW_REWARD";
        MajorTokenReportEvent[MajorTokenReportEvent["OBTAIN_REWARD"] = 2] = "OBTAIN_REWARD";
        MajorTokenReportEvent[MajorTokenReportEvent["GET_REWARD"] = 3] = "GET_REWARD";
        MajorTokenReportEvent[MajorTokenReportEvent["SHOW_FREE_REWARD"] = 4] = "SHOW_FREE_REWARD";
        MajorTokenReportEvent[MajorTokenReportEvent["OBTAIN_FREE_REWARD"] = 5] = "OBTAIN_FREE_REWARD";
        MajorTokenReportEvent[MajorTokenReportEvent["GET_FREDD_REWARD"] = 6] = "GET_FREDD_REWARD";
        MajorTokenReportEvent[MajorTokenReportEvent["START_GAME"] = 7] = "START_GAME";
        return MajorTokenReportEvent;
      }({}));
      let PhotoChooseNumReportEvent = exports('PhotoChooseNumReportEvent', /*#__PURE__*/function (PhotoChooseNumReportEvent) {
        PhotoChooseNumReportEvent[PhotoChooseNumReportEvent["SHOW"] = 1] = "SHOW";
        PhotoChooseNumReportEvent[PhotoChooseNumReportEvent["SELECTED"] = 2] = "SELECTED";
        PhotoChooseNumReportEvent[PhotoChooseNumReportEvent["UNLOCKED"] = 3] = "UNLOCKED";
        PhotoChooseNumReportEvent[PhotoChooseNumReportEvent["DOWNLOADED"] = 4] = "DOWNLOADED";
        return PhotoChooseNumReportEvent;
      }({}));
      let CustomReportEvent = exports('CustomReportEvent', /*#__PURE__*/function (CustomReportEvent) {
        CustomReportEvent["HOME_START_GAME"] = "homeStartGame";
        CustomReportEvent["PLAY_GAME"] = "playGame";
        CustomReportEvent["GAME_END"] = "gameEnd";
        CustomReportEvent["LEVEL_UPGRADE"] = "levelupgrade";
        CustomReportEvent["WWY_GAME_LIFE_KEY_NODE"] = "game_life_key_node";
        CustomReportEvent["AD_EVENT_DISTRIBUTED"] = "ad_event_distributed";
        CustomReportEvent["USER_LIFECYCLE_MILESTONE"] = "user_lifecycle_milestone";
        CustomReportEvent["STABLE_MONITOR"] = "stable_monitor";
        CustomReportEvent["PHOTO_CHOOSE_NUM"] = "photo_choose_num";
        CustomReportEvent["INTER_VIDEO_SCENE"] = "inter_video_scene";
        CustomReportEvent["LOADING"] = "name_loading";
        CustomReportEvent["SDK_THEME_STUFF"] = "sdk_theme_stuff";
        CustomReportEvent["LOADING_GRAPH_TASK"] = "main_process_monitoring";
        CustomReportEvent["PAGE_SHOW_MONITORING"] = "page_show_monitoring";
        CustomReportEvent["PAGE_BUTTON_ACTION"] = "page_button_action";
        return CustomReportEvent;
      }({}));

      // loading graph
      let LoadingTaskType = exports('LoadingTaskType', /*#__PURE__*/function (LoadingTaskType) {
        LoadingTaskType["SPECIAL_A"] = "special_a";
        LoadingTaskType["SPECIAL_B"] = "special_b";
        LoadingTaskType["LEVEL_WIN_A"] = "level_win_a";
        LoadingTaskType["LEVEL_WIN_B"] = "level_win_b";
        LoadingTaskType["SELECT_A"] = "select_a";
        LoadingTaskType["DOWNLOAD"] = "download";
        return LoadingTaskType;
      }({}));
      let LoadingTaskState = exports('LoadingTaskState', /*#__PURE__*/function (LoadingTaskState) {
        LoadingTaskState["START"] = "start";
        LoadingTaskState["SUCCESS"] = "success";
        LoadingTaskState["FAIL"] = "failed";
        return LoadingTaskState;
      }({}));
      class LoadingTaskReportInfo {
        constructor(pic_id, type, state, time_stamp, duration = 0, cur_lv = 0) {
          this.type = LoadingTaskType.SPECIAL_A;
          this.state = LoadingTaskState.START;
          this.time_stamp = 0;
          this.duration = 0;
          this.cur_lv = 0;
          this.pic_id = '';
          this.type = type;
          this.state = state;
          this.time_stamp = time_stamp;
          this.duration = duration;
          this.cur_lv = cur_lv;
          this.pic_id = pic_id;
        }
      }
      exports('LoadingTaskReportInfo', LoadingTaskReportInfo);
      let PageName = exports('PageName', /*#__PURE__*/function (PageName) {
        PageName["None"] = "";
        PageName["SpecialRewardPopup"] = "special_reward_popup";
        PageName["PictureObtainPopup"] = "picture_obtain_popup";
        PageName["PictureSelectView"] = "picture_select_view";
        PageName["LevelWin"] = "level_win";
        PageName["SlidePictureView"] = "slide_picture_view";
        PageName["SlidePictureViewSpeical"] = "slide_picture_view_special";
        PageName["DownLoadPage"] = "download_page";
        PageName["AdUnlockPopup"] = "ad_unlock_popup";
        return PageName;
      }({}));
      let BtnName = exports('BtnName', /*#__PURE__*/function (BtnName) {
        BtnName["Continue"] = "continue";
        BtnName["Unlock"] = "unlock";
        BtnName["Download"] = "download";
        BtnName["Get"] = "get";
        BtnName["Close"] = "close";
        BtnName["Pick"] = "pick";
        BtnName["Refresh"] = "refresh";
        return BtnName;
      }({}));
      class PageSuccessData {
        constructor(pageName) {
          this.page_name = PageName.None;
          this.total_time = 0;
          this.success_time = 0;
          this.fail_times = 0;
          this.page_name = pageName;
        }
      }
      exports('PageSuccessData', PageSuccessData);
      class ReportAgent {
        static reportMajorTokenEvent(event) {
          switch (event) {
            case MajorTokenReportEvent.SHOW_ACCOUNT:
              {
                // pp卡卡槽展示
                CJXOHZKFR.IGXFCDIINLIFOQLM();
              }
              break;
            case MajorTokenReportEvent.SHOW_REWARD:
              {
                // pp卡弹窗展示
                CJXOHZKFR.WDYXWDHX();
              }
              break;
            case MajorTokenReportEvent.OBTAIN_REWARD:
              {
                // pp卡点击领取
                CJXOHZKFR.XMGYNYKGAGOLMDW();
              }
              break;
            case MajorTokenReportEvent.GET_REWARD:
              {
                // pp卡领取成功
                CJXOHZKFR.DIZUYVYWXWFRKAXH();
              }
              break;
            case MajorTokenReportEvent.SHOW_FREE_REWARD:
              {
                // pp卡免费奖励展示
                CJXOHZKFR.ARYHPYJLVTXGU();
              }
              break;
            case MajorTokenReportEvent.OBTAIN_FREE_REWARD:
              {
                // pp卡免费奖励点击
                CJXOHZKFR.BZLOZQPQE();
              }
              break;
            case MajorTokenReportEvent.GET_FREDD_REWARD:
              {
                // pp卡免费奖励领取成功
                CJXOHZKFR.JGEXBWTYOHB();
              }
              break;
            case MajorTokenReportEvent.START_GAME:
              {
                // 显示游戏界面（冷启动后引擎载入后的第一屏）
                CJXOHZKFR.UCVHOJDVSTUTMOX();
              }
          }
        }
        static reportCustomEvent(event, params) {
          console.log(`reportCustomEvent-event:${event}, params:${JSON.stringify(params)}`);
          ConnectAgent.reportCustomEvent(event, params);
        }
        static reportPageMonitoring(pageName, isError, show_num) {
          let gdMgr = GameDataManager.instance;
          gdMgr.addPageShowData(pageName, isError);
          let showData = gdMgr.localData.pageSuccessDataList.find(item => item.page_name == pageName);
          ReportAgent.reportCustomEvent(CustomReportEvent.PAGE_SHOW_MONITORING, {
            page_type: pageName,
            show_result: isError ? 'failed' : 'success',
            level_current: gdMgr.data.level,
            show_times_total: showData.total_time,
            success_rate: Math.floor(showData.success_time / showData.total_time * 100) / 100,
            show_num: show_num,
            success_times: showData.success_time,
            fail_times: showData.fail_times
          });
        }
      }
      exports('ReportAgent', ReportAgent);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/request-manager.ts", ['cc', './config.ts', './common-util.ts', './http-agent.ts'], function (exports) {
  var cclegacy, Config, CommonUtil, HttpAgent;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      CommonUtil = module.CommonUtil;
    }, function (module) {
      HttpAgent = module.HttpAgent;
    }],
    execute: function () {
      cclegacy._RF.push({}, "99a7498ERpIDp8qENe4A+Gm", "request-manager", undefined);
      class ReqeustManager {
        constructor() {
          this.timeout = 6000;
          // 请求超时时间（毫秒）
          this.maxRetries = 2;
          // 最大重试次数
          this.retryDelay = 300;
          // 每次重试的间隔时间（毫秒）
          this.header = {
            'Content-Type': 'application/json',
            'Cache-Control': 'no-cache, no-store, must-revalidate',
            'Pragma': 'no-cache',
            'Expires': '0'
          };
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new ReqeustManager();
          }
          return this._instance;
        }
        async get(url, params) {
          return this.requestWithRetry(url, 'GET', this.timeout, params);
        }
        async post(url, params) {
          return this.requestWithRetry(url, 'POST', this.timeout, params);
        }
        async requestWithRetry(url, method, timeout, params, retries = this.maxRetries) {
          try {
            // 尝试发送请求
            return await this.request(url, method, timeout, params);
          } catch (error) {
            if (retries > 0) {
              console.warn(`Request failed. Retrying... (${this.maxRetries - retries + 1}/${this.maxRetries})`);
              await CommonUtil.delay(this.retryDelay);
              return this.requestWithRetry(url, method, timeout, params, retries - 1);
            } else {
              console.error('Request failed after maximum retries:', error);
              throw error;
            }
          }
        }
        async request(url, method, timeout, params) {
          url = Config.API_URL + url;
          const headers = this.buildHeader();
          console.log(`${method} - Request URL:${url} , params:${params}`);
          return HttpAgent.request(url, method, headers, timeout, params);
        }
        buildHeader(headers) {
          if (!!headers) {
            return new Headers({
              ...this.header,
              ...headers
            });
          }
          return new Headers(this.header);
        }
      }
      exports('ReqeustManager', ReqeustManager);
      ReqeustManager._instance = void 0;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/res-keeper.ts", ['cc', './res-loader.ts'], function (exports) {
  var cclegacy, Component, _decorator, resLoader;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Component = module.Component;
      _decorator = module._decorator;
    }, function (module) {
      resLoader = module.resLoader;
    }],
    execute: function () {
      var _class;
      cclegacy._RF.push({}, "633deonDmNICIpeqT64Haxo", "res-keeper", undefined);
      /**
       * 资源引用类
       * 1. 提供加载功能，并记录加载过的资源
       * 2. 在node释放时自动清理加载过的资源
       * 3. 支持手动添加记录
       */
      const {
        ccclass
      } = _decorator;
      let ResKeeper = exports('ResKeeper', ccclass(_class = class ResKeeper extends Component {
        constructor(...args) {
          super(...args);
          this.resCache = new Set();
        }
        /**
         * 开始加载资源
         * @param bundle        assetbundle的路径
         * @param url           资源url或url数组
         * @param type          资源类型，默认为null
         * @param onProgess     加载进度回调
         * @param onCompleted   加载完成回调
         */
        load(...args) {
          // 调用加载接口
          resLoader.load.apply(resLoader, args);
        }

        /**
         * 缓存资源
         * @param asset 
         */
        cacheAsset(asset) {
          if (!this.resCache.has(asset)) {
            asset.addRef();
            this.resCache.add(asset);
          }
        }

        /**
         * 组件销毁时自动释放所有keep的资源
         */
        onDestroy() {
          this.releaseAssets();
        }

        /**
         * 释放资源，组件销毁时自动调用
         */
        releaseAssets() {
          if (!this.resCache) {
            this.resCache = new Set();
          }
          this.resCache.forEach(element => {
            element.decRef();
          });
          this.resCache.clear();
        }
      }) || _class);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/res-leak-checker.ts", ['cc', './res-util.ts', './log-util.ts'], function (exports) {
  var cclegacy, ResUtil, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      ResUtil = module.ResUtil;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      cclegacy._RF.push({}, "f53e6WROUNP9KZOApNQ0eR5", "res-leak-checker", undefined);
      class ResLeakChecker {
        constructor() {
          this.resFilter = null;
          // 资源过滤回调
          this._checking = false;
          this.traceAssets = new Set();
        }
        /**
         * 检查该资源是否符合过滤条件
         * @param url 
         */
        checkFilter(asset) {
          if (!this._checking) {
            return false;
          }
          if (this.resFilter) {
            return this.resFilter(asset);
          }
          return true;
        }

        /**
         * 对资源进行引用的跟踪
         * @param asset 
         */
        traceAsset(asset) {
          if (!asset || !this.checkFilter(asset)) {
            return;
          }
          if (!this.traceAssets.has(asset)) {
            asset.addRef();
            this.traceAssets.add(asset);
            this.extendAsset(asset);
          }
        }

        /**
         * 扩展asset，使其支持引用计数追踪
         * @param asset 
         */
        extendAsset(asset) {
          let addRefFunc = asset.addRef;
          let decRefFunc = asset.decRef;
          let traceMap = new Map();
          asset.traceMap = traceMap;
          asset.addRef = function (...args) {
            let stack = ResUtil.getCallStack(1);
            let cnt = traceMap.has(stack) ? traceMap.get(stack) + 1 : 1;
            traceMap.set(stack, cnt);
            return addRefFunc.apply(asset, args);
          };
          asset.decRef = function (...args) {
            let stack = ResUtil.getCallStack(1);
            let cnt = traceMap.has(stack) ? traceMap.get(stack) + 1 : 1;
            traceMap.set(stack, cnt);
            return decRefFunc.apply(asset, args);
          };
          asset.resetTrace = () => {
            asset.addRef = addRefFunc;
            asset.decRef = decRefFunc;
            delete asset.traceMap;
          };
        }

        /**
         * 还原asset，使其恢复默认的引用计数功能
         * @param asset 
         */
        resetAsset(asset) {
          if (asset.resetTrace) {
            asset.resetTrace();
          }
        }
        untraceAsset(asset) {
          if (this.traceAssets.has(asset)) {
            this.resetAsset(asset);
            asset.decRef();
            this.traceAssets.delete(asset);
          }
        }
        startCheck() {
          this._checking = true;
        }
        stopCheck() {
          this._checking = false;
        }
        getTraceAssets() {
          return this.traceAssets;
        }
        reset() {
          this.traceAssets.forEach(element => {
            this.resetAsset(element);
            element.decRef();
          });
          this.traceAssets.clear();
        }
        dump() {
          this.traceAssets.forEach(element => {
            let traceMap = element.traceMap;
            if (traceMap) {
              traceMap.forEach((key, value) => {
                LogUtil.log(`${key} : ${value} `);
              });
            }
          });
        }
      }
      exports('ResLeakChecker', ResLeakChecker);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/res-loader.ts", ['cc'], function (exports) {
  var js, Asset, assetManager, resources, cclegacy;
  return {
    setters: [function (module) {
      js = module.js;
      Asset = module.Asset;
      assetManager = module.assetManager;
      resources = module.resources;
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "d5026ibTpBFnraX+zxbrCVW", "res-loader", undefined);
      class ResLoader {
        constructor() {
          this.defaultBundleName = "resources";
        }
        parseLoadResArgs(paths, type, onProgress, onComplete) {
          let pathsOut = paths;
          let typeOut = type;
          let onProgressOut = onProgress;
          let onCompleteOut = onComplete;
          if (onComplete === undefined) {
            const isValidType = js.isChildClassOf(type, Asset);
            if (onProgress) {
              onCompleteOut = onProgress;
              if (isValidType) {
                onProgressOut = null;
              }
            } else if (onProgress === undefined && !isValidType) {
              onCompleteOut = type;
              onProgressOut = null;
              typeOut = null;
            }
            if (onProgress !== undefined && !isValidType) {
              onProgressOut = type;
              typeOut = null;
            }
          }
          return {
            paths: pathsOut,
            type: typeOut,
            onProgress: onProgressOut,
            onComplete: onCompleteOut
          };
        }
        loadByBundleAndArgs(bundle, args) {
          if (args.dir) {
            bundle.loadDir(args.paths, args.type, args.onProgress, args.onComplete);
          } else {
            if (typeof args.paths == 'string') {
              bundle.load(args.paths, args.type, args.onProgress, args.onComplete);
            } else {
              bundle.load(args.paths, args.type, args.onProgress, args.onComplete);
            }
          }
        }
        loadByArgs(args) {
          if (args.bundle) {
            if (assetManager.bundles.has(args.bundle)) {
              let bundle = assetManager.bundles.get(args.bundle);
              this.loadByBundleAndArgs(bundle, args);
            } else {
              // 自动加载bundle
              assetManager.loadBundle(args.bundle, (err, bundle) => {
                if (!err) {
                  this.loadByBundleAndArgs(bundle, args);
                }
              });
            }
          } else {
            this.loadByBundleAndArgs(resources, args);
          }
        }
        load(bundleName, paths, type, onProgress, onComplete) {
          let args = null;
          if (typeof paths === "string" || paths instanceof Array) {
            args = this.parseLoadResArgs(paths, type, onProgress, onComplete);
            args.bundle = bundleName;
          } else {
            args = this.parseLoadResArgs(bundleName, paths, type, onProgress);
          }
          this.loadByArgs(args);
        }

        /**
         * 异步加载一个资源
         * @param bundleName    远程包名
         * @param paths         资源路径
         * @param type          资源类型
         */

        loadAsync(bundleName, paths, type) {
          return new Promise((resolve, reject) => {
            this.load(bundleName, paths, type, (err, asset) => {
              if (err) {
                console.error(err.message);
              }
              resolve(asset);
            });
          });
        }
        loadDir(bundleName, dir, type, onProgress, onComplete) {
          let args = null;
          if (typeof dir === "string") {
            args = this.parseLoadResArgs(dir, type, onProgress, onComplete);
            args.bundle = bundleName;
          } else {
            args = this.parseLoadResArgs(bundleName, dir, type, onProgress);
          }
          args.dir = args.paths;
          this.loadByArgs(args);
        }
        loadRemote(url, ...args) {
          assetManager.loadRemote(url, args);
        }

        /**
         * 通过资源相对路径释放资源
         * @param path          资源路径
         * @param bundleName    远程资源包名
         */
        release(path, bundleName = this.defaultBundleName) {
          const bundle = assetManager.getBundle(bundleName);
          if (bundle) {
            const asset = bundle.get(path);
            if (asset) {
              this.releasePrefabtDepsRecursively(asset);
            }
          }
        }

        /**
         * 通过相对文件夹路径删除所有文件夹中资源
         * @param path          资源文件夹路径
         * @param bundleName    远程资源包名
         */
        releaseDir(path, bundleName = this.defaultBundleName) {
          const bundle = assetManager.getBundle(bundleName);
          if (bundle) {
            var infos = bundle.getDirWithPath(path);
            if (infos) {
              infos.map(info => {
                this.releasePrefabtDepsRecursively(info.uuid);
              });
            }
            if (path == "" && bundleName != "resources") {
              assetManager.removeBundle(bundle);
            }
          }
        }

        /** 释放预制依赖资源 */
        releasePrefabtDepsRecursively(uuid) {
          if (uuid instanceof Asset) {
            uuid.decRef();
            // assetManager.releaseAsset(uuid);
          } else {
            const asset = assetManager.assets.get(uuid);
            if (asset) {
              asset.decRef();
              // assetManager.releaseAsset(asset);
            }
          }
        }

        /**
         * 获取资源
         * @param path          资源路径
         * @param type          资源类型
         * @param bundleName    远程资源包名
         */
        get(path, type, bundleName = this.defaultBundleName) {
          var bundle = assetManager.getBundle(bundleName);
          return bundle.get(path, type);
        }
      }
      exports('default', ResLoader);
      let resLoader = exports('resLoader', new ResLoader());
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/res-util.ts", ['cc', './res-keeper.ts'], function (exports) {
  var cclegacy, Asset, instantiate, ResKeeper;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Asset = module.Asset;
      instantiate = module.instantiate;
    }, function (module) {
      ResKeeper = module.ResKeeper;
    }],
    execute: function () {
      cclegacy._RF.push({}, "ebc48bvSj1LBZgy/61GukeZ", "res-util", undefined);
      /**
       * 资源使用相关工具类
       * 2020-1-18
       */

      class ResUtil {
        /**
         * 开始加载资源
         * @param bundle        assetbundle的路径
         * @param url           资源url或url数组
         * @param type          资源类型，默认为null
         * @param onProgess     加载进度回调
         * @param onCompleted   加载完成回调
         */

        static load(attachNode, ...args) {
          let keeper = ResUtil.getResKeeper(attachNode);
          keeper.load.apply(keeper, args);
        }

        /**
         * 从目标节点或其父节点递归查找一个资源挂载组件
         * @param attachNode 目标节点
         * @param autoCreate 当目标节点找不到ResKeeper时是否自动创建一个
         */
        static getResKeeper(attachNode, autoCreate) {
          if (attachNode) {
            let ret = attachNode.getComponent(ResKeeper);
            if (!ret) {
              if (autoCreate) {
                return attachNode.addComponent(ResKeeper);
              } else {
                return ResUtil.getResKeeper(attachNode.parent, autoCreate);
              }
            }
            return ret;
          }
          // 返回一个默认的ResKeeper
          return null;
        }

        /**
        * 赋值srcAsset，并使其跟随targetNode自动释放，用法如下
        * mySprite.spriteFrame = AssignWith(otherSpriteFrame, mySpriteNode);
        * @param srcAsset 用于赋值的资源，如cc.SpriteFrame、cc.Texture等等
        * @param targetNode 
        * @param autoCreate 
        */
        static assignWith(srcAsset, targetNode, autoCreate) {
          let keeper = ResUtil.getResKeeper(targetNode, autoCreate);
          if (keeper && srcAsset instanceof Asset) {
            keeper.cacheAsset(srcAsset);
            return srcAsset;
          } else {
            console.error(`assignWith ${srcAsset} to ${targetNode} faile`);
            return null;
          }
        }

        /**
         * 实例化一个prefab，并带自动释放功能
         * @param prefab 要实例化的预制
         */
        static instantiate(prefab) {
          let node = instantiate(prefab);
          let keeper = ResUtil.getResKeeper(node, true);
          if (keeper) {
            keeper.cacheAsset(prefab);
          }
          return node;
        }

        /**
         * 从字符串中查找第N个字符
         * @param str 目标字符串
         * @param cha 要查找的字符
         * @param num 第N个
         */
        static findCharPos(str, cha, num) {
          let x = str.indexOf(cha);
          let ret = x;
          for (var i = 0; i < num; i++) {
            x = str.indexOf(cha, x + 1);
            if (x != -1) {
              ret = x;
            } else {
              return ret;
            }
          }
          return ret;
        }

        /**
         * 获取当前调用堆栈
         * @param popCount 要弹出的堆栈数量
         */
        static getCallStack(popCount) {
          // 严格模式无法访问 arguments.callee.caller 获取堆栈，只能先用Error的stack
          let ret = new Error().stack;
          let pos = ResUtil.findCharPos(ret, '\n', popCount);
          if (pos > 0) {
            ret = ret.slice(pos);
          }
          return ret;
        }
      }
      exports('ResUtil', ResUtil);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/reward-anim-controller.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './reward-type-define.ts', './random-util.ts', './audio-manager.ts', './game-constants.ts', './home-view.ts', './log-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Prefab, Node, _decorator, Component, NodePool, director, UITransform, tween, Vec3, instantiate, ItemType, RandomUtil, AudioManager, GameEvent, AudioUrl, HomeView, LogUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Prefab = module.Prefab;
      Node = module.Node;
      _decorator = module._decorator;
      Component = module.Component;
      NodePool = module.NodePool;
      director = module.director;
      UITransform = module.UITransform;
      tween = module.tween;
      Vec3 = module.Vec3;
      instantiate = module.instantiate;
    }, function (module) {
      ItemType = module.ItemType;
    }, function (module) {
      RandomUtil = module.RandomUtil;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      GameEvent = module.GameEvent;
      AudioUrl = module.AudioUrl;
    }, function (module) {
      HomeView = module.HomeView;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "28b29rdMFBMxIgYEmGqeu5p", "reward-anim-controller", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let RewardAnimController = exports('RewardAnimController', (_dec = ccclass('RewardAnimController'), _dec2 = property(Prefab), _dec3 = property(Prefab), _dec4 = property(Node), _dec5 = property(Node), _dec(_class = (_class2 = class RewardAnimController extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "prfbMinorToken", _descriptor, this);
          _initializerDefineProperty(this, "prfbFragment", _descriptor2, this);
          _initializerDefineProperty(this, "magic", _descriptor3, this);
          _initializerDefineProperty(this, "undo", _descriptor4, this);
          this.poolSize = 10;
          this.minorTokenPool = new NodePool();
          this.fragmentPool = new NodePool();
        }
        onEnable() {
          director.on(GameEvent.ITEM_GAIN_ANIM, this.playGainItemAnim, this);
        }
        onDisable() {
          director.off(GameEvent.ITEM_GAIN_ANIM, this.playGainItemAnim, this);
        }

        /**
         * 播放获得物品动画
         * @param startPos 起点（世界坐标）
         * @param endPos 终点（世界坐标）
         * @param count 数量
         * @param itemId 物品类型
         */
        playGainItemAnim(startPos, count, itemId) {
          startPos = this.getComponent(UITransform).convertToNodeSpaceAR(startPos);
          let endPos = this.getEndPos(itemId);
          endPos = this.getComponent(UITransform).convertToNodeSpaceAR(endPos);
          if (!endPos) return;
          let dur = 1;
          switch (itemId) {
            case ItemType.MinorToken:
            case ItemType.Fragment:
              {
                for (let i = 0; i < count; i++) {
                  let item = this.createToken(itemId);
                  if (!item) {
                    LogUtil.error(`createToken failed, itemId:${itemId}`);
                    continue;
                  }
                  this.node.addChild(item);
                  let offsetX = RandomUtil.random(-250, 250);
                  let offsetY = RandomUtil.random(-250, 250);
                  item.setPosition(new Vec3(startPos.x + offsetX, startPos.y + offsetY, startPos.z));
                  tween(item).delay(0.1 * i).to(dur, {
                    position: endPos
                  }, {
                    easing: 'sineOut'
                  }).call(() => {
                    AudioManager.instance.playEffect(AudioUrl.GAIN_MAJOR);
                    this.removeToken(item, itemId);
                  }).start();
                }
              }
              break;
            case ItemType.Magic:
              {
                this.magic.active = true;
                this.undo.setScale(1, 1, 1);
                this.magic.setPosition(startPos);
                tween(this.magic).to(dur, {
                  position: endPos,
                  scale: new Vec3(0.26, 0.26, 0.26)
                }, {
                  easing: 'sineOut'
                }).call(() => {
                  this.magic.active = false;
                }).start();
              }
              break;
            case ItemType.Undo:
              {
                this.undo.active = true;
                this.undo.setScale(1, 1, 1);
                this.undo.setPosition(startPos);
                tween(this.undo).to(dur, {
                  position: endPos,
                  scale: new Vec3(0.35, 0.35, 0.35)
                }, {
                  easing: 'sineOut'
                }).call(() => {
                  this.undo.active = false;
                }).start();
              }
              break;
          }
        }
        createToken(itemId) {
          switch (itemId) {
            case ItemType.MinorToken:
              {
                let token = this.minorTokenPool.get();
                if (!token) {
                  token = instantiate(this.prfbMinorToken);
                }
                return token;
              }
            case ItemType.Fragment:
              {
                let fragment = this.fragmentPool.get();
                if (!fragment) {
                  fragment = instantiate(this.prfbFragment);
                }
                return fragment;
              }
          }
          return null;
        }
        removeToken(token, itemId) {
          switch (itemId) {
            case ItemType.MinorToken:
              {
                if (this.minorTokenPool.size() >= this.poolSize) {
                  token.destroy();
                  return;
                }
                this.minorTokenPool.put(token);
              }
              break;
            case ItemType.Fragment:
              {
                if (this.fragmentPool.size() >= this.poolSize) {
                  token.destroy();
                  return;
                }
                this.fragmentPool.put(token);
              }
              break;
          }
        }
        getEndPos(itemId) {
          let homeView = director.getScene().getChildByPath('Canvas/uiLayer/HomeView');
          if (!homeView) {
            LogUtil.error('homeView not found');
            return null;
          }
          let comp = homeView.getComponent(HomeView);
          switch (itemId) {
            case ItemType.MinorToken:
              let minorIcon = director.getScene().getChildByPath('Canvas/midLayer/LayoutTokenAccount/TokenMinorAccount/Icon');
              return minorIcon.parent.getComponent(UITransform).convertToWorldSpaceAR(minorIcon.position);
            case ItemType.Magic:
              return comp.btnMagic.node.parent.getComponent(UITransform).convertToWorldSpaceAR(comp.btnMagic.node.getPosition());
            case ItemType.Undo:
              return comp.btnUndo.node.parent.getComponent(UITransform).convertToWorldSpaceAR(comp.btnUndo.node.getPosition());
            case ItemType.Fragment:
              let fragment = director.getScene().getChildByPath('Canvas/midLayer/LayoutTokenAccount/FragmentAccount/Icon');
              return fragment.parent.getComponent(UITransform).convertToWorldSpaceAR(fragment.position);
          }
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "prfbMinorToken", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "prfbFragment", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "magic", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "undo", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/reward-get-popup.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './game-data-manager.ts', './game-constants.ts', './reward-type-define.ts', './ui-manager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Label, Node, _decorator, UITransform, director, UIView, GameDataManager, GameEvent, ItemType, UIManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Label = module.Label;
      Node = module.Node;
      _decorator = module._decorator;
      UITransform = module.UITransform;
      director = module.director;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      GameEvent = module.GameEvent;
    }, function (module) {
      ItemType = module.ItemType;
    }, function (module) {
      UIManager = module.UIManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "bf85fAere1OpKB/SngkqXz9", "reward-get-popup", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let RewardGetPopup = exports('RewardGetPopup', (_dec = ccclass('RewardGetPopup'), _dec2 = property(Label), _dec3 = property(Label), _dec4 = property(Node), _dec5 = property(Node), _dec(_class = (_class2 = class RewardGetPopup extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "lblTokenAmount", _descriptor, this);
          _initializerDefineProperty(this, "lblFragmentAmount", _descriptor2, this);
          _initializerDefineProperty(this, "clickArea", _descriptor3, this);
          _initializerDefineProperty(this, "descLbl", _descriptor4, this);
          this.tokenCount = 0;
          this.fragmentCount = 0;
        }
        onOpen(fromUI, ...args) {
          let data = args[0];
          this.clickArea.active = false;
          this.descLbl.active = false;
          this.scheduleOnce(() => {
            this.clickArea.active = true;
            this.descLbl.active = true;
          }, 1);
          this.tokenCount = data.token_amount;
          this.lblTokenAmount.node.parent.active = data.token_amount > 0;
          this.lblTokenAmount.string = `x${data.token_amount}`;
          this.fragmentCount = data.fragment_amount;
          this.lblFragmentAmount.node.parent.active = data.fragment_amount > 0;
          this.lblFragmentAmount.string = `x${data.fragment_amount}`;
        }
        onClose() {
          let gdMgr = GameDataManager.instance;
          let token = this.lblTokenAmount.node.parent;
          if (token.active) {
            gdMgr.addMinorToken(this.tokenCount);
            let startPos = token.getComponent(UITransform).convertToWorldSpaceAR(token.position);
            director.emit(GameEvent.ITEM_GAIN_ANIM, startPos, 10, ItemType.MinorToken);
          }
          let fragment = this.lblFragmentAmount.node.parent;
          if (fragment.active) {
            gdMgr.addFragment(this.fragmentCount);
            let startPos = fragment.getComponent(UITransform).convertToWorldSpaceAR(fragment.position);
            director.emit(GameEvent.ITEM_GAIN_ANIM, startPos, 10, ItemType.Fragment);
          }
          GameDataManager.instance.saveData(true);
        }
        onClickArea() {
          UIManager.instance.close(this);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "lblTokenAmount", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "lblFragmentAmount", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "clickArea", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "descLbl", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/reward-manager.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './object-util.ts', './game-data-manager.ts', './default-config.ts', './reward-type-define.ts', './mount-manager.ts', './mount-point.ts', './log-util.ts', './time-agent.ts', './random-util.ts', './ui-manager.ts', './ui-config.ts', './config.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, sys, ObjectUtil, ClassType, GameDataManager, REWARD_CONFIG_DEFAULT, RewardConfig, ItemType, RealRewardAction, MountManager, MountPoint, LogUtil, TimeAgent, RandomUtil, UIManager, UIID, Config;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      sys = module.sys;
    }, function (module) {
      ObjectUtil = module.ObjectUtil;
      ClassType = module.ClassType;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      REWARD_CONFIG_DEFAULT = module.REWARD_CONFIG_DEFAULT;
    }, function (module) {
      RewardConfig = module.RewardConfig;
      ItemType = module.ItemType;
      RealRewardAction = module.RealRewardAction;
    }, function (module) {
      MountManager = module.MountManager;
    }, function (module) {
      MountPoint = module.MountPoint;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      TimeAgent = module.TimeAgent;
    }, function (module) {
      RandomUtil = module.RandomUtil;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      UIID = module.UIID;
    }, function (module) {
      Config = module.Config;
    }],
    execute: function () {
      var _dec, _class, _descriptor, _class2;
      cclegacy._RF.push({}, "aac96cMWFFG45I08Vp0TTy3", "reward-manager", undefined);
      let RewardManager = exports('RewardManager', (_dec = ClassType(RewardConfig), (_class = (_class2 = class RewardManager {
        constructor() {
          _initializerDefineProperty(this, "config", _descriptor, this);
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new RewardManager();
          }
          return this._instance;
        }
        initConfig(config) {
          if (!config) {
            config = REWARD_CONFIG_DEFAULT;
          }
          try {
            this.config = ObjectUtil.fromPlain(RewardConfig, config);
          } catch (error) {
            LogUtil.error("initConfig error:", error);
          }
        }
        getConfig() {
          return this.config;
        }
        isSg() {
          if (sys.isBrowser) {
            return true;
          }
          return this.config.sg.is_sg;
        }
        getToolNum(itemId, isFree) {
          let toolCfg = this.config.tool;
          switch (itemId) {
            case ItemType.Magic:
              return isFree ? toolCfg.magic.free_amount : toolCfg.magic.paid_amount;
            case ItemType.Undo:
              return isFree ? toolCfg.undo.free_amount : toolCfg.undo.paid_amount;
          }
        }
        getToolPrice(itemId) {
          let toolCfg = this.config.tool;
          switch (itemId) {
            case ItemType.Magic:
              return toolCfg.magic.price_by_minor;
            case ItemType.Undo:
              return toolCfg.magic.price_by_minor;
          }
        }
        getSignInReward(idx) {
          let signInCfg = this.config.sign_in;
          return signInCfg.rewards[idx];
        }
        getRewardAmountWithData(itemId, target, isRedeem, account) {
          let rangeCfg = this.config.range;
          let cfgList = [];
          switch (itemId) {
            case ItemType.MajorToken:
              {
                cfgList = isRedeem ? rangeCfg.major_after_redeem : rangeCfg.major_before_redeem;
              }
              break;
            case ItemType.MinorToken:
              {
                cfgList = rangeCfg.minor;
              }
              break;
          }
          if (!cfgList) {
            cfgList = [];
          }
          for (let i = 0; i < cfgList.length; i++) {
            let cfg = cfgList[i];
            if (account < cfg.hold * target || i == cfgList.length - 1) {
              let amount = target * (cfg.output_min + Math.random() * (cfg.output_max - cfg.output_min));
              if (Number.isNaN(amount) || amount < 0) {
                LogUtil.error(`getRewardAmountWithData-amount is NaN or less than 0`);
                amount = 0;
              }
              if (amount === 0 && itemId == ItemType.MinorToken) {
                amount = 300;
              }
              return itemId == ItemType.MajorToken ? parseFloat(amount.toFixed(2)) : Math.floor(amount);
            }
          }
          if (itemId == ItemType.MinorToken) {
            console.log("getRewardAmountWithItemId-minor");
            return 300;
          }
          return 0;
        }
        getRewardAmountWithItemId(itemId) {
          if (itemId == ItemType.Fragment) {
            return this.config.range.fragment;
          }
          let redeemList = MountManager.instance.notify(MountPoint.NativeNotifyIsRedeem, null);
          let isRedeem = false;
          if (redeemList.length > 0) {
            isRedeem = redeemList[0];
          } else {
            LogUtil.log('RewardMgr-getRewardAmountWithItemId, get isRedeem Error');
          }
          let amountList = MountManager.instance.notify(MountPoint.NativeNotifyRedeemAount, null);
          let nextAmount = 0;
          if (amountList.length > 0) {
            nextAmount = amountList[0];
          } else {
            LogUtil.log('RewardMgr-getRewardAmountWithItemId, get nextRedeemAmount Error');
          }
          let gdManager = GameDataManager.instance;
          let majorAccount = gdManager.getMajorToken();
          let minorAccount = gdManager.getMinorToken();
          let account = itemId == ItemType.MajorToken ? majorAccount : minorAccount;
          let target = itemId == ItemType.MajorToken ? nextAmount : 1;
          return this.getRewardAmountWithData(itemId, target, isRedeem, account);
        }
        checkRealRewardStepComplete(step) {
          let completeInfo = GameDataManager.instance.data.realReward;
          let config = this.config.real_reward[step];
          if (!config || !completeInfo) return false;
          let curTime = TimeAgent.instance.getTime();
          let isTimeOut = curTime - completeInfo.startTime >= config.time * 1000;
          switch (config.action) {
            case RealRewardAction.Ad:
              {
                if (completeInfo.progress >= config.count) {
                  return true;
                }
                if (isTimeOut) {
                  completeInfo.startTime = curTime;
                  completeInfo.progress = 0;
                }
                return false;
              }
            case RealRewardAction.Wait:
              {
                return isTimeOut;
              }
            case RealRewardAction.Queue:
              {
                if (isTimeOut) {
                  completeInfo.startTime = curTime;
                }
                return false;
              }
          }
        }
        isShowRatingPopup() {
          let gdMgr = GameDataManager.instance;
          if (gdMgr.data.levelShowRating < 0) {
            return false;
          }
          const no_sg_version = this.getConfig().no_sg_version || [];
          if (no_sg_version.indexOf(Config.GAME_VERSION) >= 0) {
            console.log(`ENABLE_SG: no_sg_version-false`);
            return false;
          }
          if (gdMgr.data.levelShowRating < gdMgr.data.level) {
            let num = GameDataManager.instance.data.level;
            let idx = this.config.rating.show_after_games.indexOf(num);
            return idx >= 0;
          }
          return false;
        }
        getRandomSpecialCardNum(itemId) {
          let min = 0;
          let max = 3;
          switch (itemId) {
            case ItemType.MajorToken:
              min = this.config.ad.special_card.major.num_min;
              max = this.config.ad.special_card.major.num_max;
              break;
            case ItemType.MinorToken:
              min = this.config.ad.special_card.minor.num_min;
              max = this.config.ad.special_card.minor.num_max;
              break;
          }
          if (max < min) {
            let temp = min;
            min = max;
            max = temp;
          }
          let ret = RandomUtil.random(min, max);
          return ret;
        }
        getMajorTokenTarget(stageId) {
          let targets = this.config.major_token_milestone;
          if (stageId < targets.length) {
            return targets[stageId];
          } else {
            return -1;
          }
        }
        openPictureSelectView() {
          let selectCfg = this.getConfig().sg.select;
          let specialNum = selectCfg.special_num;
          if (++GameDataManager.instance.sg.selectFreqCount >= selectCfg.special_frequency.frequency) {
            specialNum = selectCfg.special_frequency.show_num;
            GameDataManager.instance.sg.selectFreqCount = 0;
          }
          let listNormal = GameDataManager.instance.getAvailablePictureList(4 - specialNum, false);
          let listSpecial = GameDataManager.instance.getAvailablePictureList(specialNum, true);
          let infoList = listNormal.concat(listSpecial);
          UIManager.instance.open(UIID.PictureSelectView, {
            infoList: infoList
          });
        }
      }, _class2._instance = null, _class2), _descriptor = _applyDecoratedDescriptor(_class.prototype, "config", [_dec], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new RewardConfig();
        }
      }), _class)));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/reward-type-define.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './object-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, ClassType, ArrayType;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      ClassType = module.ClassType;
      ArrayType = module.ArrayType;
    }],
    execute: function () {
      var _dec, _dec2, _class2, _descriptor, _descriptor2, _dec3, _class5, _descriptor3, _dec4, _dec5, _class9, _descriptor4, _descriptor5, _dec6, _dec7, _class12, _descriptor6, _descriptor7, _dec8, _dec9, _dec10, _dec11, _dec12, _dec13, _dec14, _class15, _descriptor8, _descriptor9, _descriptor10, _descriptor11, _descriptor12, _descriptor13, _descriptor14, _dec15, _class17, _descriptor15, _dec16, _dec17, _dec18, _dec19, _class19, _descriptor16, _descriptor17, _descriptor18, _descriptor19, _dec20, _class32, _descriptor20, _dec21, _dec22, _dec23, _class35, _descriptor21, _descriptor22, _descriptor23, _dec24, _class37, _descriptor24, _dec25, _class39, _descriptor25, _dec26, _dec27, _dec28, _dec29, _dec30, _dec31, _dec32, _dec33, _dec34, _dec35, _dec36, _class41, _descriptor26, _descriptor27, _descriptor28, _descriptor29, _descriptor30, _descriptor31, _descriptor32, _descriptor33, _descriptor34, _descriptor35, _descriptor36;
      cclegacy._RF.push({}, "d9903yF6ExLs74ycMF9/24E", "reward-type-define", undefined);

      // Tool
      class ToolRewardInfo {
        constructor() {
          this.free_amount = 0;
          this.paid_amount = 3;
          this.price_by_minor = 1000;
        }
      }
      exports('ToolRewardInfo', ToolRewardInfo);
      let ToolRewardConfig = exports('ToolRewardConfig', (_dec = ClassType(ToolRewardInfo), _dec2 = ClassType(ToolRewardInfo), (_class2 = class ToolRewardConfig {
        constructor() {
          _initializerDefineProperty(this, "magic", _descriptor, this);
          _initializerDefineProperty(this, "undo", _descriptor2, this);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "magic", [_dec], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new ToolRewardInfo();
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "undo", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new ToolRewardInfo();
        }
      })), _class2)));
      let ItemType = exports('ItemType', /*#__PURE__*/function (ItemType) {
        ItemType[ItemType["MajorToken"] = 0] = "MajorToken";
        ItemType[ItemType["MinorToken"] = 1] = "MinorToken";
        ItemType[ItemType["Magic"] = 2] = "Magic";
        ItemType[ItemType["Undo"] = 3] = "Undo";
        ItemType[ItemType["Fragment"] = 4] = "Fragment";
        return ItemType;
      }({}));

      // Sign in
      class RewardItemInfo {
        constructor(itemId, amount) {
          this.itemId = ItemType.MinorToken;
          this.amount = 100;
          this.itemId = itemId;
          this.amount = amount;
        }
      }
      exports('RewardItemInfo', RewardItemInfo);
      let SignInRewardConfig = exports('SignInRewardConfig', (_dec3 = ArrayType(RewardItemInfo), (_class5 = class SignInRewardConfig {
        constructor() {
          this.is_ad = true;
          this.show_after_games = 1;
          //多少局后弹出签到
          _initializerDefineProperty(this, "rewards", _descriptor3, this);
        }
      }, _descriptor3 = _applyDecoratedDescriptor(_class5.prototype, "rewards", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [new RewardItemInfo(ItemType.MinorToken, 5000), new RewardItemInfo(ItemType.MajorToken, 20), new RewardItemInfo(ItemType.MinorToken, 5000), new RewardItemInfo(ItemType.MajorToken, 30), new RewardItemInfo(ItemType.MinorToken, 5000), new RewardItemInfo(ItemType.MajorToken, 50), new RewardItemInfo(ItemType.MajorToken, 300)];
        }
      }), _class5)));

      // ad
      class RewardShowInfo {
        constructor() {
          this.show_delay_first = 45;
          this.exist_time = 30;
          this.show_delay_recieved = 10;
          this.show_delay_not_recieved = 30;
        }
      }
      exports('RewardShowInfo', RewardShowInfo);
      class FlipRewardInfo {
        constructor() {
          this.is_ad_first_flip = true;
          this.rewardIds = [0, 0, 0, 1];
        }
      }
      exports('FlipRewardInfo', FlipRewardInfo);
      let FlipRewardConfig = exports('FlipRewardConfig', (_dec4 = ClassType(RewardShowInfo), _dec5 = ClassType(FlipRewardInfo), (_class9 = class FlipRewardConfig {
        constructor() {
          _initializerDefineProperty(this, "show", _descriptor4, this);
          _initializerDefineProperty(this, "flip", _descriptor5, this);
        }
      }, (_descriptor4 = _applyDecoratedDescriptor(_class9.prototype, "show", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new RewardShowInfo();
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class9.prototype, "flip", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new FlipRewardInfo();
        }
      })), _class9)));
      class SpecialCardInfo {
        constructor(num_min, num_max) {
          this.num_min = 2;
          this.num_max = 3;
          this.num_min = num_min;
          this.num_max = num_max;
        }
      }
      exports('SpecialCardInfo', SpecialCardInfo);
      let SpecialCardConfig = exports('SpecialCardConfig', (_dec6 = ClassType(SpecialCardInfo), _dec7 = ClassType(SpecialCardInfo), (_class12 = class SpecialCardConfig {
        constructor() {
          _initializerDefineProperty(this, "major", _descriptor6, this);
          _initializerDefineProperty(this, "minor", _descriptor7, this);
        }
      }, (_descriptor6 = _applyDecoratedDescriptor(_class12.prototype, "major", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new SpecialCardInfo(2, 3);
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class12.prototype, "minor", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new SpecialCardInfo(1, 2);
        }
      })), _class12)));
      class InterAdWeightInfo {
        constructor(is_play, weight) {
          this.is_play = true;
          this.weight = 0;
          this.is_play = is_play;
          this.weight = weight;
        }
      }
      exports('InterAdWeightInfo', InterAdWeightInfo);
      let InterAdWeightConfig = exports('InterAdWeightConfig', (_dec8 = ClassType(InterAdWeightInfo), _dec9 = ClassType(InterAdWeightInfo), _dec10 = ClassType(InterAdWeightInfo), _dec11 = ClassType(InterAdWeightInfo), _dec12 = ClassType(InterAdWeightInfo), _dec13 = ClassType(InterAdWeightInfo), _dec14 = ClassType(InterAdWeightInfo), (_class15 = class InterAdWeightConfig {
        constructor() {
          _initializerDefineProperty(this, "level_win", _descriptor8, this);
          _initializerDefineProperty(this, "tab_illustration", _descriptor9, this);
          _initializerDefineProperty(this, "tab_album", _descriptor10, this);
          _initializerDefineProperty(this, "photo_choose", _descriptor11, this);
          _initializerDefineProperty(this, "victory_reward", _descriptor12, this);
          _initializerDefineProperty(this, "surprise_reward", _descriptor13, this);
          _initializerDefineProperty(this, "enough_coins", _descriptor14, this);
        }
      }, (_descriptor8 = _applyDecoratedDescriptor(_class15.prototype, "level_win", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new InterAdWeightInfo(true, 100);
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class15.prototype, "tab_illustration", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new InterAdWeightInfo(false, 0);
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class15.prototype, "tab_album", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new InterAdWeightInfo(false, 0);
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class15.prototype, "photo_choose", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new InterAdWeightInfo(false, 0);
        }
      }), _descriptor12 = _applyDecoratedDescriptor(_class15.prototype, "victory_reward", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new InterAdWeightInfo(false, 0);
        }
      }), _descriptor13 = _applyDecoratedDescriptor(_class15.prototype, "surprise_reward", [_dec13], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new InterAdWeightInfo(true, 50);
        }
      }), _descriptor14 = _applyDecoratedDescriptor(_class15.prototype, "enough_coins", [_dec14], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new InterAdWeightInfo(true, 100);
        }
      })), _class15)));
      let InterAdConfig = exports('InterAdConfig', (_dec15 = ClassType(InterAdWeightConfig), (_class17 = class InterAdConfig {
        constructor() {
          this.show_weights = [200, 100];
          this.skip_times = [1, 0];
          this.cd_time = 30;
          _initializerDefineProperty(this, "page", _descriptor15, this);
        }
      }, _descriptor15 = _applyDecoratedDescriptor(_class17.prototype, "page", [_dec15], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new InterAdWeightConfig();
        }
      }), _class17)));
      let AdRewardConfig = exports('AdRewardConfig', (_dec16 = ClassType(FlipRewardConfig), _dec17 = ClassType(FlipRewardConfig), _dec18 = ClassType(SpecialCardConfig), _dec19 = ClassType(InterAdConfig), (_class19 = class AdRewardConfig {
        constructor() {
          this.reward_multiple = 2;
          this.free_times = -1;
          _initializerDefineProperty(this, "drift_bubble", _descriptor16, this);
          _initializerDefineProperty(this, "win_streak", _descriptor17, this);
          _initializerDefineProperty(this, "special_card", _descriptor18, this);
          this.turn_table_major_rate = 0.8;
          _initializerDefineProperty(this, "inter", _descriptor19, this);
          this.lucky_card_reward = 1;
        }
      }, (_descriptor16 = _applyDecoratedDescriptor(_class19.prototype, "drift_bubble", [_dec16], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new FlipRewardConfig();
        }
      }), _descriptor17 = _applyDecoratedDescriptor(_class19.prototype, "win_streak", [_dec17], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new FlipRewardConfig();
        }
      }), _descriptor18 = _applyDecoratedDescriptor(_class19.prototype, "special_card", [_dec18], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new SpecialCardConfig();
        }
      }), _descriptor19 = _applyDecoratedDescriptor(_class19.prototype, "inter", [_dec19], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new InterAdConfig();
        }
      })), _class19)));

      // action
      class ActionRewardConfig {
        constructor() {
          this.reward_id = ItemType.MinorToken;
          this.flip = 2;
          this.move_from_stock = 1;
          this.move_to_foundation = 5;
          this.ace_to_foundation = 10;
          this.card_collect = 10;
        }
      }
      exports('ActionRewardConfig', ActionRewardConfig);

      //range config
      class RewardAmountRangeInfo {
        constructor(hold, output_min, output_max) {
          this.hold = 0.6;
          this.output_min = 0.3;
          this.output_max = 0.3;
          this.hold = hold;
          this.output_min = output_min;
          this.output_max = output_max;
        }
      }
      exports('RewardAmountRangeInfo', RewardAmountRangeInfo);
      class RewardAmountRangeConfig {
        constructor() {
          this.major_before_redeem = [new RewardAmountRangeInfo(0.4, 0.16, 0.2), new RewardAmountRangeInfo(0.64, 0.064, 0.08), new RewardAmountRangeInfo(0.76, 0.048, 0.06), new RewardAmountRangeInfo(0.8, 0.032, 0.04), new RewardAmountRangeInfo(0.89, 0.02, 0.024), new RewardAmountRangeInfo(0.965, 0.01, 0.012), new RewardAmountRangeInfo(0.985, 0.004, 0.005), new RewardAmountRangeInfo(0.995, 0.002, 0.003), new RewardAmountRangeInfo(1, 0.004, 0.005)];
          this.major_after_redeem = [new RewardAmountRangeInfo(0.1, 0.08, 0.1), new RewardAmountRangeInfo(0.38, 0.064, 0.08), new RewardAmountRangeInfo(0.52, 0.048, 0.06), new RewardAmountRangeInfo(0.632, 0.032, 0.04), new RewardAmountRangeInfo(0.702, 0.024, 0.03), new RewardAmountRangeInfo(0.767, 0.012, 0.015), new RewardAmountRangeInfo(0.872, 0.0096, 0.012), new RewardAmountRangeInfo(0.918, 0.008, 0.01), new RewardAmountRangeInfo(0.953, 0.004, 0.005), new RewardAmountRangeInfo(0.957, 0.0032, 0.004), new RewardAmountRangeInfo(0.963, 0.0016, 0.002), new RewardAmountRangeInfo(0.974, 0.0008, 0.001), new RewardAmountRangeInfo(0.9802, 0.00064, 0.0008), new RewardAmountRangeInfo(0.98982, 0.0004, 0.0005), new RewardAmountRangeInfo(1.00042, 0.0004, 0.0005)];
          this.minor = [new RewardAmountRangeInfo(100000, 300, 300), new RewardAmountRangeInfo(99999999, 60, 60)];
          this.fragment = 1;
        }
      }
      exports('RewardAmountRangeConfig', RewardAmountRangeConfig);
      class ThemeConfig {
        constructor() {
          this.front_prices = [5000, 5000, 5000, 5000, 5000];
          this.back_prices = [5000, 5000, 5000, 5000, 5000];
        }
      }
      exports('ThemeConfig', ThemeConfig);
      let RealRewardAction = exports('RealRewardAction', /*#__PURE__*/function (RealRewardAction) {
        RealRewardAction["Ad"] = "ad";
        RealRewardAction["Wait"] = "wait";
        RealRewardAction["Queue"] = "queue";
        return RealRewardAction;
      }({}));
      class RealRewardStepConfig {
        constructor() {
          this.action = RealRewardAction.Ad;
          this.time = 0;
          this.count = 0;
          this.init = 0;
          this.cut_per_min = 0;
          this.cut_per_ad = 0;
        }
      }
      exports('RealRewardStepConfig', RealRewardStepConfig);
      class RealRewardCompleteInfo {
        constructor() {
          this.startTime = 0;
          this.stepId = 0;
          this.progress = 0;
        }
      }
      exports('RealRewardCompleteInfo', RealRewardCompleteInfo);
      class RatingShowConfig {
        constructor() {
          this.show_after_games = [99, 999];
        }
      }
      exports('RatingShowConfig', RatingShowConfig);
      class GmConfig {
        constructor() {
          this.is_gm = false;
          this.signal = 549527;
        }
      }
      exports('GmConfig', GmConfig);
      class StageGroupInfo {
        constructor() {
          this.stage_num = 5;
        }
      }
      exports('StageGroupInfo', StageGroupInfo);
      let ChapterType = exports('ChapterType', /*#__PURE__*/function (ChapterType) {
        ChapterType[ChapterType["Consumtion"] = 0] = "Consumtion";
        ChapterType[ChapterType["Countryside"] = 1] = "Countryside";
        return ChapterType;
      }({}));
      class StageConfig {
        constructor() {
          this.special_stage_interval = 10;
        }
      }
      exports('StageConfig', StageConfig);
      class SelectFrequencyConfig {
        constructor() {
          this.frequency = 5;
          this.show_num = 3;
        }
      }
      exports('SelectFrequencyConfig', SelectFrequencyConfig);
      let SgSelectInfo = exports('SgSelectInfo', (_dec20 = ClassType(SelectFrequencyConfig), (_class32 = class SgSelectInfo {
        constructor() {
          this.refresh_time = 1;
          this.special_num = 0;
          _initializerDefineProperty(this, "special_frequency", _descriptor20, this);
        }
      }, _descriptor20 = _applyDecoratedDescriptor(_class32.prototype, "special_frequency", [_dec20], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new SelectFrequencyConfig();
        }
      }), _class32)));
      let SignInTaskType = exports('SignInTaskType', /*#__PURE__*/function (SignInTaskType) {
        SignInTaskType[SignInTaskType["LEVEL_WIN"] = 0] = "LEVEL_WIN";
        SignInTaskType[SignInTaskType["UNLOCK_IMAGE"] = 1] = "UNLOCK_IMAGE";
        SignInTaskType[SignInTaskType["GET_IMAGE"] = 2] = "GET_IMAGE";
        SignInTaskType[SignInTaskType["PLAY_GAME"] = 3] = "PLAY_GAME";
        return SignInTaskType;
      }({}));
      class SignInTaskInfo {
        constructor(type, target) {
          this.type = SignInTaskType.LEVEL_WIN;
          this.target = 10;
          this.type = type;
          this.target = target;
        }
      }
      exports('SignInTaskInfo', SignInTaskInfo);
      let SignInTaskConfig = exports('SignInTaskConfig', (_dec21 = ArrayType(SignInTaskInfo), _dec22 = ArrayType(SignInTaskInfo), _dec23 = ArrayType(SignInTaskInfo), (_class35 = class SignInTaskConfig {
        constructor() {
          _initializerDefineProperty(this, "day_1", _descriptor21, this);
          _initializerDefineProperty(this, "day_2", _descriptor22, this);
          _initializerDefineProperty(this, "day_3", _descriptor23, this);
        }
      }, (_descriptor21 = _applyDecoratedDescriptor(_class35.prototype, "day_1", [_dec21], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [new SignInTaskInfo(SignInTaskType.LEVEL_WIN, 10), new SignInTaskInfo(SignInTaskType.UNLOCK_IMAGE, 3)];
        }
      }), _descriptor22 = _applyDecoratedDescriptor(_class35.prototype, "day_2", [_dec22], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [new SignInTaskInfo(SignInTaskType.UNLOCK_IMAGE, 5), new SignInTaskInfo(SignInTaskType.GET_IMAGE, 15)];
        }
      }), _descriptor23 = _applyDecoratedDescriptor(_class35.prototype, "day_3", [_dec23], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [new SignInTaskInfo(SignInTaskType.GET_IMAGE, 15), new SignInTaskInfo(SignInTaskType.PLAY_GAME, 20)];
        }
      })), _class35)));
      let SignInConfigSg = exports('SignInConfigSg', (_dec24 = ClassType(SignInTaskConfig), (_class37 = class SignInConfigSg {
        constructor() {
          this.main_reward = 1000;
          this.task_reward = 500;
          _initializerDefineProperty(this, "task", _descriptor24, this);
        }
      }, _descriptor24 = _applyDecoratedDescriptor(_class37.prototype, "task", [_dec24], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new SignInTaskConfig();
        }
      }), _class37)));
      let SgConfig = exports('SgConfig', (_dec25 = ClassType(SgSelectInfo), (_class39 = class SgConfig {
        constructor() {
          this.is_sg = false;
          this.loading_after_flag = true;
          this.illustration_cost = 1000;
          this.album_cost = 10;
          this.preload_time = 20;
          this.unselected_size = 50;
          _initializerDefineProperty(this, "select", _descriptor25, this);
          this.unshow_limit = 10;
        }
      }, _descriptor25 = _applyDecoratedDescriptor(_class39.prototype, "select", [_dec25], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new SgSelectInfo();
        }
      }), _class39)));

      // main config
      let RewardConfig = exports('RewardConfig', (_dec26 = ClassType(AdRewardConfig), _dec27 = ClassType(ActionRewardConfig), _dec28 = ClassType(ToolRewardConfig), _dec29 = ClassType(SignInRewardConfig), _dec30 = ClassType(RewardAmountRangeConfig), _dec31 = ClassType(ThemeConfig), _dec32 = ArrayType(RealRewardStepConfig), _dec33 = ClassType(RatingShowConfig), _dec34 = ClassType(GmConfig), _dec35 = ClassType(StageConfig), _dec36 = ClassType(SgConfig), (_class41 = class RewardConfig {
        constructor() {
          this.major_token_milestone = [100, 200, 300, 400, 450, 480, 490, 500, 600, 700, 800, 1000, 1500];
          _initializerDefineProperty(this, "ad", _descriptor26, this);
          _initializerDefineProperty(this, "action", _descriptor27, this);
          _initializerDefineProperty(this, "tool", _descriptor28, this);
          _initializerDefineProperty(this, "sign_in", _descriptor29, this);
          _initializerDefineProperty(this, "range", _descriptor30, this);
          _initializerDefineProperty(this, "theme", _descriptor31, this);
          _initializerDefineProperty(this, "real_reward", _descriptor32, this);
          _initializerDefineProperty(this, "rating", _descriptor33, this);
          this.is_more_game = false;
          this.no_sg_version = ["1.0.0"];
          this.no_web_version = ["1.0.0"];
          _initializerDefineProperty(this, "gm", _descriptor34, this);
          _initializerDefineProperty(this, "stage", _descriptor35, this);
          _initializerDefineProperty(this, "sg", _descriptor36, this);
        }
      }, (_descriptor26 = _applyDecoratedDescriptor(_class41.prototype, "ad", [_dec26], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new AdRewardConfig();
        }
      }), _descriptor27 = _applyDecoratedDescriptor(_class41.prototype, "action", [_dec27], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new ActionRewardConfig();
        }
      }), _descriptor28 = _applyDecoratedDescriptor(_class41.prototype, "tool", [_dec28], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new ToolRewardConfig();
        }
      }), _descriptor29 = _applyDecoratedDescriptor(_class41.prototype, "sign_in", [_dec29], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new SignInRewardConfig();
        }
      }), _descriptor30 = _applyDecoratedDescriptor(_class41.prototype, "range", [_dec30], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new RewardAmountRangeConfig();
        }
      }), _descriptor31 = _applyDecoratedDescriptor(_class41.prototype, "theme", [_dec31], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new ThemeConfig();
        }
      }), _descriptor32 = _applyDecoratedDescriptor(_class41.prototype, "real_reward", [_dec32], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor33 = _applyDecoratedDescriptor(_class41.prototype, "rating", [_dec33], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new RatingShowConfig();
        }
      }), _descriptor34 = _applyDecoratedDescriptor(_class41.prototype, "gm", [_dec34], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new GmConfig();
        }
      }), _descriptor35 = _applyDecoratedDescriptor(_class41.prototype, "stage", [_dec35], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new StageConfig();
        }
      }), _descriptor36 = _applyDecoratedDescriptor(_class41.prototype, "sg", [_dec36], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return new SgConfig();
        }
      })), _class41)));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/RHNDXTSQQCUFJ.ts", ['cc', './SVDMRMIFJDYHRX.ts', './FSIOKP.ts', './AQKTRMDQJQQBTDC.ts', './WBKIRV.ts', './PQBRALKRA.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, GameAd, AQKTRMDQJQQBTDC, PSWZDFV, PDWTAEXGRLKYCOL, PQBRALKRA;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      GameAd = module.GameAd;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      PSWZDFV = module.PSWZDFV;
      PDWTAEXGRLKYCOL = module.PDWTAEXGRLKYCOL;
    }, function (module) {
      PQBRALKRA = module.PQBRALKRA;
    }],
    execute: function () {
      cclegacy._RF.push({}, "c5fd9o8ASRCaLkGvY3M6RAx", "RHNDXTSQQCUFJ", undefined);
      class RHNDXTSQQCUFJ extends SVDMRMIFJDYHRX {
        constructor(...args) {
          super(...args);
          this.TTVSSHKUKYIFWUL = null;
        }
        TGQXAKDAHFFVG() {
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.TGDSIXDAK, this.TGDSIXDAK, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.NQRUAAO, this.NQRUAAO, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.ZORHXXXEEY, this.NWFQRCYNFGVCFJXE, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.XWFUQTQPSCVLJYL, this.XWFUQTQPSCVLJYL, this);
        }
        QIZLFVUQ() {}
        TGDSIXDAK(ICLLMTBOICCIAPM) {
          try {
            let data = JSON.parse(ICLLMTBOICCIAPM);
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.TGDSIXDAK(data);
            }
          } catch (e) {}
        }
        NQRUAAO(ICLLMTBOICCIAPM) {
          try {
            let data = JSON.parse(ICLLMTBOICCIAPM);
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.NQRUAAO(data);
            }
          } catch (e) {}
        }
        NWFQRCYNFGVCFJXE(ICLLMTBOICCIAPM) {
          try {
            let data = JSON.parse(ICLLMTBOICCIAPM);
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.ZORHXXXEEY(data);
            }
          } catch (e) {}
        }
        XWFUQTQPSCVLJYL(ICLLMTBOICCIAPM) {
          try {
            let data = JSON.parse(ICLLMTBOICCIAPM);
            if (PDWTAEXGRLKYCOL.QAWGKUNMWHJHXKY == data.type) {
              if (this.TTVSSHKUKYIFWUL != null) {
                this.TTVSSHKUKYIFWUL.XWFUQTQPSCVLJYL(data);
              }
            }
          } catch (e) {}
        }
        QQHBFNGENLK(PYGPRHHLLOGJEROQ) {
          this.TTVSSHKUKYIFWUL = PYGPRHHLLOGJEROQ;
        }
        PYQUCSIIH(HKHIMBDEOIRB) {
          if (PQBRALKRA.OTORTMMYVD) {
            return false;
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().PYQUCSIIH(HKHIMBDEOIRB);
        }
        XOUECKSDJND(HKHIMBDEOIRB) {
          if (PQBRALKRA.OTORTMMYVD) {
            let data = new GameAd();
            data.entry = HKHIMBDEOIRB;
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.TGDSIXDAK(data);
              this.TTVSSHKUKYIFWUL.NQRUAAO(data);
              this.TTVSSHKUKYIFWUL.ZORHXXXEEY(data);
            }
            return true;
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().XOUECKSDJND(HKHIMBDEOIRB);
        }
      }
      exports('RHNDXTSQQCUFJ', RHNDXTSQQCUFJ);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/round-rect-mask.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, _decorator, Component, Graphics, UITransform;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
      Graphics = module.Graphics;
      UITransform = module.UITransform;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "0c785R/1cNGx5QHQaJEij1E", "round-rect-mask", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let RoundRectMask = exports('RoundRectMask', (_dec = ccclass('RoundRectMask'), _dec2 = property(Number), _dec(_class = (_class2 = class RoundRectMask extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "cornerRadius", _descriptor, this);
        }
        start() {
          const graphics = this.getComponent(Graphics);
          graphics.lineWidth = 2;
          let size = this.node.getComponent(UITransform).contentSize;
          graphics.roundRect(0 - size.width / 2, 0 - size.height / 2, size.width, size.height, this.cornerRadius);
          graphics.fill();
        }
      }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "cornerRadius", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 40;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/RTONERXYWGCD.ts", ['cc', './SVDMRMIFJDYHRX.ts', './AQKTRMDQJQQBTDC.ts', './WBKIRV.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, AQKTRMDQJQQBTDC, PSWZDFV;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      PSWZDFV = module.PSWZDFV;
    }],
    execute: function () {
      cclegacy._RF.push({}, "327bb16FTVAjZteltj91Jrg", "RTONERXYWGCD", undefined);
      class RTONERXYWGCD extends SVDMRMIFJDYHRX {
        constructor(...args) {
          super(...args);
          this.TTVSSHKUKYIFWUL = null;
        }
        TGQXAKDAHFFVG() {
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.GBWCLMQUYDVKUKG, this.GBWCLMQUYDVKUKG, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.MLFWMEZHCWEUHV, this.MLFWMEZHCWEUHV, this);
        }
        QIZLFVUQ() {}
        NLSKEHTGBDWWZFL(PYGPRHHLLOGJEROQ) {
          this.TTVSSHKUKYIFWUL = PYGPRHHLLOGJEROQ;
        }
        GBWCLMQUYDVKUKG(ICLLMTBOICCIAPM) {
          try {
            let data = JSON.parse(ICLLMTBOICCIAPM);
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.GBWCLMQUYDVKUKG(data);
            }
          } catch (e) {}
        }
        MLFWMEZHCWEUHV(ICLLMTBOICCIAPM) {
          try {
            let data = JSON.parse(ICLLMTBOICCIAPM);
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.MLFWMEZHCWEUHV(data);
            }
          } catch (e) {}
        }
        UZSJLDEBYEZI(placementId, width, height, left, top) {
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().UZSJLDEBYEZI(placementId, width, height, left, top);
        }
        BLERBUWYZ(placementId) {
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().BLERBUWYZ(placementId);
        }
      }
      exports('RTONERXYWGCD', RTONERXYWGCD);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/safe-area-util.ts", ['cc'], function (exports) {
  var cclegacy, _decorator, Component, view, sys;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
      view = module.view;
      sys = module.sys;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "0c5618AahxMjLgGiLqwQmU0", "safe-area-util", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let SafeAreaUtil = exports('SafeAreaUtil', (_dec = ccclass('SafeAreaUtil'), _dec(_class = (_class2 = class SafeAreaUtil extends Component {
        constructor(...args) {
          super(...args);
          this._safeAreaTop = 0;
          this._safeAreaBottom = 0;
          this._safeAreaLeft = 0;
          this._safeAreaRight = 0;
        }
        static get instance() {
          return this._instance;
        }
        onLoad() {
          if (SafeAreaUtil._instance === null) {
            SafeAreaUtil._instance = this;
          }
          this.updateSafeArea();
        }
        updateSafeArea() {
          const safeArea = view.getSafeAreaRect();
          const visibleSize = view.getVisibleSize();

          // 计算安全区域边距
          this._safeAreaTop = visibleSize.height - safeArea.y - safeArea.height;
          this._safeAreaBottom = safeArea.y;
          this._safeAreaLeft = safeArea.x;
          this._safeAreaRight = visibleSize.width - safeArea.x - safeArea.width;

          // 如果是 iOS 设备，确保顶部有足够空间避开灵动岛
          if (sys.isIOS) {
            this._safeAreaTop = Math.max(this._safeAreaTop, 60);
          }
        }

        /**
         * 获取顶部安全区域高度
         */
        get safeAreaTop() {
          return this._safeAreaTop;
        }

        /**
         * 获取底部安全区域高度
         */
        get safeAreaBottom() {
          return this._safeAreaBottom;
        }

        /**
         * 获取左侧安全区域宽度
         */
        get safeAreaLeft() {
          return this._safeAreaLeft;
        }

        /**
         * 获取右侧安全区域宽度
         */
        get safeAreaRight() {
          return this._safeAreaRight;
        }
      }, _class2._instance = null, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/sdk-agent.ts", ['cc', './log-util.ts'], function (exports) {
  var cclegacy, sys, native, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      sys = module.sys;
      native = module.native;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      cclegacy._RF.push({}, "fa145Tavk9O3Y5qHWWuqKZn", "sdk-agent", undefined);
      class SDKAgent {
        static init() {
          console.log('SDK init');
          if (!sys.isNative) {
            LogUtil.log('SDK init but is not native');
            return;
          }
          if (sys.os === sys.OS.IOS) {
            LogUtil.log('SDK init iOS');
            native.reflection.callStaticMethod(null, 'init', '()V');
          } else if (sys.os === sys.OS.ANDROID) {
            LogUtil.log('SDK init Android');
          }
        }
      }
      exports('SDKAgent', SDKAgent);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/SDYSTNCVGG.ts", ['cc', './SVDMRMIFJDYHRX.ts', './FSIOKP.ts', './AQKTRMDQJQQBTDC.ts', './WBKIRV.ts', './PQBRALKRA.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, GameAd, AQKTRMDQJQQBTDC, PSWZDFV, PDWTAEXGRLKYCOL, PQBRALKRA;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      GameAd = module.GameAd;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      PSWZDFV = module.PSWZDFV;
      PDWTAEXGRLKYCOL = module.PDWTAEXGRLKYCOL;
    }, function (module) {
      PQBRALKRA = module.PQBRALKRA;
    }],
    execute: function () {
      cclegacy._RF.push({}, "c0e65PX0yBGYIWmpyaAsEAe", "SDYSTNCVGG", undefined);
      class SDYSTNCVGG extends SVDMRMIFJDYHRX {
        constructor(...args) {
          super(...args);
          this.TTVSSHKUKYIFWUL = null;
        }
        TGQXAKDAHFFVG() {
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.UUPFZKPXSEPHGAUI, this.UUPFZKPXSEPHGAUI, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.WASOVBLBVPPJBHMG, this.WASOVBLBVPPJBHMG, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.GKDTHXPMZJTYHU, this.UEKQUOKAFWDLF, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.NUVJWDOUNYDWG, this.SEEKAINN, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.XWFUQTQPSCVLJYL, this.XWFUQTQPSCVLJYL, this);
        }
        QIZLFVUQ() {}
        UUPFZKPXSEPHGAUI(args) {
          try {
            let data = JSON.parse(args);
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.HGGNPG(data);
            }
          } catch (e) {}
        }
        SEEKAINN(args) {
          try {
            let data = JSON.parse(args);
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.NUVJWDOUNYDWG(data);
            }
          } catch (e) {}
        }
        XWFUQTQPSCVLJYL(args) {
          try {
            let data = JSON.parse(args);
            if (PDWTAEXGRLKYCOL.EBRVJXLSPJUZ == data.type) {
              if (this.TTVSSHKUKYIFWUL != null) {
                this.TTVSSHKUKYIFWUL.XWFUQTQPSCVLJYL(data);
              }
            }
          } catch (e) {}
        }
        WASOVBLBVPPJBHMG(args) {
          try {
            let data = JSON.parse(args);
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.WASOVBLBVPPJBHMG(data);
            }
          } catch (e) {}
        }
        UEKQUOKAFWDLF(args) {
          try {
            let data = JSON.parse(args);
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.GKDTHXPMZJTYHU(data);
            }
          } catch (e) {}
        }

        // private XWFUQTQPSCVLJYL(args: string) {
        //     try {
        //         let data: GameAd = JSON.parse(args);
        //         if (GameAllCtrlName.EBRVJXLSPJUZ == data.type) {
        //             if (this.TTVSSHKUKYIFWUL != null) {
        //                 this.TTVSSHKUKYIFWUL.XWFUQTQPSCVLJYL(data);
        //             }
        //         }
        //     } catch (e) {
        //     }
        // }

        ZPJDWIDCHI(listener) {
          this.TTVSSHKUKYIFWUL = listener;
        }
        LHAKYKQVTTJC(entry) {
          if (PQBRALKRA.OTORTMMYVD) {
            return false;
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().LHAKYKQVTTJC(entry);
        }
        IUVEANIFARSRGVJN(entry) {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().IUVEANIFARSRGVJN(entry);
        }
        WUMMTYU(entry) {
          if (PQBRALKRA.OTORTMMYVD) {
            let data = new GameAd();
            data.entry = entry;
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.HGGNPG(data);
              this.TTVSSHKUKYIFWUL.WASOVBLBVPPJBHMG(data);
              this.TTVSSHKUKYIFWUL.GKDTHXPMZJTYHU(data);
              this.TTVSSHKUKYIFWUL.NUVJWDOUNYDWG(data);
            }
            return true;
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().WUMMTYU(entry);
        }
      }
      exports('SDYSTNCVGG', SDYSTNCVGG);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/shuffle-anim-controller.ts", ['cc'], function (exports) {
  var cclegacy, Component, _decorator;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Component = module.Component;
      _decorator = module._decorator;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "6b8afcrgC9PzY6p5726NRgg", "shuffle-anim-controller", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let ShuffleAnimController = exports('ShuffleAnimController', (_dec = ccclass('ShuffleAnimController'), _dec(_class = class ShuffleAnimController extends Component {
        onAnimEnd() {}
      }) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/sign-in-item.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './reward-type-define.ts', './game-data-manager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Sprite, SpriteFrame, Node, Label, _decorator, Component, ItemType, GameDataManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Sprite = module.Sprite;
      SpriteFrame = module.SpriteFrame;
      Node = module.Node;
      Label = module.Label;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      ItemType = module.ItemType;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _dec11, _dec12, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9, _descriptor10, _descriptor11;
      cclegacy._RF.push({}, "48394RQZsVKSKKBUf7bBiQ3", "sign-in-item", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let SignInState = exports('SignInState', /*#__PURE__*/function (SignInState) {
        SignInState[SignInState["Unavailable"] = 0] = "Unavailable";
        SignInState[SignInState["UnSigned"] = 1] = "UnSigned";
        SignInState[SignInState["Signed"] = 2] = "Signed";
        return SignInState;
      }({}));
      let SignInItem = exports('SignInItem', (_dec = ccclass('SignInItem'), _dec2 = property(Sprite), _dec3 = property([SpriteFrame]), _dec4 = property(Sprite), _dec5 = property([SpriteFrame]), _dec6 = property(Node), _dec7 = property(Label), _dec8 = property(Label), _dec9 = property(Node), _dec10 = property(Node), _dec11 = property(Node), _dec12 = property(Node), _dec(_class = (_class2 = class SignInItem extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "sprtMark", _descriptor, this);
          _initializerDefineProperty(this, "sprtMarkFrames", _descriptor2, this);
          _initializerDefineProperty(this, "bg", _descriptor3, this);
          _initializerDefineProperty(this, "bgFrames", _descriptor4, this);
          _initializerDefineProperty(this, "light", _descriptor5, this);
          _initializerDefineProperty(this, "lblDay", _descriptor6, this);
          _initializerDefineProperty(this, "lblNum", _descriptor7, this);
          _initializerDefineProperty(this, "nodeMajorToken", _descriptor8, this);
          _initializerDefineProperty(this, "nodeMinorToken", _descriptor9, this);
          _initializerDefineProperty(this, "star", _descriptor10, this);
          _initializerDefineProperty(this, "staticLight", _descriptor11, this);
        }
        initWithData(day, data) {
          this.lblDay.string = day.toString();
          this.nodeMinorToken.active = false;
          this.nodeMajorToken.active = false;
          switch (data.itemId) {
            case ItemType.MinorToken:
              {
                this.nodeMinorToken.active = true;
                this.lblNum.string = data.amount.toString();
              }
              break;
            case ItemType.MajorToken:
              {
                this.nodeMajorToken.active = true;
                this.lblNum.string = `${GameDataManager.instance.getCurrency()}${data.amount}`;
              }
              break;
          }
        }
        set state(val) {
          this.sprtMark.spriteFrame = this.sprtMarkFrames[val];
          this.lblDay.node.active = val == SignInState.Unavailable;
          this.bg.spriteFrame = val == SignInState.Signed ? this.bgFrames[1] : this.bgFrames[0];
          this.light.active = val == SignInState.UnSigned;
          this.star.active = val != SignInState.Signed;
          this.staticLight.active = val == SignInState.UnSigned;
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "sprtMark", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "sprtMarkFrames", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "bg", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "bgFrames", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "light", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "lblDay", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "lblNum", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "nodeMajorToken", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "nodeMinorToken", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor10 = _applyDecoratedDescriptor(_class2.prototype, "star", [_dec11], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor11 = _applyDecoratedDescriptor(_class2.prototype, "staticLight", [_dec12], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/sign-in-popup.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './sign-in-item.ts', './game-data-manager.ts', './ui-manager.ts', './reward-manager.ts', './reward-type-define.ts', './ui-config.ts', './game-constants.ts', './report-agent.ts', './ad-manager.ts', './audio-manager.ts', './bridge-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, _decorator, tween, Vec3, UIView, SignInItem, SignInState, GameDataManager, UIManager, RewardManager, ItemType, UIID, AudioUrl, ReportAgent, CustomReportEvent, AdManager, AudioManager, BridgeUtil, VibrationEffect;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      _decorator = module._decorator;
      tween = module.tween;
      Vec3 = module.Vec3;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      SignInItem = module.SignInItem;
      SignInState = module.SignInState;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      RewardManager = module.RewardManager;
    }, function (module) {
      ItemType = module.ItemType;
    }, function (module) {
      UIID = module.UIID;
    }, function (module) {
      AudioUrl = module.AudioUrl;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
    }, function (module) {
      AdManager = module.AdManager;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "5e289Sl7GtGepvZMGP4PIjn", "sign-in-popup", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let SignInPopup = exports('SignInPopup', (_dec = ccclass('SignInPopup'), _dec2 = property(Node), _dec3 = property(Node), _dec(_class = (_class2 = class SignInPopup extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "container", _descriptor, this);
          this.itemList = [];
          _initializerDefineProperty(this, "tipsBubble", _descriptor2, this);
        }
        onOpen(fromUI, ...args) {
          AudioManager.instance.playEffect(AudioUrl.SHOW_POPUP);
          BridgeUtil.vibrate(30, VibrationEffect.CLICK);
          let data = GameDataManager.instance.data;
          for (let i = 0; i < this.container.children.length; i++) {
            let node = this.container.getChildByName(`Item${i}`);
            let item = node.getComponent(SignInItem);
            let day = i + 1;
            let info = RewardManager.instance.getSignInReward(i);
            item.initWithData(i + 1, info);
            this.itemList.push(item);
            if (day > data.loginDayNum) {
              item.state = SignInState.Unavailable;
            } else if (day > data.signInDayNum) {
              item.state = SignInState.UnSigned;
            } else {
              item.state = SignInState.Signed;
            }
            if (info.itemId === ItemType.MajorToken) ;
          }
          if (data.signInDayNum < data.loginDayNum) {
            ReportAgent.reportCustomEvent(CustomReportEvent.AD_EVENT_DISTRIBUTED, {
              reward_page_show: 'sign_in'
            });
          }
          tween(this.tipsBubble).repeatForever(tween().by(1.5, {
            position: new Vec3(0, 10, 0)
          }, {
            easing: 'sineInOut'
          }).by(1.5, {
            position: new Vec3(0, -10, 0)
          }, {
            easing: 'sineInOut'
          })).start();
        }
        onClose() {
          tween(this.tipsBubble).stop();
          GameDataManager.instance.saveData(true);
        }
        onClaimBtn() {
          let data = GameDataManager.instance.data;
          if (data.signInDayNum > this.itemList.length) {
            return;
          }
          if (data.signInDayNum < data.loginDayNum) {
            let callback = () => {
              data.signInDayNum++;
              let idx = data.signInDayNum - 1;
              let info = RewardManager.instance.getSignInReward(idx);
              this.obtainItem(info);
              let item = this.itemList[idx];
              item.state = SignInState.Signed;
            };
            if (RewardManager.instance.getConfig().sign_in.is_ad) {
              ReportAgent.reportCustomEvent(CustomReportEvent.AD_EVENT_DISTRIBUTED, {
                reward_page_click: 'sign_in'
              });
              AdManager.instance.openVideoAd('SignInPopup', (entry, success) => {
                if (success) {
                  callback();
                }
              });
            } else {
              callback();
            }
          } else {
            UIManager.instance.showToast('You have already checked in today. Please try again tomorrow.');
          }
        }
        obtainItem(info) {
          let data = {
            itemId: info.itemId,
            amount: info.amount
          };
          UIManager.instance.open(UIID.ItemGetPopupSg, data);
        }
        onCloseBtn() {
          UIManager.instance.close(this);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "container", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "tipsBubble", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/stage.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-manager.ts', './ui-config.ts', './game-data-manager.ts', './mount-manager.ts', './mount-point.ts', './config.ts', './log-util.ts', './report-agent.ts', './graph-manager.ts', './bg-adapter.ts', './game-data-type-define.ts', './ui-util.ts', './game-constants.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, Sprite, ParticleSystem2D, _decorator, Component, sys, game, Game, director, Vec3, UIManager, UIID, UICF, GameDataManager, MountManager, MountPoint, Config, LogUtil, ReportAgent, CustomReportEvent, GraphManager, BgAdapter, SgState, UIUtil, GameEvent;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      Sprite = module.Sprite;
      ParticleSystem2D = module.ParticleSystem2D;
      _decorator = module._decorator;
      Component = module.Component;
      sys = module.sys;
      game = module.game;
      Game = module.Game;
      director = module.director;
      Vec3 = module.Vec3;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      UIID = module.UIID;
      UICF = module.UICF;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      MountManager = module.MountManager;
    }, function (module) {
      MountPoint = module.MountPoint;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
    }, function (module) {
      GraphManager = module.GraphManager;
    }, function (module) {
      BgAdapter = module.BgAdapter;
    }, function (module) {
      SgState = module.SgState;
    }, function (module) {
      UIUtil = module.UIUtil;
    }, function (module) {
      GameEvent = module.GameEvent;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "bb0ec/GYF9B9LG4mVMZI+k9", "stage", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let Stage = exports('Stage', (_dec = ccclass('stage'), _dec2 = property(Node), _dec3 = property(Sprite), _dec4 = property(ParticleSystem2D), _dec5 = property(Node), _dec(_class = (_class2 = class Stage extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "gameDesk", _descriptor, this);
          _initializerDefineProperty(this, "sprBg", _descriptor2, this);
          _initializerDefineProperty(this, "ptclClick", _descriptor3, this);
          _initializerDefineProperty(this, "touchBlock", _descriptor4, this);
        }
        onLoad() {
          GameDataManager.instance.inGame = true;
          this.initConfigAndData();
          this.updateBg();
        }
        start() {
          // wwy
          ReportAgent.reportCustomEvent(CustomReportEvent.WWY_GAME_LIFE_KEY_NODE, {
            step: 'into_game'
          });
          if (GameDataManager.instance.data.firstGameAction.start_stage) {
            GameDataManager.instance.data.firstGameAction.start_stage = false;
            ReportAgent.reportCustomEvent(CustomReportEvent.USER_LIFECYCLE_MILESTONE, {
              action: 'game_star_first'
            });
          }
          UIManager.instance.setLayer();
          // this.schedule(() => {
          //     UIManager.instance.showDebugInfoToast();
          // }, 5)

          if (GameDataManager.instance.sg.state === SgState.Started) {
            UIManager.instance.open(UIID.HomeViewSg);
          }

          // this.setupBridge();

          if (sys.isBrowser) {
            this.scheduleOnce(() => {
              Config.setRFlag(true);
            }, 5);
          }
        }
        onEnable() {
          game.on(Game.EVENT_HIDE, this.onGamePause, this);
          game.on(Game.EVENT_SHOW, this.onGameShow, this);
          this.node.on(Node.EventType.TOUCH_END, this.onTouchEnd, this, true);
          director.on(GameEvent.ENABLE_TOUCH, this.enbableTouch, this);
          director.on(GameEvent.DISABLE_TOUCH, this.disableTouch, this);
        }
        onDisable() {
          game.off(Game.EVENT_HIDE, this.onGamePause, this);
          game.off(Game.EVENT_SHOW, this.onGameShow, this);
          this.node.off(Node.EventType.TOUCH_END, this.onTouchEnd, this, true);
          director.off(GameEvent.ENABLE_TOUCH, this.enbableTouch, this);
          director.off(GameEvent.DISABLE_TOUCH, this.disableTouch, this);
        }
        onDestroy() {
          this.unscheduleAllCallbacks();
        }
        initConfigAndData() {
          MountManager.instance.notify(MountPoint.StageInitUIConf, UICF);
          UIManager.instance.initUIConf(UICF);
        }
        onGamePause() {
          LogUtil.log('onGamePause');
          GameDataManager.instance.saveData(true);
        }
        onGameShow() {
          LogUtil.log('onGameShow');
        }
        async updateBg() {
          let gdMgr = GameDataManager.instance;
          if (GameDataManager.instance.sg.state === SgState.Started) {
            // 根据逻辑选择bg
            let bgInfo = GameDataManager.instance.data.selectedSgPicture;
            let bgSpf = null;
            if (bgInfo) {
              bgSpf = await GraphManager.instance.loadGraph(bgInfo.url_A_t);
            } else {
              let bgInfo = gdMgr.getRandomBgInfo();
              if (bgInfo) {
                bgSpf = await GraphManager.instance.loadGraph(bgInfo.url_A_t);
              } else {
                return;
              }
            }
            if (bgSpf && bgSpf.isValid) {
              this.sprBg.spriteFrame = bgSpf;
              let adapter = this.sprBg.getComponent(BgAdapter);
              adapter.updateSize();
            }
            GraphManager.instance.loadGraph(bgInfo.url_A_s).then(spr => {
              if (spr && spr.isValid) {
                this.sprBg.spriteFrame = bgSpf;
                let adapter = this.sprBg.getComponent(BgAdapter);
                adapter.updateSize();
              }
            });
          }
        }
        onTouchEnd(event) {
          if (!this.ptclClick) return;
          let sPos = event.getLocation();
          let lPos = UIUtil.convertScreenPosToLocal(new Vec3(sPos.x, sPos.y, 0), this.ptclClick.node.parent, this.node);
          this.ptclClick.resetSystem();
          this.ptclClick.node.setPosition(lPos);
          this.ptclClick.node.active = true;
        }
        enbableTouch() {
          this.touchBlock.active = false;
        }
        disableTouch() {
          this.touchBlock.active = true;
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "gameDesk", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "sprBg", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "ptclClick", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "touchBlock", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/star-effect.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, _decorator, Component, macro, tween, Vec3;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
      Component = module.Component;
      macro = module.macro;
      tween = module.tween;
      Vec3 = module.Vec3;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "f23c5dhJ9BAKL790eC6MHZL", "star-effect", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let StarEffect = exports('StarEffect', (_dec = ccclass('StarEffect'), _dec2 = property(Number), _dec(_class = (_class2 = class StarEffect extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "duration", _descriptor, this);
        }
        onEnable() {
          this.schedule(() => {
            this.playAnim();
          }, this.duration, macro.REPEAT_FOREVER);
        }
        onDisable() {
          this.stopAnim();
          this.unschedule(this.playAnim);
        }
        playAnim() {
          let scaleMin = 0.8;
          let scaleMax = 1.2;
          let time = 1;
          tween(this.node).to(time / 4, {
            scale: new Vec3(scaleMin, scaleMin, 1)
          }).to(time / 2, {
            scale: new Vec3(scaleMax, scaleMax, 1)
          }).to(time / 4, {
            scale: new Vec3(1, 1, 1)
          }).call(() => {
            this.stopAnim();
          }).start();
        }
        stopAnim() {
          if (!this.node) {
            return;
          }
          tween(this.node).stop();
          this.node.scale = new Vec3(1, 1, 1);
        }
      }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "duration", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return 0;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/star-layout.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, _decorator, Component, UITransform;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      _decorator = module._decorator;
      Component = module.Component;
      UITransform = module.UITransform;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "4520eLx3gNF+4pOq95SQE6O", "star-layout", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let StarLayout = exports('StarLayout', (_dec = ccclass('StarLayout'), _dec2 = property([Node]), _dec(_class = (_class2 = class StarLayout extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "starNodes", _descriptor, this);
          this.multiple = 1;
          this._totalNum = 0;
        }
        set totalNum(value) {
          this._totalNum = value;
          for (let i = 0; i < this.starNodes.length; i++) {
            this.starNodes[i].active = i < value;
          }
          this.multiple = Math.max(1, Math.floor(this._totalNum / this.starNodes.length));
        }
        set curNum(value) {
          let activeNum = value / this.multiple;
          let remainNum = value % this.multiple;
          for (let i = 0; i < this.starNodes.length; i++) {
            let star = this.starNodes[i];
            if (star.active) {
              let mask = star.getChildByName('Mask');
              let width = star.getComponent(UITransform).width;
              let uiTrsf = mask.getComponent(UITransform);
              uiTrsf.width = i < activeNum ? width : width * parseFloat((remainNum / this.multiple).toFixed(1));
            }
          }
        }
      }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "starNodes", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/step-checker.ts", ['cc', './layout-tableau.ts', './card.ts', './card-constants.ts', './log-util.ts'], function (exports) {
  var cclegacy, LayoutTableau, Card, CardPoint, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      LayoutTableau = module.LayoutTableau;
    }, function (module) {
      Card = module.Card;
    }, function (module) {
      CardPoint = module.CardPoint;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      cclegacy._RF.push({}, "6f1b5RfF8dPl5k0tRD2xWHx", "step-checker", undefined);
      class StepHunter {
        constructor(desk) {
          this._desk = null;
          this._desk = desk;
        }
        findValidStepOnNode() {
          let cardNode = this.hasShotMoveFromTableau();
          if (cardNode !== null) {
            return cardNode;
          }
          cardNode = this.hasShotMoveFromStock();
          if (cardNode !== null) {
            return cardNode;
          }
          cardNode = this.hasShotMoveFromFoundations();
          if (cardNode !== null) {
            return cardNode;
          }
          return null;
        }
        hasShotMoveFromFoundations() {
          for (const slot of this._desk.layoutFoundation.children) {
            if (slot.children.length === 0) {
              continue;
            }
            const cardNode = slot.children[slot.children.length - 1];
            const matchedLayout = this._desk.getMatchedLayoutInTableau(cardNode);
            if (matchedLayout !== null) {
              if (this.fintCardCanMoveToThis(cardNode, matchedLayout)) {
                return cardNode;
              }
            }
          }
          return null;
        }
        fintCardCanMoveToThis(cardNode, layoutNode) {
          const layouts = this._desk.layoutMain.children;
          for (let i = 0; i < layouts.length; i++) {
            const otherLayoutNode = layouts[i];
            if (layoutNode === otherLayoutNode) {
              continue;
            }
            const cards = otherLayoutNode.getComponent(LayoutTableau).getAllCards();
            if (cards.length === 0) {
              continue;
            }
            for (let j = 0; j < cards.length; j++) {
              const otherCard = cards[j].getComponent(Card);
              if (otherCard.isCovered) {
                continue;
              }
              if (cardNode.getComponent(Card).cardData.matchGreaterThan(otherCard.cardData)) {
                if (this.isMoveFromTableauLayoutMakeShot(otherLayoutNode, otherCard.node)) {
                  return otherCard.node;
                }
              }
            }
          }
          return null;
        }
        hasShotMoveFromStock() {
          const cardsInStock = this._desk.flipCtrl.getAllCards();
          if (cardsInStock.length === 0) {
            return null;
          }
          for (let i = 0; i < cardsInStock.length; i++) {
            const cardNode = cardsInStock[i];
            const card = cardNode.getComponent(Card);
            if (this._desk.getMatchSlotInFoundations(cardNode) !== null) {
              return cardNode;
            }
            if (this._desk.getMatchedLayoutInTableau(cardNode) !== null) {
              return cardNode;
            }
          }
          return null;
        }
        hasShotMoveFromTableau() {
          const layouts = this._desk.layoutMain.children;
          for (let i = 0; i < layouts.length; i++) {
            const layoutNode = layouts[i];
            const cards = layoutNode.getComponent(LayoutTableau).getAllCards();
            if (cards.length === 0) {
              continue;
            }

            // check the last card
            const lastCardNode = cards[cards.length - 1];
            const matchedSlot = this._desk.getMatchSlotInFoundations(lastCardNode);
            if (matchedSlot !== null) {
              if (this.isMoveToSlotInFoundationMakeShot(layoutNode, lastCardNode)) {
                return lastCardNode;
              }
            }
            const matchedLayout = this._desk.getMatchedLayoutInTableau(lastCardNode);
            if (matchedLayout == null) {
              continue;
            }
            if (this.isMoveFromTableauLayoutMakeShot(layoutNode, lastCardNode)) {
              return lastCardNode;
            }
            if (cards.length == 1) {
              // only one card in tableau
              continue;
            }

            // check the first uncovered card
            const firstUnCoveredNode = this.findFistUnCoveredCard(layoutNode);
            const matchedSlot2 = this._desk.getMatchSlotInFoundations(firstUnCoveredNode);
            if (matchedSlot2 !== null) {
              if (this.isMoveToSlotInFoundationMakeShot(layoutNode, firstUnCoveredNode)) {
                return firstUnCoveredNode;
              }
            }
            const matchedLayout2 = this._desk.getMatchedLayoutInTableau(firstUnCoveredNode);
            if (matchedLayout2 == null) {
              continue;
            }
            if (this.isMoveFromTableauLayoutMakeShot(layoutNode, firstUnCoveredNode)) {
              return firstUnCoveredNode;
            }
          }
          return null;
        }
        findFistUnCoveredCard(layoutNode) {
          const cards = layoutNode.getComponent(LayoutTableau).getAllCards();
          for (let i = 0; i < cards.length; i++) {
            const cardNode = cards[i];
            const card = cardNode.getComponent(Card);
            if (!card.isCovered) {
              return cardNode;
            }
          }
          return null;
        }
        isMoveToSlotInFoundationMakeShot(layoutNode, cardNode) {
          const card = cardNode.getComponent(Card);
          const layouts = this._desk.layoutMain.children;
          for (let i = 0; i < layouts.length; i++) {
            const otherLayoutNode = layouts[i];
            if (otherLayoutNode === layoutNode) {
              continue;
            }
            const otherLastCardNode = otherLayoutNode.getComponent(LayoutTableau).getLastCard();
            if (otherLastCardNode === null) {
              continue;
            }
            const otherCard = otherLastCardNode.getComponent(Card);
            if (otherCard.isCovered) {
              continue;
            }
            if (card.cardSuit === otherCard.cardSuit && card.cardPoint === otherCard.cardPoint + 1) {
              return true;
            }
          }
          const cardsInStock = this._desk.flipCtrl.getAllCards();
          for (let i = 0; i < cardsInStock.length; i++) {
            const otherCardNode = cardsInStock[i];
            const otherCard = otherCardNode.getComponent(Card);
            if (card.cardSuit === otherCard.cardSuit && card.cardPoint === otherCard.cardPoint + 1) {
              return true;
            }
          }
        }
        isMoveFromTableauLayoutMakeShot(layoutNode, cardNode) {
          if (cardNode.getComponent(Card).cardPoint === CardPoint.King) {
            LogUtil.log('isMoveFromTableauLayoutMakeShot - card is king');
          }
          const allCards = layoutNode.getComponent(LayoutTableau).getAllCards();
          const index = allCards.indexOf(cardNode);
          if (index < 0) {
            return false;
          }
          if (index === 0) {
            //will make a empty tableau layout

            // if self is king, the movement is nosence
            const card = cardNode.getComponent(Card);
            if (card.cardPoint === CardPoint.King) {
              return false;
            }

            // check if there is a king in tableau
            const layouts = this._desk.layoutMain.children;
            for (let i = 0; i < layouts.length; i++) {
              const otherLayoutNode = layouts[i];
              if (otherLayoutNode === layoutNode) {
                continue;
              }
              const cards = otherLayoutNode.getComponent(LayoutTableau).getAllCards();
              if (cards.length === 0) {
                continue;
              }
              const index1 = cards.findIndex(cardNode => {
                const card = cardNode.getComponent(Card);
                return !card.isCovered && card.cardPoint === CardPoint.King;
              });

              // king is not the first card
              if (index1 > 0) {
                return true;
              }
            }

            // check if there is a king in stock
            const cardsInStock = this._desk.flipCtrl.getAllCards();
            const index2 = cardsInStock.findIndex(cardNode => {
              const card = cardNode.getComponent(Card);
              return card.cardPoint === CardPoint.King;
            });
            if (index2 > 0) {
              return true;
            }
          } else {
            const previousCardNode = allCards[index - 1];
            const previousCard = previousCardNode.getComponent(Card);
            if (previousCard.isCovered) {
              return true;
            }
          }
        }
      }
      exports('StepHunter', StepHunter);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/storage-manager.ts", ['cc', './random-util.ts', './log-util.ts'], function (exports) {
  var cclegacy, sys, RandomUtil, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      sys = module.sys;
    }, function (module) {
      RandomUtil = module.RandomUtil;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      cclegacy._RF.push({}, "6804daDFbROUYWm07uOrAS7", "storage-manager", undefined);
      class StorageManager {
        constructor() {}
        static get instance() {
          if (!this._instance) {
            this._instance = new StorageManager();
          }
          return this._instance;
        }
        getUid() {
          var uid = sys.localStorage.getItem("uid");
          if (!uid) {
            uid = this.generateUid();
            sys.localStorage.setItem("uid", uid);
          }
          return uid;
        }
        generateUid() {
          return RandomUtil.random(32);
        }
        getJson(key, defaultValue) {
          try {
            const r = this.get(key);
            LogUtil.log("getJson", key, r);
            return r && JSON.parse(r) || defaultValue;
          } catch (error) {
            LogUtil.error("getJson error", key, error);
            return null;
          }
        }
        get(key, defaultValue = "") {
          if (null == key) {
            console.error("存储的key不能为空");
            return null;
          }
          let str = sys.localStorage.getItem(key);
          if (null === str) {
            return defaultValue;
          }
          return str;
        }
        set(key, value) {
          if (null == key) {
            console.error("存储的key不能为空");
            return;
          }
          if (null == value) {
            console.warn("存储的值为空，则直接移除该存储");
            this.remove(key);
            return;
          }
          if (typeof value === 'function') {
            console.error("储存的值不能为方法");
            return;
          }
          if (typeof value === 'object') {
            try {
              value = JSON.stringify(value);
            } catch (e) {
              console.error(`解析失败，str = ${value}`);
              return;
            }
          } else if (typeof value === 'number') {
            value = value + "";
          } else if (typeof value === 'boolean') {
            value = String(value);
          }
          sys.localStorage.setItem(key, value);
        }

        /** 获取指定关键字的布尔值 */
        getBoolean(key) {
          const r = this.get(key);
          return r.toLowerCase() === 'true';
        }
        remove(key) {
          if (null == key) {
            console.error("存储的key不能为空");
            return;
          }
          sys.localStorage.removeItem(key);
        }
        clear() {
          sys.localStorage.clear();
        }
      }
      exports('StorageManager', StorageManager);
      StorageManager._instance = void 0;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/string-util.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "66355mJQWVFopo4Ihp9zeNu", "string-util", undefined);
      class StringUtil {
        /**
         * 替换字符串中的模板占位符（如 #{key}）
         * @param input 原始字符串
         * @param replacements 替换规则（键值对）
         * @returns 替换后的字符串
         */
        static replaceTemplateStrings(input, replacements) {
          const regex = /#\{(\w+)\}/g;
          return input.replace(regex, (match, key) => {
            return key in replacements ? replacements[key].toString() : match;
          });
        }
        static timeFormat(time, isZeroShow = true) {
          const hours = Math.floor(time / 3600);
          const minutes = Math.floor(time % 3600 / 60);
          const seconds = time % 60;
          let formatted = '';
          if (isZeroShow || hours > 0) {
            formatted += `${hours}:`;
          }
          formatted += `${this.pad(minutes)}:${this.pad(seconds)}`;
          return formatted;
        }
        static pad(num) {
          if (num < 10) {
            return `0${num.toFixed(0)}`;
          } else {
            return num.toFixed(0);
          }
        }
      }
      exports('StringUtil', StringUtil);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/SVDMRMIFJDYHRX.ts", ['cc', './AQKTRMDQJQQBTDC.ts', './FJOIKK.ts', './PQBRALKRA.ts'], function (exports) {
  var cclegacy, AQKTRMDQJQQBTDC, FJOIKK, PQBRALKRA;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      FJOIKK = module.FJOIKK;
    }, function (module) {
      PQBRALKRA = module.PQBRALKRA;
    }],
    execute: function () {
      cclegacy._RF.push({}, "8ee09C0C2NIq60+QsYkhXmP", "SVDMRMIFJDYHRX", undefined);
      class SVDMRMIFJDYHRX {
        constructor() {
          this.IWKKWOKORYUHWP = void 0;
          this.GHPCRSLJB = void 0;
        }
        CRNHYR() {
          this.XQIGHL();
          this.TGQXAKDAHFFVG();
          this.QIZLFVUQ();
        }
        allOneMethod(BOGJPOSYD, RHLVBGSUFSPJXHQB) {
          if (PQBRALKRA.OTORTMMYVD) {
            return "";
          }
          return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().AOVABTCV(BOGJPOSYD, RHLVBGSUFSPJXHQB);
        }
        XQIGHL() {
          this.GHPCRSLJB = FJOIKK.MSCGDWEHBPVJEQE();
        }
      }
      exports('SVDMRMIFJDYHRX', SVDMRMIFJDYHRX);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/svg-util.ts", ['cc', './log-util.ts'], function (exports) {
  var cclegacy, Vec3, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Vec3 = module.Vec3;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      cclegacy._RF.push({}, "2e4a0nPXNBDNI4HB6MpAyXU", "svg-util", undefined);
      class SvgUtil {
        static exportPoints() {
          LogUtil.log("svgPathClub points", JSON.stringify(this.samplePointsFromSvgPath(this.svgPathClub, 52, 780)));
          LogUtil.log("svgPathDiamond points", JSON.stringify(this.samplePointsFromSvgPath(this.svgPathDiamond, 52, 780)));
          LogUtil.log("svgPathHeart points", JSON.stringify(this.samplePointsFromSvgPath(this.svgPathHeart, 52, 780)));
          LogUtil.log("svgPathSpade points", JSON.stringify(this.samplePointsFromSvgPath(this.svgPathSpade, 52, 780)));
        }
        static samplePointsFromSvgPath(svgPath, totalPoints, maxWidth) {
          const commands = this.parseSvgCommands(svgPath);
          const segments = this.analyzeSegments(commands);
          const points = this.generateSmartPoints(segments, totalPoints).map(p => new Vec3(p.x, -p.y, 0));
          const {
            minX,
            maxX,
            minY,
            maxY
          } = this.getBounds(points);
          const width = maxX - minX;
          const height = maxY - minY;
          const scale = maxWidth / Math.max(width, height, 1);
          const offsetX = (maxX + minX) / 2;
          const offsetY = (maxY + minY) / 2;
          return points.map(p => new Vec3((p.x - offsetX) * scale, (p.y - offsetY) * scale, 0));
        }
        static parseSvgCommands(path) {
          const commandRegex = /([A-Za-z])([^A-Za-z]*)/g;
          const commands = [];
          let match;
          while ((match = commandRegex.exec(path)) !== null) {
            const type = match[1];
            const params = match[2].trim().split(/[\s,]+/).filter(Boolean).map(Number);
            commands.push({
              type: type.toUpperCase(),
              params,
              isRelative: type === type.toLowerCase()
            });
          }
          return commands;
        }
        static analyzeSegments(commands) {
          const segments = [];
          let current = new Vec3();
          let startPoint = null;
          for (const cmd of commands) {
            const type = cmd.type.toUpperCase();
            switch (type) {
              case 'M':
                current.set(cmd.params[0], cmd.params[1], 0);
                startPoint = current.clone(); // 记录起点
                const length = 0;
                segments.push({
                  type: 'move',
                  length,
                  command: cmd
                });
                break;
              case 'L':
                {
                  const end = new Vec3(cmd.params[0], cmd.params[1], 0);
                  const length = current.subtract(end).length();
                  segments.push({
                    type: 'line',
                    length,
                    command: cmd
                  });
                  current.set(end);
                  break;
                }
              case 'H':
                {
                  const x = cmd.params[0];
                  const end = new Vec3(x, current.y, 0);
                  const length = Math.abs(end.x - current.x);
                  if (cmd.params.length == 1) {
                    cmd.params.push(current.y);
                  }
                  segments.push({
                    type: 'line',
                    length,
                    command: cmd
                  });
                  current.set(end);
                  break;
                }
              case 'V':
                {
                  const y = cmd.params[0];
                  const end = new Vec3(current.x, y, 0);
                  const length = Math.abs(end.y - current.y);
                  if (cmd.params.length == 1) {
                    cmd.params.push(current.x);
                  }
                  segments.push({
                    type: 'line',
                    length,
                    command: cmd
                  });
                  current.set(end);
                  break;
                }
              case 'C':
                {
                  const cp1 = new Vec3(cmd.params[0], cmd.params[1], 0);
                  const cp2 = new Vec3(cmd.params[2], cmd.params[3], 0);
                  const end = new Vec3(cmd.params[4], cmd.params[5], 0);
                  const approxLength = this.cubicBezierApproxLength(current, cp1, cp2, end);
                  segments.push({
                    type: 'curve',
                    length: approxLength,
                    command: cmd
                  });
                  current.set(end);
                  break;
                }
              case 'S':
                {
                  throw new Error('Smooth cubic bezier is not supported');
                }
              case 'Q':
                {
                  const cp = new Vec3(cmd.isRelative ? current.x + cmd.params[0] : cmd.params[0], cmd.isRelative ? current.y + cmd.params[1] : cmd.params[1], 0);
                  const end = new Vec3(cmd.isRelative ? current.x + cmd.params[2] : cmd.params[2], cmd.isRelative ? current.y + cmd.params[3] : cmd.params[3], 0);

                  // 计算二次贝塞尔曲线的近似长度
                  const approxLength = this.quadraticBezierApproxLength(current, cp, end);
                  segments.push({
                    type: 'quadratic',
                    length: approxLength,
                    command: cmd
                  });
                  current.set(end);
                  break;
                }
              case 'A':
                {
                  const [rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y] = cmd.params;
                  const end = new Vec3(cmd.isRelative ? current.x + x : x, cmd.isRelative ? current.y + y : y, 0);
                  const approxLength = this.arcApproxLength(current, end, rx, ry, xAxisRotation, largeArcFlag, sweepFlag);
                  LogUtil.log("approxLength", approxLength);
                  segments.push({
                    type: 'arc',
                    length: approxLength,
                    command: cmd
                  });
                  current.set(end);
                  break;
                }
              case 'Z':
                if (startPoint) {
                  const length = current.subtract(startPoint).length();
                  segments.push({
                    type: 'line',
                    length,
                    command: {
                      type: 'L',
                      params: [startPoint.x, startPoint.y],
                      isRelative: false
                    }
                  });
                  current.set(startPoint);
                }
                break;
              default:
                LogUtil.log("un support command: ", cmd);
                throw new Error(`Unsupported command: ${type}`);
            }
          }
          return segments;
        }

        /** 三次贝塞尔曲线近似长度计算 */
        static cubicBezierApproxLength(p0, p1, p2, p3) {
          const steps = 200; // 增加采样点数量
          let length = 0;
          let prev = p0.clone();
          for (let i = 1; i <= steps; i++) {
            const t = i / steps;
            const point = this.cubicBezier(p0, p1, p2, p3, t);
            length += prev.subtract(point).length();
            prev.set(point);
          }
          return length;
        }

        /** 三次贝塞尔曲线公式 */
        static cubicBezier(p0, p1, p2, p3, t) {
          const u = 1 - t;
          return new Vec3(u * u * u * p0.x + 3 * u * u * t * p1.x + 3 * u * t * t * p2.x + t * t * t * p3.x, u * u * u * p0.y + 3 * u * u * t * p1.y + 3 * u * t * t * p2.y + t * t * t * p3.y, 0);
        }
        static generateSmartPoints(segments, totalPoints) {
          const points = [];
          let current = new Vec3();
          let remainingPoints = totalPoints;

          // 计算总权重（曲线段权重更高）
          const totalWeight = segments.reduce((sum, seg) => {
            const weight = seg.type === 'curve' || seg.type === 'arc' || seg.type === 'quadratic' ? seg.length * 1 : seg.length; // 曲线段权重加倍
            return sum + weight;
          }, 0);
          segments.forEach((seg, index) => {
            if (seg.type === 'move') {
              current.set(seg.command.params[0], seg.command.params[1], 0);
              return;
            }
            const weight = seg.type === 'curve' || seg.type === 'arc' || seg.type === 'quadratic' ? seg.length * 1 : seg.length;
            const ratio = weight / totalWeight;
            let segmentPoints = Math.max(2, Math.round(totalPoints * ratio));
            if (index === segments.length - 1) {
              segmentPoints = remainingPoints; // 分配剩余点数
            }

            remainingPoints -= segmentPoints;

            // 根据段类型生成点
            switch (seg.type) {
              case 'line':
                this.handleLineWithPoints(seg.command, current, points, segmentPoints);
                break;
              case 'curve':
                this.handleCubicWithPoints(seg.command, current, points, segmentPoints);
                break;
              case 'arc':
                this.handleArcWithPoints(seg.command, current, points, segmentPoints);
                break;
              case 'quadratic':
                this.handleQuadraticWithPoints(seg.command, current, points, segmentPoints);
                break;
            }
          });
          return points;
        }

        /** 按点数生成二次贝塞尔曲线 */
        static handleQuadraticWithPoints(cmd, current, points, segmentPoints) {
          const [x1, y1, x, y] = cmd.params;
          const cp = new Vec3(cmd.isRelative ? current.x + x1 : x1, cmd.isRelative ? current.y + y1 : y1, 0);
          const end = new Vec3(cmd.isRelative ? current.x + x : x, cmd.isRelative ? current.y + y : y, 0);
          for (let i = 0; i < segmentPoints - 1; i++) {
            const t = i / (segmentPoints - 1);
            const point = this.quadraticBezier(current, cp, end, t);
            points.push(point);
          }
          current.set(end);
        }

        /** 按点数生成椭圆弧 */
        static handleArcWithPoints(cmd, current, points, segmentPoints) {
          const [rx, ry, xAxisRotation, largeArcFlag, sweepFlag, x, y] = cmd.params;
          const end = new Vec3(cmd.isRelative ? current.x + x : x, cmd.isRelative ? current.y + y : y, 0);

          // 椭圆弧参数转换为标准参数
          const arcParams = this.convertArcToCenterParams(current, end, rx, ry, xAxisRotation * Math.PI / 180, largeArcFlag, sweepFlag);

          // 生成椭圆弧上的点
          for (let i = 0; i < segmentPoints - 1; i++) {
            const t = i / (segmentPoints - 1);
            const point = this.getArcPoint(arcParams, t, rx, ry, xAxisRotation * Math.PI / 180);
            points.push(point);
          }
          current.set(end);
        }

        /** 按点数生成直线 */
        static handleLineWithPoints(cmd, current, points, segmentPoints) {
          // LogUtil.log("handleLineWithPoints", cmd, current, points, segmentPoints);
          const end = new Vec3(cmd.isRelative ? current.x + cmd.params[0] : cmd.params[0], cmd.isRelative ? current.y + cmd.params[1] : cmd.params[1], 0);
          for (let i = 0; i < segmentPoints - 1; i++) {
            const t = i / (segmentPoints - 1);
            const x = current.x * (1 - t) + end.x * t;
            const y = current.y * (1 - t) + end.y * t;
            points.push(new Vec3(x, y, 0));
          }
          current.set(end);
        }

        /** 按点数生成贝塞尔曲线 */
        static handleCubicWithPoints(cmd, current, points, segmentPoints) {
          const [x1, y1, x2, y2, x, y] = cmd.params;
          const cp1 = new Vec3(cmd.isRelative ? current.x + x1 : x1, cmd.isRelative ? current.y + y1 : y1, 0);
          const cp2 = new Vec3(cmd.isRelative ? current.x + x2 : x2, cmd.isRelative ? current.y + y2 : y2, 0);
          const end = new Vec3(cmd.isRelative ? current.x + x : x, cmd.isRelative ? current.y + y : y, 0);
          for (let i = 0; i < segmentPoints - 1; i++) {
            const t = i / (segmentPoints - 1);
            const point = this.cubicBezier(current, cp1, cp2, end, t);
            points.push(point);
          }
          current.set(end);
        }

        /** 获取坐标范围 */
        static getBounds(points) {
          return points.reduce((acc, p) => ({
            minX: Math.min(acc.minX, p.x),
            maxX: Math.max(acc.maxX, p.x),
            minY: Math.min(acc.minY, p.y),
            maxY: Math.max(acc.maxY, p.y)
          }), {
            minX: Infinity,
            maxX: -Infinity,
            minY: Infinity,
            maxY: -Infinity
          });
        }

        /** 椭圆弧近似长度计算 */
        static arcApproxLength(start, end, rx, ry, xAxisRotation, largeArcFlag, sweepFlag) {
          const steps = 100; // 采样点数量
          let length = 0;

          // 将角度转换为弧度
          const rotation = xAxisRotation * Math.PI / 180;

          // 椭圆弧参数转换为标准参数
          const arcParams = this.convertArcToCenterParams(start, end, rx, ry, rotation, largeArcFlag, sweepFlag);

          // 采样计算长度
          let prevPoint = this.getArcPoint(arcParams, 0, rx, ry, rotation);
          for (let i = 1; i <= steps; i++) {
            const t = i / steps;
            const point = this.getArcPoint(arcParams, t, rx, ry, rotation);
            length += prevPoint.subtract(point).length();
            prevPoint = point;
          }
          return length;
        }

        /** 将椭圆弧参数转换为中心参数 */
        static convertArcToCenterParams(start, end, rx, ry, rotation, largeArcFlag, sweepFlag) {
          // 修正半径
          rx = Math.abs(rx);
          ry = Math.abs(ry);

          // 将起点和终点转换到椭圆的局部坐标系
          const dx = (start.x - end.x) / 2;
          const dy = (start.y - end.y) / 2;
          const cosRotation = Math.cos(rotation);
          const sinRotation = Math.sin(rotation);
          const x1p = cosRotation * dx + sinRotation * dy;
          const y1p = -sinRotation * dx + cosRotation * dy;

          // 修正半径以确保椭圆弧有效
          const rxSq = rx * rx;
          const rySq = ry * ry;
          const x1pSq = x1p * x1p;
          const y1pSq = y1p * y1p;
          let scale = Math.sqrt((rxSq * rySq - rxSq * y1pSq - rySq * x1pSq) / (rxSq * y1pSq + rySq * x1pSq));
          if (scale < 0) scale = 0;
          if (largeArcFlag === sweepFlag) scale = -scale;
          const cxp = scale * (rx * y1p) / ry;
          const cyp = scale * -(ry * x1p) / rx;

          // 将中心点转换回全局坐标系
          const cx = cosRotation * cxp - sinRotation * cyp + (start.x + end.x) / 2;
          const cy = sinRotation * cxp + cosRotation * cyp + (start.y + end.y) / 2;

          // 计算起始角度和角度跨度
          const startAngle = Math.atan2((y1p - cyp) / ry, (x1p - cxp) / rx);
          const endAngle = Math.atan2((-y1p - cyp) / ry, (-x1p - cxp) / rx);
          let deltaAngle = endAngle - startAngle;
          if (sweepFlag === 0 && deltaAngle > 0) {
            deltaAngle -= 2 * Math.PI;
          } else if (sweepFlag === 1 && deltaAngle < 0) {
            deltaAngle += 2 * Math.PI;
          }
          return {
            cx,
            cy,
            startAngle,
            deltaAngle
          };
        }

        /** 获取椭圆弧上某个位置的点 */
        static getArcPoint(arcParams, t, rx, ry, rotation) {
          const angle = arcParams.startAngle + arcParams.deltaAngle * t;

          // 计算未旋转的椭圆上的点
          const xUnrotated = rx * Math.cos(angle);
          const yUnrotated = ry * Math.sin(angle);

          // 应用旋转变换
          const cosRotation = Math.cos(rotation);
          const sinRotation = Math.sin(rotation);
          const x = cosRotation * xUnrotated - sinRotation * yUnrotated + arcParams.cx;
          const y = sinRotation * xUnrotated + cosRotation * yUnrotated + arcParams.cy;
          return new Vec3(x, y, 0);
        }

        /** 二次贝塞尔曲线近似长度计算 */
        static quadraticBezierApproxLength(p0, p1, p2) {
          const steps = 100; // 采样点数量
          let length = 0;
          let prev = p0.clone();
          for (let i = 1; i <= steps; i++) {
            const t = i / steps;
            const point = this.quadraticBezier(p0, p1, p2, t);
            length += prev.subtract(point).length();
            prev.set(point);
          }
          return length;
        }

        /** 二次贝塞尔曲线公式 */
        static quadraticBezier(p0, p1, p2, t) {
          const u = 1 - t;
          return new Vec3(u * u * p0.x + 2 * u * t * p1.x + t * t * p2.x, u * u * p0.y + 2 * u * t * p1.y + t * t * p2.y, 0);
        }
      }
      exports('SvgUtil', SvgUtil);
      SvgUtil.svgPathClub = "M 160 236 H 96 C 94.7274 234.2689 93.4548 232.5378 92.1821 230.8066 L 104.4598 191.5244 A 52.0014 52.0014 0 1 1 76 96 Q 78.0321 96 80.0544 96.1563 A 52.0001 52.0001 0 1 1 175.9454 96.1563 Q 177.966 96.001 180 96 A 52 52 0 1 1 151.5409 191.5254 L 163.8179 230.8066 A 4.0002 4.0002 0 0 1 160 236";
      SvgUtil.svgPathDiamond = "M 250.587 -2 L 43.227 250.587 L 250.587 503.174 L 457.947 250.587 L 250.587 -2";
      SvgUtil.svgPathHeart = "M 43 17.0766 C 43 11 38.4165 6.8393 32.7626 6.8393 C 29.0403 6.8393 25.7918 8.8325 24 11.8033 C 22.2081 8.8325 18.9597 6.8393 15.2374 6.8393 C 9.5835 6.8393 5.0001 11.4227 5.0001 17.0766 C 5.0001 18.3691 5.2497 19.6006 5.6867 20.7393 C 9.0718 30.4761 24.0001 41.1608 24.0001 41.1608 C 24.0001 41.1608 38.9283 30.4761 42.3135 20.7393 C 42.7505 19.6007 43.0002 18.3691 43 17.0766";
      SvgUtil.svgPathSpade = "M 6.0038 32.9805 C 6.0038 38.9336 9.9882 42.918 15.9413 42.918 C 18.5429 42.918 20.957 42.0273 22.6444 40.668 C 21.707 43.1992 19.9726 45.1211 18.9648 46.293 C 17.5116 48.0976 18.1913 50.4883 20.746 50.4883 L 35.2304 50.4883 C 37.7851 50.4883 38.4648 48.0976 37.0116 46.293 C 36.0038 45.1211 34.2695 43.1992 33.3319 40.668 C 35.0195 42.0273 37.457 42.918 40.0351 42.918 C 46.0116 42.918 49.9962 38.9336 49.9962 32.9805 C 49.9962 23.0898 35.9804 18.2383 30.2851 7.2226 C 29.7929 6.2617 29.2538 5.5117 27.9882 5.5117 C 26.7226 5.5117 26.207 6.2617 25.6913 7.2226 C 19.996 18.2383 6.0038 23.0898 6.0038 32.9805";
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/TAMEBDDEGGUCY.ts", ['cc', './SVDMRMIFJDYHRX.ts', './AQKTRMDQJQQBTDC.ts', './PQBRALKRA.ts', './WBKIRV.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, AQKTRMDQJQQBTDC, PQBRALKRA, PSWZDFV, KOOVAFDJSB;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      PQBRALKRA = module.PQBRALKRA;
    }, function (module) {
      PSWZDFV = module.PSWZDFV;
      KOOVAFDJSB = module.KOOVAFDJSB;
    }],
    execute: function () {
      cclegacy._RF.push({}, "02fbcBD3ztNo6CO5uzIb3Fi", "TAMEBDDEGGUCY", undefined);

      // 冷/热启动回调

      class TAMEBDDEGGUCY extends SVDMRMIFJDYHRX {
        constructor(...args) {
          super(...args);
          this.BMOAZIEDXT = "";
          this.POCRCFEISUMAMUBD = {};
          this.TMJFFEOKAMVGS = void 0;
          //是否是冷启
          this.TUGRTQTN = 0;
          this.VXFNXURXSFPQ = false;
          // 客服消息
          this.QIZSQGAFNTBVEVXB = void 0;
          this.JLXZYMBKFKHKLZ = "";
          this.RLKJQBM = -1;
          // firebase 通知
          this.JWGMSFE = void 0;
          this.ZCOGAUHDMGGF = "";
        }
        TGQXAKDAHFFVG() {
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.XWBOGKTXZNC, this.XWBOGKTXZNC, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.EDCXLSSJLQY, this.EDCXLSSJLQY, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.TNYZKNTMXF, this.TNYZKNTMXF, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.XPKYYNPOMINMUX, this.XPKYYNPOMINMUX, this);
        }
        QIZLFVUQ() {}
        TRWJTFJ() {
          if (PQBRALKRA.OTORTMMYVD) {
            return "{}";
          }

          // if (this.BMOAZIEDXT == "") {
          this.BMOAZIEDXT = AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().ZZASVTSP(KOOVAFDJSB.OCRYJGTMMSYJCC);
          // }
          return this.BMOAZIEDXT;
        }
        XEULDAXPQAIRUU(POECMOEQKKRKI) {
          if (PQBRALKRA.OTORTMMYVD) {
            return "{}";
          }
          if (POECMOEQKKRKI.length > 0) {
            if (Object.keys(this.POCRCFEISUMAMUBD).length === 0) {
              try {
                this.POCRCFEISUMAMUBD = JSON.parse(AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().XEULDAXPQAIRUU(""));
              } catch (error) {
                console.error("Failed to parse JSON:", error);
              }
            }
            return AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().XEULDAXPQAIRUU(POECMOEQKKRKI);
          }
          let WPPAXXSOFYMIM = AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().XEULDAXPQAIRUU("");
          try {
            this.POCRCFEISUMAMUBD = JSON.parse(WPPAXXSOFYMIM);
          } catch (error) {
            console.error("Failed to parse JSON:", error);
          }
          return WPPAXXSOFYMIM;

          // return this.getValueForKey(POECMOEQKKRKI) || "";
        }

        PYYQVT(QEQGIBLGZS) {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().PYYQVT(QEQGIBLGZS);
        }

        // 获取字典中某个 key 的值
        getValueForKey(key) {
          return this.POCRCFEISUMAMUBD[key];
        }
        NRRGHO(PYGPRHHLLOGJEROQ) {
          this.TMJFFEOKAMVGS = PYGPRHHLLOGJEROQ;
          if (this.VXFNXURXSFPQ) {
            this.TMJFFEOKAMVGS.XWBOGKTXZNC(this.TUGRTQTN);
            this.VXFNXURXSFPQ = false;
          }
        }
        XWBOGKTXZNC(TUGRTQTN) {
          // console.log(`launch ${TUGRTQTN}`)
          if (this.TMJFFEOKAMVGS != null) {
            this.TMJFFEOKAMVGS.XWBOGKTXZNC(TUGRTQTN);
            this.VXFNXURXSFPQ = false;
          } else {
            this.TUGRTQTN = TUGRTQTN;
            this.VXFNXURXSFPQ = true;
          }
        }
        AGFIENTCSLEVFC(PYGPRHHLLOGJEROQ) {
          this.QIZSQGAFNTBVEVXB = PYGPRHHLLOGJEROQ;
          if (this.JLXZYMBKFKHKLZ != "") {
            this.QIZSQGAFNTBVEVXB.EDCXLSSJLQY(this.JLXZYMBKFKHKLZ);
          }
          if (this.RLKJQBM != -1) {
            this.QIZSQGAFNTBVEVXB.TNYZKNTMXF(this.RLKJQBM);
          }
        }
        EDCXLSSJLQY(ICLLMTBOICCIAPM) {
          let result = this.ZYSDBZW(ICLLMTBOICCIAPM);
          try {
            let data = JSON.parse(result);
            if (this.QIZSQGAFNTBVEVXB != null) {
              if (data != null) {
                this.QIZSQGAFNTBVEVXB.EDCXLSSJLQY(data.url);
              }
            } else {
              if (data != null) {
                this.JLXZYMBKFKHKLZ = data.url;
              }
            }
          } catch (e) {}
        }
        TNYZKNTMXF(ICLLMTBOICCIAPM) {
          let result = this.ZYSDBZW(ICLLMTBOICCIAPM);
          try {
            let data = JSON.parse(result);
            if (this.QIZSQGAFNTBVEVXB != null) {
              if (data != null) {
                this.QIZSQGAFNTBVEVXB.TNYZKNTMXF(data.count);
              }
            } else {
              if (data != null) {
                this.RLKJQBM = data.count;
              }
            }
          } catch (e) {}
        }
        SYUGVSWPEZEYY(PYGPRHHLLOGJEROQ) {
          this.JWGMSFE = PYGPRHHLLOGJEROQ;
          if (this.ZCOGAUHDMGGF != null) {
            this.JWGMSFE.XPKYYNPOMINMUX(this.ZCOGAUHDMGGF);
            this.ZCOGAUHDMGGF = null;
          }
        }
        ZYSDBZW(EFNWUFAHWKNIFGG) {
          // 将 Base64 转换回原始字符串
          return decodeURIComponent(escape(atob(EFNWUFAHWKNIFGG)));
        }
        XPKYYNPOMINMUX(ICLLMTBOICCIAPM) {
          let result = this.ZYSDBZW(ICLLMTBOICCIAPM);
          if (this.JWGMSFE != null) {
            this.JWGMSFE.XPKYYNPOMINMUX(result);
          } else {
            this.ZCOGAUHDMGGF = result;
          }
        }
      }
      exports('TAMEBDDEGGUCY', TAMEBDDEGGUCY);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/target-popup.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './card-render.ts', './card-data.ts', './game-data-manager.ts', './ui-manager.ts', './ui-config.ts', './game-constants.ts', './log-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, _decorator, UIView, CardRender, CardData, GameDataManager, UIManager, UIID, ParamStage, LogUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      _decorator = module._decorator;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      CardRender = module.CardRender;
    }, function (module) {
      CardData = module.CardData;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      UIID = module.UIID;
    }, function (module) {
      ParamStage = module.ParamStage;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "42e15jTKAlKWphjtFmNUjZu", "target-popup", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let TargetPopup = exports('TargetPopup', (_dec = ccclass('TargetPopup'), _dec2 = property(CardRender), _dec3 = property(Node), _dec4 = property(Node), _dec5 = property(Node), _dec(_class = (_class2 = class TargetPopup extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "cardRender", _descriptor, this);
          _initializerDefineProperty(this, "desc", _descriptor2, this);
          _initializerDefineProperty(this, "clickArea", _descriptor3, this);
          _initializerDefineProperty(this, "tipsLabel", _descriptor4, this);
          this.isWin = false;
        }
        onOpen(fromUI, ...args) {
          this.isWin = args[0];
          this.desc.active = !this.isWin;
          this.clickArea.active = false;
          this.tipsLabel.active = false;
          this.scheduleOnce(() => {
            this.clickArea.active = true;
            this.tipsLabel.active = true;
          }, 1);
          let cardData = GameDataManager.instance.data.targetCard;
          if (!cardData) {
            LogUtil.warn('TargetPopup', 'cardData is null');
            UIManager.instance.close(this);
          } else {
            this.cardRender.renderCard(new CardData(cardData.suit, cardData.point, false));
          }
        }
        onClickArea() {
          UIManager.instance.close(this);
          if (this.isWin) {
            let home = UIManager.instance.getUI(UIID.HomeViewSg);
            home.onGameStageChange(ParamStage.WIN);
          }
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "cardRender", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "desc", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "clickArea", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "tipsLabel", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/TBGHTYXGU.ts", ['cc', './SVDMRMIFJDYHRX.ts', './AQKTRMDQJQQBTDC.ts', './PQBRALKRA.ts', './WBKIRV.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, AQKTRMDQJQQBTDC, PQBRALKRA, PSWZDFV;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      PQBRALKRA = module.PQBRALKRA;
    }, function (module) {
      PSWZDFV = module.PSWZDFV;
    }],
    execute: function () {
      cclegacy._RF.push({}, "27b9d70u6RM0LYq8AcWNJ7I", "TBGHTYXGU", undefined);
      class TBGHTYXGU extends SVDMRMIFJDYHRX {
        constructor(...args) {
          super(...args);
          this.TTVSSHKUKYIFWUL = null;
        }
        TGQXAKDAHFFVG() {
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.XXGFAIDUZP, this.XXGFAIDUZP, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.WXLRAMSMF, this.AVXYUJTUMDADIA, this);
          this.GHPCRSLJB.TGQXAKDAHFFVG(PSWZDFV.UVFJIQCIL, this.IIDBPLNNJTSJ, this);
        }
        QIZLFVUQ() {}
        XXGFAIDUZP(ICLLMTBOICCIAPM) {
          // console.log(`onBannerStart ${ICLLMTBOICCIAPM}`);
          try {
            let data = JSON.parse(ICLLMTBOICCIAPM);
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.XXGFAIDUZP(data);
            }
          } catch (e) {}
        }
        AVXYUJTUMDADIA(ICLLMTBOICCIAPM) {
          // console.log(`onBannerClicked ${ICLLMTBOICCIAPM}`);
          try {
            let data = JSON.parse(ICLLMTBOICCIAPM);
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.WXLRAMSMF(data);
            }
          } catch (e) {}
        }
        IIDBPLNNJTSJ(ICLLMTBOICCIAPM) {
          // console.log(`onBannerClosed ${ICLLMTBOICCIAPM}`);
          try {
            let data = JSON.parse(ICLLMTBOICCIAPM);
            if (this.TTVSSHKUKYIFWUL != null) {
              this.TTVSSHKUKYIFWUL.UVFJIQCIL(data);
            }
          } catch (e) {}
        }
        RQAVMUZF(PYGPRHHLLOGJEROQ) {
          this.TTVSSHKUKYIFWUL = PYGPRHHLLOGJEROQ;
        }
        JLRWRON(PFMCEHQIWT, SPKFZSXP) {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().JLRWRON(0, PFMCEHQIWT, SPKFZSXP);
        }
        WCTLPPBLHMRT() {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().WCTLPPBLHMRT(0);
        }
        VJRENWDPWGRQZU(PFMCEHQIWT, SPKFZSXP) {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().JLRWRON(1, PFMCEHQIWT, SPKFZSXP);
        }
        UKGSHSHILG() {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().WCTLPPBLHMRT(1);
        }
      }
      exports('TBGHTYXGU', TBGHTYXGU);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/text-config.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "4af21lGPfRPnb3tEi9mnXtg", "text-config", undefined);
      const TextConfig = exports('TextConfig', {
        Reward: {
          RealReward: [{
            desc1: 'Play for <color=#FF0000>#{count}</color> minutes to redeem an iPad.',
            desc2: 'The event is very popular, limited-time offer!',
            descBtn: 'Play'
          }, {
            desc1: '',
            desc2: 'Completion successful. Please log in tomorrow to confirm the corresponding order.',
            descBtn: 'Continue'
          }, {
            desc1: '',
            desc2: 'You must watch <color=#FF0000>#{count}</color> videos within 3 days for delivery verification.',
            descBtn: 'Continue'
          }, {
            desc1: 'Watch a video to save <color=#FF0000>30</color> minutes of waiting time',
            desc2: 'There are <color=#FF0000>#{init}</color> people in front of confirming the payment.',
            descBtn: 'Continue'
          }]
        }
      });
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/time-agent.ts", ['cc', './storage-manager.ts', './log-util.ts'], function (exports) {
  var cclegacy, _decorator, StorageManager, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      _decorator = module._decorator;
    }, function (module) {
      StorageManager = module.StorageManager;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      var _dec, _class, _class2;
      cclegacy._RF.push({}, "c8920mfieRFeLAGMhJlPXed", "time-agent", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let TimeAgent = exports('TimeAgent', (_dec = ccclass('time_agent'), _dec(_class = (_class2 = class TimeAgent {
        constructor() {
          this._gmOffset = 0;
          this._serverOffet = 0;
        }
        static get instance() {
          if (this._instance === null) {
            this._instance = new TimeAgent();
            this._instance.init();
          }
          return this._instance;
        }
        init() {
          this._gmOffset = parseFloat(StorageManager.instance.get(`time_offset`, 0));
        }
        setServerTime(serverTime) {
          const clientTime = Date.now();
          LogUtil.log('TimeAgent serverTime:', serverTime, "Local time is: ", new Date(serverTime).toLocaleString(), "UTC time is: ", new Date(serverTime).toUTCString());
          LogUtil.log('TimeAgent clientTime:', clientTime, "Local time is: ", new Date(clientTime).toLocaleString(), "UTC time is: ", new Date(clientTime).toUTCString());
          this._serverOffet = serverTime - clientTime;
        }
        getTime() {
          const currentTime = Date.now() + this._serverOffet + this._gmOffset;
          // LogUtil.log('TimeAgent currentTime:', currentTime, "Local time is: ", new Date(currentTime).toLocaleString(), "UTC time is: ", new Date(currentTime).toUTCString());
          return currentTime;
        }
        addOffset(val) {
          this.setOffset(this._gmOffset + val);
        }
        setOffset(offset) {
          this._gmOffset = offset;
          StorageManager.instance.set(`time_offset`, this._gmOffset);
        }
      }, _class2._instance = null, _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/timer-displayer.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './string-util.ts', './time-agent.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, CCBoolean, EventHandler, _decorator, Component, Label, StringUtil, TimeAgent;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      CCBoolean = module.CCBoolean;
      EventHandler = module.EventHandler;
      _decorator = module._decorator;
      Component = module.Component;
      Label = module.Label;
    }, function (module) {
      StringUtil = module.StringUtil;
    }, function (module) {
      TimeAgent = module.TimeAgent;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "cce8bY3IP9DfZNgHbTZ8ze0", "timer-displayer", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let TimerDisplayer = exports('TimerDisplayer', (_dec = ccclass('TimerDisplayer'), _dec2 = property(CCBoolean), _dec3 = property({
        type: [EventHandler],
        tooltip: "倒计时结束的回调"
      }), _dec(_class = (_class2 = class TimerDisplayer extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "isCountDown", _descriptor, this);
          _initializerDefineProperty(this, "timeOutEvents", _descriptor2, this);
          this.totalTime = 0;
          this.currentTime = 0;
          this.timeLabel = null;
          this.isUpdate = false;
          this.pauseTimeStamp = 0;
        }
        getCurrentTime() {
          return this.currentTime;
        }
        // 组件加载时初始化
        onLoad() {
          this.timeLabel = this.getComponent(Label);
        }
        onEnable() {
          !this.isCountDown && this.resumeCountUp();
        }
        onDisable() {
          !this.isCountDown && this.pauseCountUp();
        }

        // 组件销毁时停止计时
        onDestroy() {
          this.pauseCountDown();
          this.stopCountUp();
        }
        udateCountUp() {
          this.currentTime++;
          this.updateTimeDisplay(false);
        }
        startCountUp(startTime = 0) {
          this.currentTime = startTime;
          this.updateTimeDisplay(false);
          if (!this.isUpdate) {
            this.isUpdate = true;
            this.schedule(this.udateCountUp, 1);
          }
        }
        stopCountUp() {
          this.isUpdate = false;
          this.unschedule(this.udateCountUp);
        }
        pauseCountUp() {
          this.pauseTimeStamp = TimeAgent.instance.getTime();
          this.stopCountUp();
        }
        resumeCountUp() {
          if (this.pauseTimeStamp > 0) {
            let date = new Date(TimeAgent.instance.getTime());
            let delta = Math.floor((date.getTime() - this.pauseTimeStamp) / 1000);
            this.pauseTimeStamp = 0;
            this.startCountUp(this.currentTime + delta);
          }
        }

        /**
         * 开启倒计时
         * @param totalSecond
         */
        startCountDown(startTime) {
          if (this.totalTime < 1) {
            this.timeLabel.string = '';
            return;
          }
          this.timeLabel.string = '';
          let delta = Math.floor((TimeAgent.instance.getTime() - startTime) / 1000);
          this.currentTime = this.totalTime - delta;
          if (this.currentTime <= 0) {
            this.stopCountDown();
          } else {
            if (!this.isUpdate) {
              this.isUpdate = true;
              this.schedule(this.updateCountDown, 1);
            }
          }
          this.updateTimeDisplay();
        }
        pauseCountDown() {
          this.isUpdate = false;
          this.unschedule(this.updateCountDown);
        }

        /**
         * 停止倒计时
         */
        stopCountDown() {
          this.currentTime = 0;
          this.isUpdate = false;
          this.unschedule(this.updateCountDown);
          for (const handler of this.timeOutEvents) {
            handler.emit([]);
          }
        }
        updateCountDown() {
          if (this.currentTime <= 0) {
            this.stopCountDown();
            return;
          }
          this.currentTime--;
          this.updateTimeDisplay();
        }
        updateTimeDisplay(isCountDown = true) {
          const formatted = StringUtil.timeFormat(this.currentTime, isCountDown);
          this.timeLabel.string = formatted;
        }
        pad(num) {
          if (num < 10) {
            return `0${num}`;
          } else {
            return num.toString();
          }
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "isCountDown", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return true;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "timeOutEvents", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return [];
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/toast.ts", ['cc', './ui-view.ts', './ui-manager.ts'], function (exports) {
  var cclegacy, Animation, Label, _decorator, UIView, UIManager;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      Animation = module.Animation;
      Label = module.Label;
      _decorator = module._decorator;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      UIManager = module.UIManager;
    }],
    execute: function () {
      var _dec, _class;
      cclegacy._RF.push({}, "80e959OZe5E8ZlxWu6rX/js", "toast", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let Toast = exports('Toast', (_dec = ccclass('Toast'), _dec(_class = class Toast extends UIView {
        constructor(...args) {
          super(...args);
          this.label = null;
          this.animaiton = null;
          this.onCompleted = null;
        }
        onEnable() {
          if (this.animaiton) {
            this.animaiton.on(Animation.EventType.FINISHED, this.onAnimationFinished, this);
          }
        }
        onDisable() {
          if (this.animaiton) {
            this.animaiton.off(Animation.EventType.FINISHED, this.onAnimationFinished, this);
          }
        }
        init() {
          this.animaiton = this.getComponentInChildren(Animation);
          this.label = this.getComponentInChildren(Label);
        }
        onAnimationFinished() {
          this.onCompleted && this.onCompleted();
          this.onCompleted = null;
          this.animaiton.stop();
          UIManager.instance.hideToast();
        }
        onOpen(fromUI, ...args) {
          let msg = args[0];
          this.label.string = msg.content;
          this.animaiton.play();
        }
      }) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/token-account-layout.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './config.ts', './report-agent.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, _decorator, Component, director, Config, ConfigEvent, ReportAgent, MajorTokenReportEvent;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      _decorator = module._decorator;
      Component = module.Component;
      director = module.director;
    }, function (module) {
      Config = module.Config;
      ConfigEvent = module.ConfigEvent;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      MajorTokenReportEvent = module.MajorTokenReportEvent;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "d629etbdpZCxq0kmdBQkApp", "token-account-layout", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let TokeAccountLayout = exports('TokeAccountLayout', (_dec = ccclass('TokeAccountLayout'), _dec2 = property(Node), _dec(_class = (_class2 = class TokeAccountLayout extends Component {
        constructor(...args) {
          super(...args);
          // @property(Node)
          // public major: Node = null;
          _initializerDefineProperty(this, "minor", _descriptor, this);
        }
        start() {
          if (Config.FULL_MODE) {
            ReportAgent.reportMajorTokenEvent(MajorTokenReportEvent.SHOW_ACCOUNT);
          }
          // this.major.active = Config.FULL_MODE;
        }

        onEnable() {
          director.on(ConfigEvent.FLAG_CHANGED, this.updateDisplay, this);
          // this.major.on(Node.EventType.TOUCH_END, this.onMajorTokenItem, this);
          this.minor.on(Node.EventType.TOUCH_END, this.onMinorTokenItem, this);
        }
        onDisable() {
          director.off(ConfigEvent.FLAG_CHANGED, this.updateDisplay, this);
          // this.major.off(Node.EventType.TOUCH_END, this.onMajorTokenItem, this);
          this.minor.off(Node.EventType.TOUCH_END, this.onMinorTokenItem, this);
        }
        onMajorTokenItem() {
          // let isStoreShow = Config.FULL_MODE;
          // if (!isStoreShow) return;
          // AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          // BridgeUtil.vibrate(30, VibrationEffect.TICK);
          // UIManager.instance.open(UIID.MajorStoreView);
        }
        onMinorTokenItem() {
          // let isStoreShow = Config.FULL_MODE;
          // if (!isStoreShow) return;
          // AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          // BridgeUtil.vibrate(30, VibrationEffect.TICK);
          // UIManager.instance.open(UIID.MinorStoreView);
        }
        updateDisplay() {
          // this.major.active = Config.FULL_MODE;
        }
      }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "minor", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/token-account.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './reward-type-define.ts', './game-constants.ts', './game-data-manager.ts', './config.ts', './report-agent.ts', './mount-manager.ts', './mount-point.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Label, Enum, _decorator, Component, director, tween, Color, UIOpacity, ItemType, GameEvent, GameDataManager, Config, ReportAgent, MajorTokenReportEvent, MountManager, MountPoint;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Label = module.Label;
      Enum = module.Enum;
      _decorator = module._decorator;
      Component = module.Component;
      director = module.director;
      tween = module.tween;
      Color = module.Color;
      UIOpacity = module.UIOpacity;
    }, function (module) {
      ItemType = module.ItemType;
    }, function (module) {
      GameEvent = module.GameEvent;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      MajorTokenReportEvent = module.MajorTokenReportEvent;
    }, function (module) {
      MountManager = module.MountManager;
    }, function (module) {
      MountPoint = module.MountPoint;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "e1531ps5xxEWKL5P+cRVi+y", "token-account", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let TokenAccount = exports('TokenAccount', (_dec = ccclass('TokenAccount'), _dec2 = property(Label), _dec3 = property({
        type: Enum(ItemType)
      }), _dec4 = property(Label), _dec(_class = (_class2 = class TokenAccount extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "lblNum", _descriptor, this);
          _initializerDefineProperty(this, "itemType", _descriptor2, this);
          _initializerDefineProperty(this, "lblDelta", _descriptor3, this);
          this.changeNum = 0;
          this.accountNum = 0;
          this.isPlaying = false;
        }
        start() {
          this.lblDelta.node.active = false;
        }
        onEnable() {
          this.updateUI();
          director.on(GameEvent.TOKEN_ACCOUNT_CHANGE, this.onAccountChange, this);
        }
        onDisable() {
          director.off(GameEvent.TOKEN_ACCOUNT_CHANGE, this.onAccountChange, this);
        }
        setNum(val) {
          let cur = GameDataManager.instance.getCurrency();
          switch (this.itemType) {
            case ItemType.MajorToken:
              {
                this.lblNum.string = `${cur}${val.toFixed(2)}`;
              }
              break;
            case ItemType.MinorToken:
            case ItemType.Fragment:
              {
                this.lblNum.string = `${val.toFixed(0)}`;
              }
              break;
          }
        }
        rollTo(targetValue, duration = 1) {
          let currentValue = parseFloat(this.lblNum.string.replace(/[^\d.-]/g, '')) || 0; // 获取当前值
          let cur = GameDataManager.instance.getCurrency(); // 获取货币符号

          let lblNum = this.lblNum;
          tween({
            value: currentValue
          }).to(duration, {
            value: targetValue
          }, {
            onUpdate: tweenObj => {
              let value = this.itemType == ItemType.MajorToken ? `${cur}${tweenObj.value.toFixed(2)}` : `${Math.round(tweenObj.value)}`;
              lblNum.string = value;
            }
          }).start();
        }
        playChangeAnim(val) {
          if (val === 0) {
            return;
          }
          let symbol = val > 0 ? '+' : '';
          let currency = MountManager.instance.notify(MountPoint.NativeNotifyCurrency, null);
          this.lblDelta.node.active = true;
          this.lblDelta.string = this.itemType === ItemType.MajorToken ? `${symbol}${currency}${val.toFixed(2)}` : `${symbol}${val.toFixed(0)}`;
          let color = val > 0 ? "00FF47" : "FF0000";
          Color.fromHEX(this.lblDelta.color, color);
          this.lblDelta.updateRenderData(true);
          let comp = this.lblDelta.getComponent(UIOpacity);
          tween(comp).stop();
          let dur = 1;
          comp.opacity = 255;
          tween(comp).to(dur, {
            opacity: 0
          }, {
            easing: 'sineOut'
          }).call(() => {
            this.lblDelta.node.active = false;
          }).start();
        }
        onAccountChange(...params) {
          let data = params[0];
          if (data.type != this.itemType) {
            return;
          }
          this.changeNum += data.change;
          this.accountNum = data.account;
          if (!this.isPlaying) {
            this.isPlaying = true;
            let dur = 1;
            this.scheduleOnce(() => {
              this.rollTo(this.accountNum, dur);
              this.playChangeAnim(this.changeNum);
              this.changeNum = 0;
              this.accountNum = 0;
              this.isPlaying = false;
            }, dur);
          }
        }
        updateUI() {
          let isStoreShow = Config.FULL_MODE;
          if (this.itemType == ItemType.MajorToken && !isStoreShow) {
            this.node.active = false;
            if (this.itemType === ItemType.MajorToken && this.node.active) {
              ReportAgent.reportMajorTokenEvent(MajorTokenReportEvent.SHOW_ACCOUNT);
            }
            return;
          }
          let gdMgr = GameDataManager.instance;
          switch (this.itemType) {
            case ItemType.MajorToken:
              {
                this.setNum(gdMgr.getMajorToken());
              }
              break;
            case ItemType.MinorToken:
              {
                this.setNum(gdMgr.getMinorToken());
              }
              break;
            case ItemType.Fragment:
              {
                this.setNum(gdMgr.getFragment());
              }
              break;
          }
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "lblNum", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "itemType", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return ItemType.MajorToken;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "lblDelta", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/tool-agent.ts", ['cc', './card.ts', './card-constants.ts', './layout-tableau.ts', './log-util.ts'], function (exports) {
  var cclegacy, Card, CardPoint, LayoutTableau, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      Card = module.Card;
    }, function (module) {
      CardPoint = module.CardPoint;
    }, function (module) {
      LayoutTableau = module.LayoutTableau;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      cclegacy._RF.push({}, "db9d7IGscZJ3pVPv73hFJpi", "tool-agent", undefined);
      class GameDataCopy {
        constructor() {
          this.mainLayouts = [];
          this.foundationSlots = [];
          this.stock = [];
        }
      }
      class ToolAgent {
        static checkIfGameFailed(gameDesk) {
          if (this.hasStepFromStock(gameDesk)) {
            return false;
          }

          // if (this.hasStepFromFoundation(gameDesk)) {
          //     return false;
          // }

          if (this.hasStepFromTableau(gameDesk)) {
            return false;
          }
          return true;
        }
        static getCopySet(gameDesk) {
          const copySet = new GameDataCopy();
          for (let i = 0; i < gameDesk.layoutMain.children.length; i++) {
            const layout = gameDesk.layoutMain.children[i];
            const cardNodes = layout.getComponent(LayoutTableau).getAllCards();
            const cardDataArray = cardNodes.map(cardNode => cardNode.getComponent(Card).cardData);
            copySet.mainLayouts.push(cardDataArray);
          }
          for (let i = 0; i < gameDesk.layoutFoundation.children.length; i++) {
            const slot = gameDesk.layoutFoundation.children[i];
            const cardNodes = slot.children;
            const cardDataArray = cardNodes.map(cardNode => cardNode.getComponent(Card).cardData);
            copySet.foundationSlots.push(cardDataArray);
          }
          copySet.stock = gameDesk.flipCtrl.getAllCards().map(cardNode => cardNode.getComponent(Card).cardData);
          return copySet;
        }
        static getAllUncoveredDats(gameDesk) {
          const result = [];
          for (let i = 0; i < gameDesk.layoutMain.children.length; i++) {
            const layout = gameDesk.layoutMain.children[i];
            const cardNodes = layout.getComponent(LayoutTableau).getAllCards();
            const cardDataArray = cardNodes.map(cardNode => cardNode.getComponent(Card).cardData);
            result.push(...cardDataArray);
          }
          for (let i = 0; i < gameDesk.layoutFoundation.children.length; i++) {
            const slot = gameDesk.layoutFoundation.children[i];
            const cardNodes = slot.children;
            const cardDataArray = cardNodes.map(cardNode => cardNode.getComponent(Card).cardData);
            result.push(...cardDataArray);
          }
          const stock = gameDesk.flipCtrl.getAllCards().map(cardNode => cardNode.getComponent(Card).cardData);
          result.push(...stock);
          return result;
        }
        static hasStepFromStock(gameDesk) {
          const stock = gameDesk.flipCtrl.getAllCards();
          for (let i = 0; i < stock.length; i++) {
            const cardNode = stock[i];
            const matchedSlot = gameDesk.getMatchSlotInFoundations(cardNode);
            if (!!matchedSlot) {
              return true;
            }
            const matchedLayout = gameDesk.getMatchedLayoutInTableau(cardNode);
            if (!!matchedLayout) {
              return true;
            }
          }
          return false;
        }
        static hasStepFromFoundation(gameDesk) {
          for (let i = 0; i < gameDesk.layoutFoundation.children.length; i++) {
            const slot = gameDesk.layoutFoundation.children[i];
            const cardNodes = slot.children;
            if (cardNodes.length == 0) {
              continue;
            }
            const cardNode = cardNodes[cardNodes.length - 1];
            const matchedLayout = gameDesk.getMatchedLayoutInTableau(cardNode);
            if (!!matchedLayout) {
              return true;
            }
          }
          return false;
        }
        static hasStepFromTableau(gameDesk) {
          const allUnCoveredDatas = this.getAllUncoveredDats(gameDesk);
          for (let i = 0; i < gameDesk.layoutMain.children.length; i++) {
            const layout = gameDesk.layoutMain.children[i];
            const cardNodes = layout.getComponent(LayoutTableau).getAllCards();
            if (cardNodes.length == 0) {
              continue;
            }
            const uncoveredCards = [];
            for (let j = 0; j < cardNodes.length; j++) {
              const cardNode = cardNodes[j];
              if (cardNode.getComponent(Card).isCovered) ;else {
                uncoveredCards.push(cardNode);
              }
            }
            if (uncoveredCards.length == 1) {
              // check foundation
              const matchedSlot = gameDesk.getMatchSlotInFoundations(uncoveredCards[0]);
              if (!!matchedSlot) {
                LogUtil.log('isNoStepFromTableau - uncovered card can move to foundation: ', uncoveredCards[0].getComponent(Card).cardData.toString());
                return true;
              }
            }
            const firstUncoveredCard = uncoveredCards[0];
            const firstUncoveredCardData = firstUncoveredCard.getComponent(Card).cardData;
            const matchedLayout = gameDesk.getMatchedLayoutInTableau(firstUncoveredCard);
            if (!!matchedLayout) {
              // 形成空列或者翻牌
              return true;
            } else {
              // 如果没有找到，则需要判断desk中已经翻开的牌是否可以形成支撑序列
              for (let k = 0; k < allUnCoveredDatas.length; k++) {
                const cardData = allUnCoveredDatas[k];
                if (cardData.point == CardPoint.King) {
                  continue;
                }
                if (cardData.matchGreaterThan(firstUncoveredCardData)) {
                  return true;
                }
              }
            }
          }
          return false;
        }
      }
      exports('ToolAgent', ToolAgent);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/tool-auto-check-end.ts", ['cc', './card.ts', './card-constants.ts', './game-constants.ts', './layout-tableau.ts', './log-util.ts'], function (exports) {
  var cclegacy, director, Card, CardPoint, GameEvent, ParamShowBtn, GameConstants, LayoutTableau, LogUtil;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
    }, function (module) {
      Card = module.Card;
    }, function (module) {
      CardPoint = module.CardPoint;
    }, function (module) {
      GameEvent = module.GameEvent;
      ParamShowBtn = module.ParamShowBtn;
      GameConstants = module.GameConstants;
    }, function (module) {
      LayoutTableau = module.LayoutTableau;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      cclegacy._RF.push({}, "03f93n3UgdANIPK2gD088Wv", "tool-auto-check-end", undefined);
      class ToolAutoCheckEnd {
        constructor(desk) {
          this._desk = null;
          this._timeout = 0;
          this._desk = desk;
        }
        postDelayCheck() {
          if (!this._desk.flipCtrl.isTurnOver) {
            LogUtil.log('ToolAutoCheckEnd - postDelayCheck - flipCtrl is not turn over');
            return;
          }
          if (this._timeout > 0) {
            clearTimeout(this._timeout);
          }
          this._timeout = setTimeout(() => {
            this._timeout = 0;
            if (this.checkGameEnd()) {
              director.emit(GameEvent.SHOW_BTN, ParamShowBtn.SHOW_END);
            }
          }, GameConstants.CheckGameEndDuration);
        }
        cancelCheck() {
          director.emit(GameEvent.SHOW_BTN, ParamShowBtn.HIDE);
          if (this._timeout > 0) {
            clearTimeout(this._timeout);
            this._timeout = 0;
          }
        }
        checkGameEnd() {
          if (this.hasStepFromStock()) {
            return false;
          }
          if (this.hasStepFromTableau()) {
            return false;
          }
          return true;
        }
        hasStepFromStock() {
          const stock = this._desk.flipCtrl.getAllCards();
          for (let i = 0; i < stock.length; i++) {
            const cardNode = stock[i];
            const matchedSlot = this._desk.getMatchSlotInFoundations(cardNode);
            if (!!matchedSlot) {
              return true;
            }
            const matchedLayout = this._desk.getMatchedLayoutInTableau(cardNode);
            if (!!matchedLayout) {
              return true;
            }
          }
          return false;
        }
        hasStepFromTableau() {
          const allUnCoveredDatas = this.getAllUncoveredDatas();
          for (let i = 0; i < this._desk.layoutMain.children.length; i++) {
            const layout = this._desk.layoutMain.children[i];
            const cardNodes = layout.getComponent(LayoutTableau).getAllCards();
            if (cardNodes.length == 0) {
              continue;
            }
            const uncoveredCards = [];
            for (let j = 0; j < cardNodes.length; j++) {
              const cardNode = cardNodes[j];
              if (cardNode.getComponent(Card).isCovered) ;else {
                uncoveredCards.push(cardNode);
              }
            }
            if (uncoveredCards.length == 1) {
              // check foundation
              const matchedSlot = this._desk.getMatchSlotInFoundations(uncoveredCards[0]);
              if (!!matchedSlot) {
                LogUtil.log('isNoStepFromTableau - uncovered card can move to foundation: ', uncoveredCards[0].getComponent(Card).cardData.toString());
                return true;
              }
            }
            const firstUncoveredCard = uncoveredCards[0];
            const firstUncoveredCardData = firstUncoveredCard.getComponent(Card).cardData;
            const matchedLayout = this._desk.getMatchedLayoutInTableau(firstUncoveredCard);
            if (!!matchedLayout) {
              // 形成空列或者翻牌
              return true;
            } else {
              // 如果没有找到，则需要判断desk中已经翻开的牌是否可以形成支撑序列
              for (let k = 0; k < allUnCoveredDatas.length; k++) {
                const cardData = allUnCoveredDatas[k];
                if (cardData.point == CardPoint.King) {
                  continue;
                }
                if (cardData.matchGreaterThan(firstUncoveredCardData)) {
                  return true;
                }
              }
            }
          }
          return false;
        }
        getAllUncoveredDatas() {
          const result = [];
          for (let i = 0; i < this._desk.layoutMain.children.length; i++) {
            const layout = this._desk.layoutMain.children[i];
            const cardNodes = layout.getComponent(LayoutTableau).getAllCards();
            const cardDataArray = cardNodes.map(cardNode => cardNode.getComponent(Card).cardData);
            result.push(...cardDataArray);
          }
          for (let i = 0; i < this._desk.layoutFoundation.children.length; i++) {
            const slot = this._desk.layoutFoundation.children[i];
            const cardNodes = slot.children;
            const cardDataArray = cardNodes.map(cardNode => cardNode.getComponent(Card).cardData);
            result.push(...cardDataArray);
          }
          const stock = this._desk.flipCtrl.getAllCards().map(cardNode => cardNode.getComponent(Card).cardData);
          result.push(...stock);
          return result;
        }
      }
      exports('ToolAutoCheckEnd', ToolAutoCheckEnd);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/tool-auto-prompt.ts", ['cc', './layout-tableau.ts', './game-constants.ts', './card.ts', './step-checker.ts', './log-util.ts', './flip-ctrl.ts'], function (exports) {
  var cclegacy, director, UITransform, v3, UIOpacity, tween, LayoutTableau, GameState, GameEvent, ParamShowBtn, GameConstants, Card, CardArea, StepHunter, LogUtil, FlipSlot;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
      UITransform = module.UITransform;
      v3 = module.v3;
      UIOpacity = module.UIOpacity;
      tween = module.tween;
    }, function (module) {
      LayoutTableau = module.LayoutTableau;
    }, function (module) {
      GameState = module.GameState;
      GameEvent = module.GameEvent;
      ParamShowBtn = module.ParamShowBtn;
      GameConstants = module.GameConstants;
    }, function (module) {
      Card = module.Card;
      CardArea = module.CardArea;
    }, function (module) {
      StepHunter = module.StepHunter;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      FlipSlot = module.FlipSlot;
    }],
    execute: function () {
      cclegacy._RF.push({}, "66865eg/fpIcoPyld7q15vs", "tool-auto-prompt", undefined);
      class ToolAutoPrompt {
        constructor(desk) {
          this._desk = null;
          this._isPrompting = false;
          this._timeout = 0;
          this._desk = desk;
        }
        excute() {
          if (this._desk.state !== GameState.PLAYING) {
            return;
          }
          if (this._desk.isStageWin()) {
            LogUtil.log('ToolAutoPrompt - excute - game win');
            this._desk.setGameState(GameState.WIN);
            this._desk.doWin();
            return;
          }
          const stepHunter = new StepHunter(this._desk);
          const cardNode = stepHunter.findValidStepOnNode();
          this.hidePromptNode();
          if (cardNode) {
            LogUtil.log('ToolAutoPrompt - excute - cardNode', cardNode);
            director.emit(GameEvent.SHOW_BTN, ParamShowBtn.HIDE);
            switch (cardNode.getComponent(Card).area) {
              case CardArea.TABLEAU:
                this.promptTableueNode(cardNode.getComponent(Card).tag);
                break;
              case CardArea.STOCK_COVERD:
                this.promptPoolNode();
                break;
              case CardArea.STOCK_FLIPED:
                const tag = cardNode.getComponent(Card).tag;
                if (tag == FlipSlot.FLIP_3) {
                  this.promptFlip3Node();
                } else {
                  this.promptPoolNode();
                }
                break;
            }
          } else {
            LogUtil.log('ToolAutoPrompt - excute - no cardNode');
            this.hidePromptNode();
            if (this._desk.flipCtrl.isTurnOver) {
              director.emit(GameEvent.SHOW_BTN, ParamShowBtn.SHOW_END);
            }
          }
        }

        // private excute() {
        //     const cardNode = this.pickMoveableCardInTableau();
        //     if (cardNode) {
        //         this.promptCardInTableau(cardNode);
        //         return;
        //     }

        //     const cardNodeInStock = this.pickMoveableCardInStock();
        //     if (cardNodeInStock) {
        //         this.promptFlipNode(cardNodeInStock);
        //         return;
        //     }

        //     this.promptPoolNode();
        // }

        postDelayCheck() {
          this.hidePromptNode();
          if (this._timeout > 0) {
            clearTimeout(this._timeout);
          }
          this._timeout = setTimeout(() => {
            this._timeout = 0;
            this.excute();
          }, GameConstants.IdlePromptDelayCheckDuration);
        }
        cancelCheck() {
          if (this._timeout > 0) {
            clearTimeout(this._timeout);
            this._timeout = 0;
          }
          this.hidePromptNode();
        }
        promptTableueNode(layoutName) {
          const layoutNode = this._desk.layoutMain.getChildByName(layoutName);
          if (!layoutNode) {
            return;
          }
          const lastCard = layoutNode.getComponent(LayoutTableau).getLastCard();
          if (!lastCard) {
            return;
          }
          const pos = lastCard.getComponent(UITransform).convertToWorldSpaceAR(v3(0, 0, 0));
          const posInDesk = this._desk.node.getComponent(UITransform).convertToNodeSpaceAR(pos);
          this.showPromptNode(posInDesk);
        }
        promptPoolNode() {
          const pos = this._desk.flipCtrl.slotPoolNode.getComponent(UITransform).convertToWorldSpaceAR(v3(0, 0, 0));
          const posInDesk = this._desk.node.getComponent(UITransform).convertToNodeSpaceAR(pos);
          this.showPromptNode(posInDesk);
        }
        promptFlip3Node() {
          const pos = this._desk.flipCtrl.slotFlipNode.children[2].getComponent(UITransform).convertToWorldSpaceAR(v3(0, 0, 0));
          const posInDesk = this._desk.node.getComponent(UITransform).convertToNodeSpaceAR(pos);
          this.showPromptNode(posInDesk);
        }
        showPromptNode(pos) {
          // LogUtil.log('showPromptNode', pos);
          this._desk.promptNode.setPosition(pos);
          this._desk.promptNode.active = true;
          const uiOpacity = this._desk.promptNode.getComponent(UIOpacity);
          if (uiOpacity) {
            uiOpacity.opacity = 0;
            this._isPrompting = true;
            tween(uiOpacity).to(0.8, {
              opacity: 255
            }).start(); // fade in
          }
        }

        hidePromptNode() {
          this._desk.promptNode.active = false;
          this._isPrompting = false;
        }
        pickMoveableCardInTableau() {
          for (const layoutNode of this._desk.layoutMain.children) {
            const layout = layoutNode.getComponent(LayoutTableau);
            if (layout) {
              const cardNode = layout.getLastCard();
              if (cardNode) {
                if (this.checkNodeCanMoveToFoundation(cardNode)) {
                  return cardNode;
                }
                if (this.checkNodeCanMoveToTableau(cardNode)) {
                  return cardNode;
                }
              }
            }
          }
          return null;
        }
        pickMoveableCardInStock() {
          const flipNode = this._desk.flipCtrl.slotFlipNode.children[2];
          if (flipNode.children.length == 0) {
            return null;
          }
          const cardNode = flipNode.children[0];
          if (cardNode) {
            if (this.checkNodeCanMoveToFoundation(cardNode)) {
              return cardNode;
            }
            if (this.checkNodeCanMoveToTableau(cardNode)) {
              return cardNode;
            }
          }
          return null;
        }
        checkNodeCanMoveToFoundation(cardNode) {
          for (const slot of this._desk.layoutFoundation.children) {
            if (this._desk.canMatchInFoundation(cardNode, slot)) {
              return true;
            }
          }
          return false;
        }
        checkNodeCanMoveToTableau(cardNode) {
          for (const layoutNode of this._desk.layoutMain.children) {
            const layout = layoutNode.getComponent(LayoutTableau);
            if (layout) {
              if (layout.canMatch(cardNode)) {
                return true;
              }
            }
          }
          return false;
        }
      }
      exports('ToolAutoPrompt', ToolAutoPrompt);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/tool-auto-solve.ts", ['cc', './card.ts', './game-constants.ts', './layout-tableau.ts', './tool-magic.ts'], function (exports) {
  var cclegacy, director, Card, GameConstants, GameState, GameEvent, ParamShowBtn, LayoutTableau, ToolMagic;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
    }, function (module) {
      Card = module.Card;
    }, function (module) {
      GameConstants = module.GameConstants;
      GameState = module.GameState;
      GameEvent = module.GameEvent;
      ParamShowBtn = module.ParamShowBtn;
    }, function (module) {
      LayoutTableau = module.LayoutTableau;
    }, function (module) {
      ToolMagic = module.ToolMagic;
    }],
    execute: function () {
      cclegacy._RF.push({}, "4a181mdAVpIvJh4oBu+WbWk", "tool-auto-solve", undefined);
      class ToolAutoSolve {
        constructor(desk) {
          this._desk = null;
          this._timeout = 0;
          this._desk = desk;
        }
        excute() {
          return new Promise(async (resolve, reject) => {
            while (true) {
              const toolMagic = new ToolMagic(GameConstants.MagicToolPickCount, this._desk);
              const result = await toolMagic.execute(true);
              if (!result) {
                break;
              }
            }
            resolve();
          });
        }
        postDelayCheck() {
          if (this._timeout > 0) {
            clearTimeout(this._timeout);
          }
          this._timeout = setTimeout(() => {
            this._timeout = 0;
            if (this._desk.isStageWin()) {
              this._desk.setGameState(GameState.WIN);
              this._desk.doWin();
              return;
            }
            if (this.checkCanAutoSolve()) {
              this._desk.cancelAutoTools();
              director.emit(GameEvent.SHOW_BTN, ParamShowBtn.SHOW_AUTO);
            }
          }, GameConstants.AutoSolveDelayCheckDuration);
        }
        cancelCheck() {
          director.emit(GameEvent.SHOW_BTN, ParamShowBtn.HIDE);
          if (this._timeout > 0) {
            clearTimeout(this._timeout);
            this._timeout = 0;
          }
        }
        checkCanAutoSolve() {
          for (let i = this._desk.layoutMain.children.length - 1; i >= 0; i--) {
            const layout = this._desk.layoutMain.children[i];
            const cardNodes = layout.getComponent(LayoutTableau).getAllCards();
            for (const cardNode of cardNodes) {
              if (cardNode.getComponent(Card).isCovered) {
                return false;
              }
            }
          }
          return true;
        }
      }
      exports('ToolAutoSolve', ToolAutoSolve);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/tool-magic.ts", ['cc', './card.ts', './card-constants.ts', './card-data.ts', './bezier-util.ts', './animation-canvas.ts', './game-constants.ts', './log-util.ts', './bridge-util.ts'], function (exports) {
  var cclegacy, director, tween, UIOpacity, UITransform, Vec3, Quat, Card, CardArea, CardPoint, CardSuit, CardData, BezierUtil, AnimationCanvas, GameConstants, LogUtil, BridgeUtil, VibrationEffect;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
      tween = module.tween;
      UIOpacity = module.UIOpacity;
      UITransform = module.UITransform;
      Vec3 = module.Vec3;
      Quat = module.Quat;
    }, function (module) {
      Card = module.Card;
      CardArea = module.CardArea;
    }, function (module) {
      CardPoint = module.CardPoint;
      CardSuit = module.CardSuit;
    }, function (module) {
      CardData = module.CardData;
    }, function (module) {
      BezierUtil = module.BezierUtil;
    }, function (module) {
      AnimationCanvas = module.AnimationCanvas;
    }, function (module) {
      GameConstants = module.GameConstants;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }],
    execute: function () {
      cclegacy._RF.push({}, "9b2b0BhCx5OmIxJG4dLx7xd", "tool-magic", undefined);
      class PickedData {
        constructor(slotName, cardData) {
          this.slotName = void 0;
          this.cardData = void 0;
          this.slotName = slotName;
          this.cardData = cardData;
        }
      }
      class ToolMagic {
        constructor(needCount, desk) {
          this._slotNames = ['slot_1', 'slot_2', 'slot_3', 'slot_4'];
          this._resultCardDatas = new Map();
          this._resultCardNodes = new Map();
          this._needCount = 2;
          this._desk = null;
          this._needCount = needCount;
          this._desk = desk;
        }
        get pickedCardDataLength() {
          // 遍历_resultCardDatas, 累加每个slot的cardData数量
          let count = 0;
          this._resultCardDatas.forEach((cardDataList, slotName) => {
            count += cardDataList.length;
          });
          return count;
        }
        execute(isDirectMove = false) {
          if (!this.pickCardDatas()) {
            LogUtil.log('pickCardDatas failed');
            return Promise.resolve(false);
          }
          if (!this.pickCardNodes()) {
            LogUtil.log('pickCardNodes failed');
            return Promise.resolve(false);
          }
          if (isDirectMove) {
            return this.directMove();
          }
          return this.magicMove();
        }
        addResult(slotName, cardData) {
          if (!this._resultCardDatas.has(slotName)) {
            this._resultCardDatas.set(slotName, []);
          }
          this._resultCardDatas.get(slotName).push(cardData);
        }
        getLastOneInResult(slotName) {
          if (!this._resultCardDatas.has(slotName)) {
            return null;
          }
          const cardDataList = this._resultCardDatas.get(slotName);
          if (cardDataList.length === 0) {
            return null;
          }
          return cardDataList[cardDataList.length - 1];
        }
        getLastOneInSlot(slotName) {
          const lastOne = this._desk.getLastCardInFoundationSlot(slotName);
          if (!lastOne) {
            return null;
          }
          return lastOne.getComponent(Card).cardData;
        }
        getNextCardDataOfSlot(slotName) {
          const lastOneInResult = this.getLastOneInResult(slotName);
          if (lastOneInResult) {
            if (lastOneInResult.point === CardPoint.King) {
              return null;
            }
            return new CardData(lastOneInResult.suit, lastOneInResult.point + 1);
          }
          const lastOneInSlot = this.getLastOneInSlot(slotName);
          if (!lastOneInSlot) {
            return new CardData(this.getFirstAvailableCardSuit(), CardPoint.Ace);
          }
          if (lastOneInSlot.point === CardPoint.King) {
            return null;
          }
          return new CardData(lastOneInSlot.suit, lastOneInSlot.point + 1);
        }
        getSuitsInUse() {
          const result = [];
          for (const slotName of this._slotNames) {
            const lastOne = this.getLastOneInResult(slotName);
            if (lastOne) {
              result.push(lastOne.suit);
            }
            const lastOneInSlot = this.getLastOneInSlot(slotName);
            if (lastOneInSlot) {
              result.push(lastOneInSlot.suit);
            }
          }
          return result;
        }
        getFirstAvailableCardSuit() {
          const suits = [CardSuit.Club, CardSuit.Diamond, CardSuit.Heart, CardSuit.Spade];
          const suitsInUse = this.getSuitsInUse();
          for (const suit of suits) {
            if (suitsInUse.indexOf(suit) == -1) {
              return suit;
            }
          }
        }
        pickCardDatas() {
          while (this.pickedCardDataLength < this._needCount) {
            const pickedDatas = [];
            for (const slotName of this._slotNames) {
              const nextCardData = this.getNextCardDataOfSlot(slotName);
              if (nextCardData) {
                pickedDatas.push(new PickedData(slotName, nextCardData));
              }
            }
            if (pickedDatas.length === 0) {
              break;
            }
            pickedDatas.sort((a, b) => {
              return a.cardData.point - b.cardData.point;
            });
            const pickData = pickedDatas[0];
            this.addResult(pickData.slotName, pickData.cardData);
            if (this.pickedCardDataLength == this._needCount) {
              break;
            }
          }
          return this._resultCardDatas.size != 0;
        }
        pickCardNodes() {
          if (this._resultCardDatas.size == 0) {
            return false;
          }
          const allCards = this._desk.getAllCardsInDesk();
          this._resultCardDatas.forEach((cardDataArray, slotName) => {
            const slot = this._desk.layoutFoundation.getChildByName(slotName);
            if (!slot) return;
            const nodeArray = [];
            for (const cardData of cardDataArray) {
              const cardNode = this.searchCardNode(cardData, allCards);
              if (cardNode) {
                nodeArray.push(cardNode);
              }
            }
            if (nodeArray.length > 0) {
              this._resultCardNodes.set(slotName, nodeArray);
            }
          });
          return this._resultCardNodes.size != 0;
        }
        searchCardNode(cardData, allCards = null) {
          if (!allCards) {
            allCards = this._desk.getAllCardsInDesk();
          }
          for (const card of allCards) {
            const cardComponent = card.getComponent(Card);
            if (cardComponent && cardComponent.cardData.equals(cardData)) {
              return card;
            }
          }
          return null;
        }
        directMove() {
          const promises = [];
          const needUpdateLayoutName = [];

          // un cover the card 
          this._resultCardNodes.forEach((nodes, slotName) => {
            nodes.forEach(node => {
              const card = node.getComponent(Card);
              if (card.isCovered) {
                // card.setCovered(false);
                this._desk.unCoverNode(node);
              }
            });
          });
          let indexInStock = 0;
          this._resultCardNodes.forEach(async (nodes, slotName) => {
            if (nodes.length == 0) {
              return;
            }
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              const card = node.getComponent(Card);
              const originArea = card.area;
              const originName = card.tag;
              if (originArea == CardArea.TABLEAU) {
                this._desk.removeFromTableau([node]);
                promises.push(this._desk.addToFoundation(this._desk.getSlotInFundation(slotName), [node], 0, GameConstants.AutoSolveMoveSpeed));
                if (needUpdateLayoutName.indexOf(originName) === -1) {
                  needUpdateLayoutName.push(originName);
                }
              } else if (originArea == CardArea.STOCK_COVERD) {
                this._desk.removeFromStockFlip(node);
                const promise = this._desk.addToFoundation(this._desk.getSlotInFundation(slotName), [node], indexInStock * 0.1, GameConstants.AutoSolveMoveSpeed);
                indexInStock += 1;
                promises.push(promise);
              } else if (originArea == CardArea.STOCK_FLIPED) {
                this._desk.removeFromStockFlip(node);
                const promise = this._desk.addToFoundation(this._desk.getSlotInFundation(slotName), [node], 0, GameConstants.AutoSolveMoveSpeed);
                promises.push(promise);
              }
            }
          });
          for (const layoutName of needUpdateLayoutName) {
            promises.push(this._desk.updateCardLoctionInLayout(layoutName));
          }
          LogUtil.log('directMove ing', promises.length);
          if (promises.length == 0) {
            return Promise.resolve(false);
          }
          return new Promise((resolve, reject) => {
            Promise.all(promises).then(() => {
              LogUtil.log('directMove done');
              this._desk.enableTools();
              resolve(true);
            });
          });
        }
        async magicMove() {
          const uiCanvas = director.getScene().getChildByPath('Canvas/uiCanvas');
          const stickNode = uiCanvas.getChildByName('stick');
          const fromTag2Nodes = new Map();
          this._resultCardNodes.forEach((nodes, slotName) => {
            nodes.forEach(node => {
              const fromTag = node.getComponent(Card).tag;
              if (!fromTag2Nodes.has(fromTag)) {
                fromTag2Nodes.set(fromTag, []);
              }
              fromTag2Nodes.get(fromTag).push(node);
            });
          });
          let i = 0;
          const movePromises = [];
          for (const fromTag of fromTag2Nodes.keys()) {
            const nodes = fromTag2Nodes.get(fromTag);
            const firstNode = nodes[0];
            if (i == 0) {
              await this.jumpStick(uiCanvas, stickNode, firstNode);
            } else {
              await this.moveStick(uiCanvas, stickNode, firstNode);
            }
            await this.nodStick(stickNode);
            nodes.forEach(node => {
              movePromises.push(this.moveCardToCenter(node, i, this.pickedCardDataLength));
              i++;
            });
          }
          LogUtil.log('magicMove done', movePromises.length);

          // fadeout
          tween(stickNode.getComponent(UIOpacity)).to(0.3, {
            opacity: 0
          }).start();
          await Promise.all(movePromises);
          await new Promise(resolve => {
            setTimeout(async () => {
              await this.flipAnimCards();
              resolve();
            }, 300);
          });
          await new Promise(resolve => {
            setTimeout(async () => {
              this.moveCardToFoundation().then(() => {
                resolve();
              });
            }, 300);
          });
          LogUtil.log('magicMove done 333');
          return Promise.resolve(true);
        }
        flipAnimCards() {
          const promises = [];
          this._resultCardNodes.forEach(async (nodes, slotName) => {
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              const animCanvas = this._desk.node.getChildByName('animation_canvas');
              const animCard = animCanvas.getComponent(AnimationCanvas).getExistAnimCard(node);
              if (animCard) {
                if (animCard.getComponent(Card).isCovered) {
                  promises.push(this._desk.unCoverNode(animCard));
                }
              }
            }
          });
          if (promises.length == 0) {
            return Promise.resolve();
          }
          return new Promise((resolve, reject) => {
            Promise.all(promises).then(() => {
              resolve();
            });
          });
        }
        moveCardToFoundation() {
          const promises = [];
          const needUpdateLayoutName = [];
          this._resultCardNodes.forEach(async (nodes, slotName) => {
            if (nodes.length == 0) {
              return;
            }
            for (let i = 0; i < nodes.length; i++) {
              const node = nodes[i];
              const card = node.getComponent(Card);
              card.setCovered(false);
              const originArea = card.area;
              const originName = card.tag;
              if (originArea == CardArea.TABLEAU) {
                this._desk.removeFromTableau([node]);
                promises.push(this._desk.addToFoundation(this._desk.getSlotInFundation(slotName), [node]));
                if (needUpdateLayoutName.indexOf(originName) === -1) {
                  needUpdateLayoutName.push(originName);
                }
              } else if (originArea == CardArea.STOCK_COVERD) {
                this._desk.removeFromStockFlip(node);
                const promise = this._desk.addToFoundation(this._desk.getSlotInFundation(slotName), [node]);
                promises.push(promise);
              } else if (originArea == CardArea.STOCK_FLIPED) {
                this._desk.removeFromStockFlip(node);
                const promise = this._desk.addToFoundation(this._desk.getSlotInFundation(slotName), [node]);
                promises.push(promise);
              }
            }
          });
          for (const layoutName of needUpdateLayoutName) {
            promises.push(this._desk.updateCardLoctionInLayout(layoutName));
          }
          if (promises.length == 0) {
            return Promise.resolve(false);
          }
          return new Promise((resolve, reject) => {
            Promise.all(promises).then(() => {
              LogUtil.log('magicMove done');
              BridgeUtil.vibrate(80, VibrationEffect.CLICK);
              this._desk.clearCurrentStep();
              this._desk.enableTools();
              resolve(true);
            });
          });
        }
        moveCardToCenter(cardNode, index, total) {
          const spacing = 320;
          const coordinates = [];
          for (let i = 0; i < total; i++) {
            const x = (i - (total - 1) / 2) * spacing;
            coordinates.push(x);
          }
          const animCanvas = this._desk.node.getChildByName('animation_canvas');
          const animCard = animCanvas.getComponent(AnimationCanvas).getCloneAnimCard(cardNode);
          let originPos = cardNode.getComponent(UITransform).convertToWorldSpaceAR(new Vec3(0, 0, 0));
          originPos = animCanvas.getComponent(UITransform).convertToNodeSpaceAR(originPos);
          const targetPos = new Vec3(coordinates[index], 0, 0);
          const controlPos = new Vec3(0, 1000, 0);
          const speed = 1800;
          cardNode.active = false;
          animCard.position = originPos;
          return BezierUtil.moveNodeAlongBezier(animCard, originPos, controlPos, targetPos, speed, new Vec3(1.8, 1.8, 1.8), Quat.fromEuler(new Quat(), 0, 0, 0));
        }
        jumpStick(uiCanvas, stickNode, targetNode) {
          let homeView = director.getScene().getChildByPath('Canvas/uiLayer/HomeView');
          let stickInBottomBar = homeView.getChildByPath('Content/BarBottom/Layout/BtnMagic');
          let originPos = stickInBottomBar.getComponent(UITransform).convertToWorldSpaceAR(new Vec3(0, 0, 0));
          originPos = uiCanvas.getComponent(UITransform).convertToNodeSpaceAR(originPos);
          const originSize = stickInBottomBar.getComponent(UITransform).contentSize;
          stickNode.active = true;
          stickNode.setScale(1, 1, 1);
          stickNode.position = originPos;
          stickNode.setRotation(Quat.fromEuler(new Quat(), 0, 0, 0));
          stickNode.getComponent(UITransform).setContentSize(originSize);
          stickNode.getComponent(UIOpacity).opacity = 255;
          // stickNode.getComponent(UITransform).setAnchorPoint(new Vec2(0.5, 0.5));

          let targetPos = targetNode.getComponent(UITransform).convertToWorldSpaceAR(new Vec3(-260, 20, 0));
          targetPos = uiCanvas.getComponent(UITransform).convertToNodeSpaceAR(targetPos);
          // LogUtil.log('targetPos', targetPos);
          const winWidth = this._desk.node.getComponent(UITransform).width;
          const controlPos = new Vec3(-winWidth * 0.8, targetPos.y, 0);
          // LogUtil.log('controlPos', controlPos);
          const speed = 1800;
          return new Promise(resolve => {
            BezierUtil.moveNodeAlongBezier(stickNode, originPos, controlPos, targetPos, speed, new Vec3(2, 2, 2), Quat.fromEuler(new Quat(), 0, 0, 15)).then(() => {
              setTimeout(() => {
                resolve();
              }, 100);
            });
          });
        }
        moveStick(uiCanvas, stickNode, targetNode) {
          const originPos = stickNode.position;
          let targetPos = targetNode.getComponent(UITransform).convertToWorldSpaceAR(new Vec3(-260, 20, 0));
          targetPos = uiCanvas.getComponent(UITransform).convertToNodeSpaceAR(targetPos);
          const speed = 1200;
          const distance = Vec3.distance(originPos, targetPos);
          // return BezierUtil.moveNodeAlongBezier(stickNode, originPos, controlPos, targetPos, speed, new Vec3(2, 2, 2), Quat.fromEuler(new Quat(), 0, 0, 15));
          return new Promise(resolve => {
            tween(stickNode).to(distance / speed, {
              position: targetPos
            }, {
              easing: 'linear'
            }).delay(0.1).call(() => {
              resolve();
            }).start();
          });
        }
        nodStick(stickNode) {
          return new Promise(resolve => {
            // 初始旋转角度
            const initialRotation = stickNode.rotation.clone();
            const uiTransform = stickNode.getComponent(UITransform);
            // uiTransform.anchorPoint = new Vec2(0, 0);
            // 目标旋转角度（右边向下点一下）
            const targetRotation = Quat.fromEuler(new Quat(), 0, 0, -15); // 右旋 15 度
            const endRotation = Quat.fromEuler(new Quat(), 0, 0, 15);
            // 使用 tween 实现摇动效果
            tween(stickNode).to(0.2, {
              rotation: targetRotation
            }, {
              easing: 'linear'
            }) // 向右下旋转
            .to(0.2, {
              rotation: endRotation
            }, {
              easing: 'linear'
            }) // 恢复初始角度
            .call(() => {
              LogUtil.log("nodStick completed");
              // uiTransform.anchorPoint = new Vec2(0.5, 0.5);
              resolve();
            }).start();
          });
        }
      }
      exports('ToolMagic', ToolMagic);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/tool-undo.ts", ['cc', './card.ts', './game-step.ts', './log-util.ts', './layout-tableau.ts', './game-constants.ts'], function (exports) {
  var cclegacy, director, CardArea, Card, GameStep, LogUtil, LayoutTableau, GameEvent;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
    }, function (module) {
      CardArea = module.CardArea;
      Card = module.Card;
    }, function (module) {
      GameStep = module.GameStep;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      LayoutTableau = module.LayoutTableau;
    }, function (module) {
      GameEvent = module.GameEvent;
    }],
    execute: function () {
      cclegacy._RF.push({}, "2de73nikfxDAbKh8/zelr/z", "tool-undo", undefined);
      class ToolUndo {
        constructor(desk) {
          this._desk = null;
          this._lastStep = null;
          this._desk = desk;
        }
        excute() {
          if (!!this._lastStep && this._lastStep.isVaild()) {
            const fromArea = this._lastStep.fromArea;
            const fromName = this._lastStep.fromName;
            const toArea = this._lastStep.toArea;
            const toName = this._lastStep.toName;
            const count = this._lastStep.count;
            const uncoverd = this._lastStep.uncoverd;
            const cardNodes = this.getCardsInArea(toArea, toName, count);
            if (cardNodes.length == 0) {
              LogUtil.log('useToolUndo - no card to undo');
              return Promise.resolve(false);
            }
            var promise = null;
            if (fromArea == CardArea.STOCK_FLIPED) {
              this._desk.flipCtrl.flipBack(false, 1, fromName);
              promise = this._desk.addToFlipCtrl(cardNodes[0], fromName);
            } else if (fromArea == CardArea.STOCK_COVERD) {
              promise = this._desk.flipCtrl.flipBack(true, count, fromName);
            } else if (fromArea == CardArea.TABLEAU) {
              if (uncoverd) {
                const lastCard = this._desk.getLayoutInTableau(fromName).getComponent(LayoutTableau).getLastCard();
                if (lastCard) {
                  lastCard.getComponent(Card).flip(true);
                  console.log('lastCard', lastCard.getComponent(Card).isCovered);
                }
              }
              promise = this._desk.moveToTableau(this._desk.getLayoutInTableau(fromName), cardNodes);
            } else if (fromArea == CardArea.FOUNDATION) {
              promise = this._desk.addToFoundation(this._desk.getSlotInFundation(fromName), cardNodes);
            }
            if (toArea === CardArea.FOUNDATION) {
              director.emit(GameEvent.COLLECT_CARD, -1);
            }
            this._lastStep = null;
            if (!!promise) {
              return promise.then(() => true).catch(() => false);
            }
          }
          return Promise.resolve(false);
        }
        saveStep(fromArea, fromName, toArea, toName, count, uncoverd) {
          this._lastStep = new GameStep(fromArea, fromName, toArea, toName, count, uncoverd);
        }
        clearStep() {
          this._lastStep = null;
        }
        getCardsInArea(area, name, count) {
          var nodes = [];
          var container = null;
          if (area == CardArea.TABLEAU) {
            const layout = this._desk.layoutMain.getChildByName(name);
            if (!layout) {
              return nodes;
            }
            container = layout.getChildByName('container');
          } else if (area == CardArea.FOUNDATION) {
            container = this._desk.layoutFoundation.getChildByName(name);
          } else if (area == CardArea.STOCK_FLIPED) {
            for (let i = 0; i < 3; i++) {
              let node = this._desk.flipCtrl.getInteractiveFlipNode(`flip_${i + 1}`);
              nodes.push(node);
            }
          }
          if (container && container.children.length >= count) {
            nodes = container.children.slice(-count);
          }
          return nodes;
        }
      }
      exports('ToolUndo', ToolUndo);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/TTINOQH.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "ff444/1tBpAErQewCNCcPTO", "TTINOQH", undefined);
      /**
       * 单例模式
       */
      class TTINOQH {
        constructor() {}
        static ALNZVIWVOSKNXTKX() {
          let instance = this._instance;
          if (instance == null) {
            instance = this._instance = new this();
          }
          return instance;
        }
      }
      exports('TTINOQH', TTINOQH);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ui-config.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "724fduBcVFFMLwCA+WOo7pQ", "ui-config", undefined);
      let UIID = exports('UIID', /*#__PURE__*/function (UIID) {
        UIID[UIID["Toast"] = 0] = "Toast";
        UIID[UIID["Loading"] = 1] = "Loading";
        UIID[UIID["GuideTips"] = 2] = "GuideTips";
        UIID[UIID["UnderView"] = 3] = "UnderView";
        UIID[UIID["HomeView"] = 4] = "HomeView";
        UIID[UIID["GmView"] = 5] = "GmView";
        UIID[UIID["DebugInfoView"] = 6] = "DebugInfoView";
        UIID[UIID["PolicyPopup"] = 7] = "PolicyPopup";
        UIID[UIID["MoreGameView"] = 8] = "MoreGameView";
        UIID[UIID["VictoryPopup"] = 9] = "VictoryPopup";
        UIID[UIID["MenuPopup"] = 10] = "MenuPopup";
        UIID[UIID["GuidePopup"] = 11] = "GuidePopup";
        UIID[UIID["RatingPopup"] = 12] = "RatingPopup";
        UIID[UIID["CardThemeView"] = 13] = "CardThemeView";
        UIID[UIID["ItemObtainPopup"] = 14] = "ItemObtainPopup";
        UIID[UIID["RewardGetPopup"] = 15] = "RewardGetPopup";
        UIID[UIID["SignInPopup"] = 16] = "SignInPopup";
        UIID[UIID["TargetPopup"] = 17] = "TargetPopup";
        UIID[UIID["BeyondPopup"] = 18] = "BeyondPopup";
        UIID[UIID["SelectView"] = 19] = "SelectView";
        UIID[UIID["PlotView"] = 20] = "PlotView";
        UIID[UIID["SelectResultView"] = 21] = "SelectResultView";
        UIID[UIID["ChapterView"] = 22] = "ChapterView";
        UIID[UIID["MapView"] = 23] = "MapView";
        UIID[UIID["StartView"] = 24] = "StartView";
        UIID[UIID["ChapterDetailView"] = 25] = "ChapterDetailView";
        UIID[UIID["IllustrationView"] = 26] = "IllustrationView";
        UIID[UIID["HomeViewSg"] = 27] = "HomeViewSg";
        UIID[UIID["VictoryPopupSg"] = 28] = "VictoryPopupSg";
        UIID[UIID["PictureObtainPopup"] = 29] = "PictureObtainPopup";
        UIID[UIID["AdUnlockPopup"] = 30] = "AdUnlockPopup";
        UIID[UIID["SlidePictureView"] = 31] = "SlidePictureView";
        UIID[UIID["IllustrationViewSg"] = 32] = "IllustrationViewSg";
        UIID[UIID["ItemObtainPopupSg"] = 33] = "ItemObtainPopupSg";
        UIID[UIID["PictureObtainView"] = 34] = "PictureObtainView";
        UIID[UIID["AlbumView"] = 35] = "AlbumView";
        UIID[UIID["AlbumDetailView"] = 36] = "AlbumDetailView";
        UIID[UIID["PausedPopupSg"] = 37] = "PausedPopupSg";
        UIID[UIID["PictureSelectView"] = 38] = "PictureSelectView";
        UIID[UIID["StartViewSg"] = 39] = "StartViewSg";
        UIID[UIID["ItemGetPopupSg"] = 40] = "ItemGetPopupSg";
        UIID[UIID["PictureView"] = 41] = "PictureView";
        UIID[UIID["LoadingSg"] = 42] = "LoadingSg";
        UIID[UIID["DescriptionView"] = 43] = "DescriptionView";
        UIID[UIID["SpecialRewardPopup"] = 44] = "SpecialRewardPopup";
        return UIID;
      }({}));
      let UICF = exports('UICF', {
        //common
        [UIID.Toast]: {
          prefab: "prefab/ui/common/Toast"
        },
        [UIID.Loading]: {
          prefab: "prefab/ui/common/LoadingView",
          preventTouch: true
        },
        [UIID.GuideTips]: {
          prefab: "prefab/ui/common/GuideTips"
        },
        //main
        [UIID.UnderView]: {
          prefab: "prefab/ui/home/UnderView"
        },
        [UIID.HomeView]: {
          prefab: "prefab/ui/home/HomeView"
        },
        [UIID.GmView]: {
          prefab: "prefab/ui/home/GmView",
          preventTouch: true
        },
        [UIID.DebugInfoView]: {
          prefab: "prefab/ui/home/DebugInfoView",
          preventTouch: true
        },
        [UIID.PolicyPopup]: {
          prefab: "prefab/ui/home/PolicyPopup",
          preventTouch: true
        },
        [UIID.MoreGameView]: {
          prefab: "prefab/ui/home/MoreGameView",
          preventTouch: true
        },
        [UIID.MenuPopup]: {
          prefab: "prefab/ui/home/MenuPopup",
          preventTouch: true
        },
        [UIID.GuidePopup]: {
          prefab: "prefab/ui/home/GuidePopup",
          preventTouch: true
        },
        [UIID.RatingPopup]: {
          prefab: "prefab/ui/home/RatingPopup",
          preventTouch: true
        },
        [UIID.CardThemeView]: {
          prefab: "prefab/ui/card-theme/CardThemeView",
          preventTouch: true
        },
        [UIID.ItemObtainPopup]: {
          prefab: "prefab/ui/reward-popup/ItemObtainPopup",
          preventTouch: true
        },
        [UIID.RewardGetPopup]: {
          prefab: "prefab/ui/home/RewardGetPopup",
          preventTouch: true
        },
        [UIID.SignInPopup]: {
          prefab: "prefab/ui/reward-popup/SignInPopup",
          preventTouch: true
        },
        [UIID.TargetPopup]: {
          prefab: "prefab/ui/home/TargetPopup",
          preventTouch: true
        },
        //map
        [UIID.SelectView]: {
          prefab: "prefab/ui/map/SelectView",
          preventTouch: true
        },
        [UIID.PlotView]: {
          prefab: "prefab/ui/map/PlotView",
          preventTouch: true
        },
        [UIID.SelectResultView]: {
          prefab: "prefab/ui/map/SelectResultView",
          preventTouch: true
        },
        [UIID.ChapterView]: {
          prefab: "prefab/ui/map/ChapterView",
          preventTouch: true
        },
        [UIID.MapView]: {
          prefab: "prefab/ui/map/MapView",
          preventTouch: true
        },
        [UIID.StartView]: {
          prefab: "prefab/ui/map/StartView",
          preventTouch: true
        },
        [UIID.ChapterDetailView]: {
          prefab: "prefab/ui/map/ChapterDetailView",
          preventTouch: true
        },
        [UIID.PictureView]: {
          prefab: "prefab/ui/map/PictureView",
          preventTouch: true
        },
        [UIID.IllustrationView]: {
          prefab: "prefab/ui/map/IllustrationView",
          preventTouch: true
        }
      });
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ui-manager.ts", ['cc', './res-loader.ts', './ui-view.ts', './ui-config.ts', './game-data-manager.ts', './config.ts'], function (exports) {
  var cclegacy, director, Prefab, instantiate, Node, UITransform, view, log, isValid, resLoader, UIShowTypes, UIView, UIID, GameDataManager, Config;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      director = module.director;
      Prefab = module.Prefab;
      instantiate = module.instantiate;
      Node = module.Node;
      UITransform = module.UITransform;
      view = module.view;
      log = module.log;
      isValid = module.isValid;
    }, function (module) {
      resLoader = module.resLoader;
    }, function (module) {
      UIShowTypes = module.UIShowTypes;
      UIView = module.UIView;
    }, function (module) {
      UIID = module.UIID;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      Config = module.Config;
    }],
    execute: function () {
      cclegacy._RF.push({}, "72300CN7XxGXoV0giY3fi/N", "ui-manager", undefined);

      /**
       * UIManager界面管理类
       * 
       * 1.打开界面，根据配置自动加载界面、调用初始化、播放打开动画、隐藏其他界面、屏蔽下方界面点击
       * 2.关闭界面，根据配置自动关闭界面、播放关闭动画、恢复其他界面
       * 3.切换界面，与打开界面类似，但是是将当前栈顶的界面切换成新的界面（先关闭再打开）
       * 4.提供界面缓存功能
       */

      /** UI栈结构体 */
      /** UI配置结构体 */
      /** ui动画名 */
      const UiAni = {
        Open: "ui-open",
        Close: "ui-close"
      };
      class UIManager {
        constructor() {
          /** ui层级 */
          this.uiLayer = null;
          this.toastLayer = null;
          this.guideLayer = null;
          /** 资源加载计数器，用于生成唯一的资源占用key */
          this.useCount = 0;
          /** 背景UI（有若干层UI是作为背景UI，而不受切换等影响）*/
          this.BackGroundUI = 0;
          /** 是否正在关闭UI */
          this.isClosing = false;
          /** 是否正在打开UI */
          this.isOpening = false;
          /** UI界面缓存（key为UIId，value为UIView节点）*/
          this.UICache = {};
          /** UI界面栈（{UIID + UIView + UIArgs}数组）*/
          this.UIStack = [];
          /** UI待打开列表 */
          this.UIOpenQueue = [];
          /** UI待关闭列表 */
          this.UICloseQueue = [];
          /** UI配置 */
          this.UIConf = {};
          this.toastView = null;
          this.guideView = null;
          /** UI打开前回调 */
          this.uiOpenBeforeDelegate = null;
          /** UI打开回调 */
          this.uiOpenDelegate = null;
          /** UI关闭回调 */
          this.uiCloseDelegate = null;
        }
        static get instance() {
          if (!this._instance) {
            this._instance = new UIManager();
            this._instance.init();
          }
          return this._instance;
        }
        /**
         * 初始化所有UI的配置对象
         * @param conf 配置对象
         */
        initUIConf(conf) {
          this.UIConf = conf;
        }

        /**
         * 设置或覆盖某uiId的配置
         * @param uiId 要设置的界面id
         * @param conf 要设置的配置
         */
        setUIConf(uiId, conf) {
          this.UIConf[uiId] = conf;
        }
        init() {
          this.setLayer();
        }
        setLayer() {
          let canvas = director.getScene().getChildByName("Canvas");
          this.uiLayer = canvas.getChildByName("uiLayer");
          this.guideLayer = canvas.getChildByName("guideLayer");
          this.toastLayer = canvas.getChildByName("toastLayer");
        }

        /****************** 私有方法，UIManager内部的功能和基础规则 *******************/

        /**
         * 添加防触摸层
         * @param zOrder 屏蔽层的层级
         */
        async preventTouch(zOrder) {
          let prefab = await resLoader.loadAsync('prefab/ui/common/PreventTouch', Prefab);
          let node = prefab ? instantiate(prefab) : new Node();
          node.name = 'preventTouch';
          let uiCom = node.addComponent(UITransform);
          uiCom.setContentSize(view.getVisibleSize());
          node.on(Node.EventType.TOUCH_START, function (event) {
            event.propagationStopped = true;
          }, node);
          this.uiLayer.addChild(node);
          uiCom.priority = zOrder - 0.01;
          return node;
        }

        /** 自动执行下一个待关闭或待打开的界面 */
        autoExecNextUI() {
          // 逻辑上是先关后开
          if (this.UICloseQueue.length > 0) {
            let uiQueueInfo = this.UICloseQueue[0];
            this.UICloseQueue.splice(0, 1);
            this.close(uiQueueInfo);
          } else if (this.UIOpenQueue.length > 0) {
            let uiQueueInfo = this.UIOpenQueue[0];
            this.UIOpenQueue.splice(0, 1);
            this.open(uiQueueInfo.uiId, uiQueueInfo.uiArgs);
          }
        }

        /**
         * 自动检测动画组件以及特定动画，如存在则播放动画，无论动画是否播放，都执行回调
         * @param aniName 动画名
         * @param aniOverCallback 动画播放完成回调
         */
        autoExecAnimation(uiView, aniName, aniOverCallback) {
          // 播放动画
          // 暂时先省略动画播放的逻辑
          if (uiView.animComp && uiView.isPlayAnim) {
            uiView.aniOverCallback = aniOverCallback;
            uiView.animComp.play(aniName);
          } else {
            console.warn(`uiView ${uiView.node.name} animComp is null`);
            aniOverCallback();
          }
        }

        /**
         * 自动检测资源预加载组件，如果存在则加载完成后调用completeCallback，否则直接调用
         * @param completeCallback 资源加载完成回调
         */
        autoLoadRes(uiView, completeCallback) {
          // 暂时先省略
          completeCallback();
        }

        /** 根据界面显示类型刷新显示 */
        updateUI() {
          this.hideGuide();
          let hideIndex = 0;
          let showIndex = this.UIStack.length - 1;
          for (; showIndex >= 0; --showIndex) {
            let mode = this.UIStack[showIndex].uiView.showType;
            // 无论何种模式，最顶部的UI都是应该显示的
            this.UIStack[showIndex].uiView.node.active = true;
            if (this.UIStack[showIndex].preventNode) {
              this.UIStack[showIndex].preventNode.active = true;
            }
            if (UIShowTypes.UIFullScreen == mode) {
              break;
            } else if (UIShowTypes.UISingle == mode) {
              for (let i = 0; i < this.BackGroundUI; ++i) {
                this.UIStack[i].uiView.node.active = true;
                if (this.UIStack[i].preventNode) {
                  this.UIStack[i].preventNode.active = true;
                }
              }
              hideIndex = this.BackGroundUI;
              break;
            }
          }
          // 隐藏不应该显示的部分UI
          for (let hide = hideIndex; hide < showIndex; ++hide) {
            let mode = this.UIStack[hide].uiView.showType;
            if (UIShowTypes.UIFullScreen == mode) {
              continue;
            }
            this.UIStack[hide].uiView.node.active = false;
            if (this.UIStack[hide].preventNode) {
              this.UIStack[hide].preventNode.active = false;
            }
          }
          console.log(`updateUI-UIStack-length:${this.UIStack.length}`);
          for (let i = 0; i < this.UIStack.length; i++) {
            console.log(`updateUI-UIStack-id:${this.UIStack[i].uiId}`);
          }
        }

        /**
         * 异步加载一个UI的prefab，成功加载了一个prefab之后
         * @param uiId 界面id
         * @param processCallback 加载进度回调
         * @param completeCallback 加载完成回调
         * @param uiArgs 初始化参数
         */
        getOrCreateUI(uiId, processCallback, completeCallback, uiArgs) {
          var _this$UIConf$uiId;
          // 如果找到缓存对象，则直接返回
          let uiView = this.UICache[uiId];
          if (uiView) {
            completeCallback(uiView);
            return;
          }

          // 找到UI配置
          let config = this.UIConf[uiId];
          if (!config) {
            log(`getOrCreateUI ${uiId} faile, prefab conf not found!`);
            completeCallback(null);
            return;
          }
          let uiPath = config.prefab;
          if (null == uiPath) {
            log(`getOrCreateUI ${uiId} faile, prefab conf not found!`);
            completeCallback(null);
            return;
          }
          let bundle = ((_this$UIConf$uiId = this.UIConf[uiId]) == null ? void 0 : _this$UIConf$uiId.bundle) || 'resources';
          resLoader.load(bundle, uiPath, processCallback, (err, prefab) => {
            // 检查加载资源错误
            if (err) {
              log(`getOrCreateUI loadRes ${uiId} faile, bundle: ${bundle}, path: ${uiPath}, error: ${err}`);
              completeCallback(null);
              return;
            }
            // 检查实例化错误
            let uiNode = instantiate(prefab);
            if (null == uiNode) {
              log(`getOrCreateUI instantiate ${uiId} faile, bundle: ${bundle}, path: ${uiPath}`);
              completeCallback(null);
              prefab.decRef();
              return;
            }
            // 检查组件获取错误
            uiView = uiNode.getComponent(UIView);
            if (null == uiView) {
              log(`getOrCreateUI getComponent ${uiId} faile, bundle: ${bundle}, path: ${uiPath}`);
              uiNode.destroy();
              completeCallback(null);
              prefab.decRef();
              return;
            }
            // 异步加载UI预加载的资源
            this.autoLoadRes(uiView, () => {
              uiView.init(uiArgs);
              completeCallback(uiView);
              uiView.cacheAsset(prefab);
            });
          });
        }

        /**
         * UI被打开时回调，对UI进行初始化设置，刷新其他界面的显示，并根据
         * @param uiId 哪个界面被打开了
         * @param uiView 界面对象
         * @param uiInfo 界面栈对应的信息结构
         * @param uiArgs 界面初始化参数
         */
        onUIOpen(uiId, uiView, uiInfo, uiArgs) {
          if (null == uiView) {
            return;
          }
          // 激活界面
          uiInfo.uiView = uiView;
          uiView.node.active = true;
          let uiCom = uiView.getComponent(UITransform);
          if (!uiCom) {
            uiCom = uiView.addComponent(UITransform);
          }

          // 快速关闭界面的设置，绑定界面中的background，实现快速关闭
          if (uiView.quickClose) {
            let backGround = uiView.node.getChildByName('background');
            if (!backGround) {
              backGround = new Node();
              backGround.name = 'background';
              let uiCom = backGround.addComponent(UITransform);
              uiCom.setContentSize(view.getVisibleSize());
              uiView.node.addChild(backGround);
              uiCom.priority = -1;
            }
            backGround.targetOff(Node.EventType.TOUCH_START);
            backGround.on(Node.EventType.TOUCH_START, event => {
              event.propagationStopped = true;
              this.close(uiView);
            }, backGround);
          }

          // 添加到场景中
          this.uiLayer.addChild(uiView.node);
          uiCom.priority = uiInfo.zOrder || this.UIStack.length;

          // 刷新其他UI
          this.updateUI();

          // 从那个界面打开的
          let fromUIID = 0;
          if (this.UIStack.length > 1) {
            fromUIID = this.UIStack[this.UIStack.length - 2].uiId;
          }

          // 打开界面之前回调
          if (this.uiOpenBeforeDelegate) {
            this.uiOpenBeforeDelegate(uiId, fromUIID);
          }

          // 执行onOpen回调
          uiView.onOpen(fromUIID, uiArgs);
          this.autoExecAnimation(uiView, UiAni.Open, () => {
            uiView.onOpenAniOver();
            if (this.uiOpenDelegate) {
              this.uiOpenDelegate(uiId, fromUIID);
            }
          });
        }

        /** 打开界面并添加到界面栈中 */
        async open(uiId, uiArgs = null, progressCallback = null) {
          let uiInfo = {
            uiId: uiId,
            uiArgs: uiArgs,
            uiView: null
          };
          if (this.isOpening || this.isClosing) {
            // 插入待打开队列
            this.UIOpenQueue.push(uiInfo);
            return;
          }
          let uiIndex = this.getUIIndex(uiId);
          if (-1 != uiIndex) {
            // 重复打开了同一个界面，直接回到该界面
            this.closeToUI(uiId, uiArgs);
            return;
          }

          // 设置UI的zOrder
          uiInfo.zOrder = this.UIStack.length + 1;
          this.UIStack.push(uiInfo);
          this.isOpening = true;

          // 先屏蔽点击
          if (this.UIConf[uiId].preventTouch) {
            uiInfo.preventNode = await this.preventTouch(uiInfo.zOrder);
          }

          // 预加载资源，并在资源加载完成后自动打开界面
          this.getOrCreateUI(uiId, progressCallback, uiView => {
            // 如果界面已经被关闭或创建失败
            if (uiInfo.isClose || null == uiView) {
              log(`getOrCreateUI ${uiId} faile!
                        close state : ${uiInfo.isClose} , uiView : ${uiView}`);
              this.isOpening = false;
              if (uiInfo.preventNode) {
                uiInfo.preventNode.destroy();
                uiInfo.preventNode = null;
              }
              return;
            }

            // 打开UI，执行配置
            this.onUIOpen(uiId, uiView, uiInfo, uiArgs);
            this.isOpening = false;
            this.autoExecNextUI();
          }, uiArgs);
        }

        /** 替换栈顶界面 */
        replace(uiId, uiArgs = null) {
          this.close(this.UIStack[this.UIStack.length - 1].uiView);
          this.open(uiId, uiArgs);
        }

        /**
         * 关闭当前界面
         * @param closeUI 要关闭的界面
         */
        close(closeUI) {
          let uiCount = this.UIStack.length;
          if (uiCount < 1 || this.isClosing || this.isOpening) {
            if (closeUI) {
              // 插入待关闭队列
              this.UICloseQueue.push(closeUI);
            }
            return;
          }
          let uiInfo;
          if (closeUI) {
            for (let index = this.UIStack.length - 1; index >= 0; index--) {
              let ui = this.UIStack[index];
              if (ui.uiView === closeUI) {
                uiInfo = ui;
                this.UIStack.splice(index, 1);
                break;
              }
            }
          } else {
            uiInfo = this.UIStack.pop();
          }
          // 找不到这个UI
          if (uiInfo === undefined) {
            return;
          }

          // 关闭当前界面
          let uiId = uiInfo.uiId;
          let uiView = uiInfo.uiView;
          uiInfo.isClose = true;

          // 回收遮罩层
          if (uiInfo.preventNode) {
            uiInfo.preventNode.destroy();
            uiInfo.preventNode = null;
          }
          if (!uiView) {
            return;
          }
          let preUIInfo = this.UIStack[uiCount - 2];
          // 处理显示模式
          this.updateUI();
          let close = () => {
            this.isClosing = false;
            // 显示之前的界面
            if (preUIInfo && preUIInfo.uiView && this.isTopUI(preUIInfo.uiId)) {
              // 如果之前的界面弹到了最上方（中间有肯能打开了其他界面）
              preUIInfo.uiView.node.active = true;
              // 回调onTop
              preUIInfo.uiView.onTop(uiId, uiView.onClose());
            } else {
              uiView.onClose();
            }
            if (this.uiCloseDelegate) {
              this.uiCloseDelegate(uiId);
            }
            if (uiView.cache) {
              this.UICache[uiId] = uiView;
              uiView.node.removeFromParent();
              log(`uiView removeFromParent ${uiInfo.uiId}`);
            } else {
              uiView.releaseAssets();
              uiView.node.destroy();
              log(`uiView destroy ${uiInfo.uiId}`);
            }
            this.autoExecNextUI();
          };
          // 执行关闭动画
          this.autoExecAnimation(uiView, UiAni.Close, close);
        }

        /** 关闭所有界面 */
        closeAll() {
          // 不播放动画，也不清理缓存
          for (const uiInfo of this.UIStack) {
            uiInfo.isClose = true;
            if (uiInfo.preventNode) {
              uiInfo.preventNode.destroy();
              uiInfo.preventNode = null;
            }
            if (uiInfo.uiView) {
              uiInfo.uiView.onClose();
              uiInfo.uiView.releaseAssets();
              uiInfo.uiView.node.destroy();
            }
          }
          if (this.toastView) {
            this.toastView.onClose();
            this.toastView.releaseAssets();
            this.toastView.node.destroy();
            this.toastView = null;
          }
          if (this.guideView) {
            this.guideView.onClose();
            this.guideView.releaseAssets();
            this.guideView.node.destroy();
            this.guideView = null;
          }
          this.UIOpenQueue = [];
          this.UICloseQueue = [];
          this.UIStack = [];
          this.isOpening = false;
          this.isClosing = false;
        }

        /**
         * 关闭界面，一直关闭到顶部为uiId的界面，为避免循环打开UI导致UI栈溢出
         * @param uiId 要关闭到的uiId（关闭其顶部的ui）
         * @param uiArgs 打开的参数
         * @param bOpenSelf 
         */
        closeToUI(uiId, uiArgs, bOpenSelf = true) {
          let idx = this.getUIIndex(uiId);
          if (-1 == idx) {
            return;
          }
          idx = bOpenSelf ? idx : idx + 1;
          for (let i = this.UIStack.length - 1; i >= idx; --i) {
            let uiInfo = this.UIStack.pop();
            if (!uiInfo) {
              continue;
            }
            let uiId = uiInfo.uiId;
            let uiView = uiInfo.uiView;
            uiInfo.isClose = true;

            // 回收屏蔽层
            if (uiInfo.preventNode) {
              uiInfo.preventNode.destroy();
              uiInfo.preventNode = null;
            }
            if (this.uiCloseDelegate) {
              this.uiCloseDelegate(uiId);
            }
            if (uiView) {
              uiView.onClose();
              if (uiView.cache) {
                this.UICache[uiId] = uiView;
                uiView.node.removeFromParent();
              } else {
                uiView.releaseAssets();
                uiView.node.destroy();
              }
            }
          }
          this.updateUI();
          this.UIOpenQueue = [];
          this.UICloseQueue = [];
          bOpenSelf && this.open(uiId, uiArgs);
        }

        /** 清理界面缓存 */
        clearCache() {
          for (const key in this.UICache) {
            let ui = this.UICache[key];
            if (isValid(ui.node)) {
              if (isValid(ui)) {
                ui.releaseAssets();
              }
              ui.node.destroy();
            }
          }
          this.UICache = {};
        }

        /******************** UI的便捷接口 *******************/
        isTopUI(uiId) {
          if (this.UIStack.length == 0) {
            return false;
          }
          return this.UIStack[this.UIStack.length - 1].uiId == uiId;
        }
        getUI(uiId) {
          for (let index = 0; index < this.UIStack.length; index++) {
            const element = this.UIStack[index];
            if (uiId == element.uiId) {
              return element.uiView;
            }
          }
          return null;
        }
        getTopUI() {
          if (this.UIStack.length > 0) {
            return this.UIStack[this.UIStack.length - 1].uiView;
          }
          return null;
        }
        getUIIndex(uiId) {
          for (let index = 0; index < this.UIStack.length; index++) {
            const element = this.UIStack[index];
            if (uiId == element.uiId) {
              return index;
            }
          }
          return -1;
        }
        showToast(msg) {
          this.getOrCreateUI(UIID.Toast, null, uiView => {
            if (null == uiView || !uiView.node) {
              return;
            }
            if (!this.toastLayer) {
              console.warn("toastLayer is null");
              return;
            }
            this.toastLayer.addChild(uiView.node);
            uiView.onOpen(0, {
              content: msg
            });
            this.toastView = uiView;
          }, null);
        }
        hideToast() {
          var _this$toastView, _this$toastView2;
          (_this$toastView = this.toastView) == null || _this$toastView.onClose();
          (_this$toastView2 = this.toastView) == null || _this$toastView2.node.removeFromParent();
          this.toastView = null;
        }
        showGuide(info) {
          this.getOrCreateUI(UIID.GuideTips, null, uiView => {
            if (null == uiView) {
              return;
            }
            if (!this.toastLayer) {
              console.warn("toastLayer is null");
              return;
            }
            this.guideLayer.addChild(uiView.node);
            uiView.onOpen(0, info);
            this.guideView = uiView;
          }, null);
        }
        hideGuide() {
          var _this$guideView, _this$guideView2;
          (_this$guideView = this.guideView) == null || _this$guideView.onClose();
          (_this$guideView2 = this.guideView) == null || _this$guideView2.node.removeFromParent();
          this.guideView = null;
        }
        showDebugInfoToast() {
          if (Config.DEBUG) {
            let gdMgr = GameDataManager.instance;
            let loadingTime = 0;
            if (gdMgr.preloadPicEndTime > 0 && gdMgr.preloadPicStartTime > 0) {
              loadingTime = Math.floor((gdMgr.preloadPicEndTime - gdMgr.preloadPicStartTime) / 1000);
            }
            let unshown_s = gdMgr.getUnselectedPictureList(10, true, false, true);
            let shown_s = gdMgr.getUnselectedPictureList(10, true, true, true);
            let str_s = `s: ${unshown_s.length}/${unshown_s.length + shown_s.length}`;
            let unshown_n = gdMgr.getUnselectedPictureList(10, false, false, true);
            let shown_n = gdMgr.getUnselectedPictureList(10, false, true, true);
            let str_n = `n:${unshown_n.length}/${unshown_n.length + shown_n.length}`;
            let str = `f-time: ${loadingTime}s, state:${gdMgr.sg.state} \n ${str_s}, ${str_n}`;
            this.showToast(str);
          }
        }
      }
      exports('UIManager', UIManager);
      UIManager._instance = null;
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ui-screen-adapter.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './log-util.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Node, _decorator, Component, sys, view, UITransform, LogUtil;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Node = module.Node;
      _decorator = module._decorator;
      Component = module.Component;
      sys = module.sys;
      view = module.view;
      UITransform = module.UITransform;
    }, function (module) {
      LogUtil = module.LogUtil;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "387c69mmgFNdpd/BOwsX2yp", "ui-screen-adapter", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let UIScreenAdapter = exports('UIScreenAdapter', (_dec = ccclass('UIScreenAdapter'), _dec2 = property({
        type: Node,
        tooltip: 'Widget组件不要设置纵向对齐'
      }), _dec3 = property({
        type: Node,
        tooltip: '顶部UI'
      }), _dec4 = property(Node), _dec(_class = (_class2 = class UIScreenAdapter extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "content", _descriptor, this);
          _initializerDefineProperty(this, "topUI", _descriptor2, this);
          _initializerDefineProperty(this, "topBg", _descriptor3, this);
        }
        start() {
          this.scheduleOnce(() => {
            this.adaptToScreen();
          }, 0);
        }
        adaptToScreen() {
          let safeArea = sys.getSafeAreaRect();
          let winSize = view.getVisibleSize();

          // 内容区域适配
          this.content && this.content.getComponent(UITransform).setContentSize(winSize.width, safeArea.height);
          // 顶部背景
          let topBgHeight = winSize.height - (safeArea.y + safeArea.height);
          this.topBg && LogUtil.log(`(${this.node.name})ScreenAdapter-topBgHeight1`, topBgHeight);
          if (this.topUI) {
            topBgHeight += this.topUI.getComponent(UITransform).contentSize.height + 70;
          }
          if (this.topBg) {
            LogUtil.log(`(${this.node.name})ScreenAdapter-topBgHeight2`, topBgHeight);
            // this.topBg.getComponent(UITransform).setContentSize(winSize.width, topBgHeight);
            this.topBg.getComponent(UITransform).height = topBgHeight;
          }
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "content", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "topUI", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "topBg", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ui-util.ts", ['cc', './card.ts', './game-constants.ts'], function (exports) {
  var cclegacy, UITransform, director, Card, GameConstants;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      UITransform = module.UITransform;
      director = module.director;
    }, function (module) {
      Card = module.Card;
    }, function (module) {
      GameConstants = module.GameConstants;
    }],
    execute: function () {
      cclegacy._RF.push({}, "992e5FWge1KWoDxJsFACVTa", "ui-util", undefined);
      class UIUtil {
        static moveCardToParent(node, targetParent, targetArea, targetPos = null) {
          // LogUtil.log('moveCardToParent', node.name, targetParent.name, targetArea, targetPos);
          if (!node || !targetParent) {
            return;
          }
          const originParent = node.parent;
          const originPos = node.position.clone();
          if (!targetPos && originParent) {
            // keep the same position
            targetPos = targetParent.getComponent(UITransform).convertToNodeSpaceAR(originParent.getComponent(UITransform).convertToWorldSpaceAR(originPos));
          }
          if (targetParent != originParent) {
            node.removeFromParent();
            targetParent.addChild(node);
          }
          node.getComponent(Card).setArea(targetArea);
          node.position = targetPos;
        }
        static calculateDistance(pos1, pos2) {
          const dx = pos2.x - pos1.x;
          const dy = pos2.y - pos1.y;
          return Math.sqrt(dx * dx + dy * dy);
        }
        static calcMoveDuration(startPos, endPos, speed = GameConstants.MoveSpeed) {
          const distance = UIUtil.calculateDistance(startPos, endPos);
          return distance / speed;
        }

        /**
         * 将屏幕坐标转换为某节点的坐标系(用于点击事件的坐标转换)
         * @param sPos 屏幕（点击）坐标
         * @param parent 目标坐标系的父节点
         * @param root 调用组件的根节点（一般传 this.node）
         * @returns 本地坐标
         */
        static convertScreenPosToLocal(sPos, parent, root) {
          let uiCamera = director.root.batcher2D.getFirstRenderCamera(root);
          uiCamera.screenToWorld(sPos, sPos);
          let lPos = parent.getComponent(UITransform).convertToNodeSpaceAR(sPos);
          return lPos;
        }
      }
      exports('UIUtil', UIUtil);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/ui-view.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './res-keeper.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Enum, _decorator, Animation, ResKeeper;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Enum = module.Enum;
      _decorator = module._decorator;
      Animation = module.Animation;
    }, function (module) {
      ResKeeper = module.ResKeeper;
    }],
    execute: function () {
      var _dec, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _class3;
      cclegacy._RF.push({}, "eb7f9q8avxDbrg9FuTHeP+T", "ui-view", undefined);

      /**
       * UIView界面基础类
       * 
       * 1. 快速关闭与屏蔽点击的选项配置
       * 2. 界面缓存设置（开启后界面关闭不会被释放，以便下次快速打开）
       * 3. 界面显示类型配置
       * 
       * 4. 加载资源接口（随界面释放自动释放），this.loadRes(xxx)
       * 5. 由UIManager释放
       * 
       * 5. 界面初始化回调（只调用一次）
       * 6. 界面打开回调（每次打开回调）
       * 7. 界面打开动画播放结束回调（动画播放完回调）
       * 8. 界面关闭回调
       * 9. 界面置顶回调
       */

      const {
        ccclass,
        property
      } = _decorator;

      /** 界面展示类型 */
      let UIShowTypes = exports('UIShowTypes', /*#__PURE__*/function (UIShowTypes) {
        UIShowTypes[UIShowTypes["UIFullScreen"] = 0] = "UIFullScreen";
        UIShowTypes[UIShowTypes["UIAddition"] = 1] = "UIAddition";
        UIShowTypes[UIShowTypes["UISingle"] = 2] = "UISingle";
        return UIShowTypes;
      }({})); // 单界面显示，只显示当前界面和背景界面，性能较好
      let UIView = exports('UIView', (_dec = property({
        type: Enum(UIShowTypes)
      }), ccclass(_class = (_class2 = (_class3 = class UIView extends ResKeeper {
        constructor(...args) {
          super(...args);
          /** 快速关闭 */
          _initializerDefineProperty(this, "quickClose", _descriptor, this);
          /** 快速关闭 */
          _initializerDefineProperty(this, "isPlayAnim", _descriptor2, this);
          /** 屏蔽点击选项 在UIConf设置屏蔽点击*/
          // @property
          // preventTouch: boolean = true;
          /** 缓存选项 */
          _initializerDefineProperty(this, "cache", _descriptor3, this);
          /** 播放通用UI动画 */
          /** 界面显示类型 */
          _initializerDefineProperty(this, "showType", _descriptor4, this);
          /** 界面id */
          this.UIid = 0;
          this.aniOverCallback = null;
          /** 用于播放UI开关动画的组件，绑定在子节点下面*/
          this.animComp = null;
        }
        onLoad() {
          let content = this.node.getChildByName('Content');
          if (content) {
            this.animComp = content.getComponent(Animation);
          }
        }
        onEnable() {
          if (this.animComp) {
            this.animComp.on(Animation.EventType.FINISHED, () => {
              this.aniOverCallback && this.aniOverCallback();
            }, this);
          }
        }
        onDisable() {
          if (this.animComp) {
            this.animComp.off(Animation.EventType.FINISHED);
          }
        }

        /********************** UI的回调 ***********************/
        /**
         * 当界面被创建时回调，生命周期内只调用
         * @param args 可变参数
         */
        init(...args) {}

        /**
         * 当界面被打开时回调，每次调用Open时回调
         * @param fromUI 从哪个UI打开的
         * @param args 可变参数
         */
        onOpen(fromUI, ...args) {}

        /**
         * 每次界面Open动画播放完毕时回调
         */
        onOpenAniOver() {}

        /**
         * 当界面被关闭时回调，每次调用Close时回调
         * 返回值会传递给下一个界面
         */
        onClose() {}

        /**
         * 当界面被置顶时回调，Open时并不会回调该函数
         * @param preID 前一个ui
         * @param args 可变参数，
         */
        onTop(preID, ...args) {}
      }, _class3.uiIndex = 0, _class3), (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "quickClose", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return false;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "isPlayAnim", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return true;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "cache", [property], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return false;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "showType", [_dec], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return UIShowTypes.UISingle;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/under-view.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './drift-bubble.ts', './reward-manager.ts', './game-constants.ts', './config.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Prefab, _decorator, NodePool, director, view, instantiate, Node, UITransform, UIView, DriftBubble, RewardManager, GameEvent, ParamGetReward, Config;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Prefab = module.Prefab;
      _decorator = module._decorator;
      NodePool = module.NodePool;
      director = module.director;
      view = module.view;
      instantiate = module.instantiate;
      Node = module.Node;
      UITransform = module.UITransform;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      DriftBubble = module.DriftBubble;
    }, function (module) {
      RewardManager = module.RewardManager;
    }, function (module) {
      GameEvent = module.GameEvent;
      ParamGetReward = module.ParamGetReward;
    }, function (module) {
      Config = module.Config;
    }],
    execute: function () {
      var _dec, _dec2, _class, _class2, _descriptor;
      cclegacy._RF.push({}, "d4f3bpoOj9LnIuhiZk4J7LH", "under-view", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let UnderView = exports('UnderView', (_dec = ccclass('UnderView'), _dec2 = property(Prefab), _dec(_class = (_class2 = class UnderView extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "prfbDriftBubble", _descriptor, this);
          this.bubblePool = new NodePool();
          this.poolSizeLimit = 5;
          this.bubbleList = [];
          this.canCreateBubble = true;
        }
        onOpen(fromUI, ...args) {
          let isStoreShow = Config.FULL_MODE;
          if (!isStoreShow) {
            return;
          }
          director.on(GameEvent.GET_REWARD, this.onGetRewardEvent, this);
          this.createBubbleWithDelay(RewardManager.instance.getConfig().ad.drift_bubble.show.show_delay_first);
        }
        onClose() {
          director.off(GameEvent.GET_REWARD, this.onGetRewardEvent, this);
          this.unschedule(this.createBubble);
          this.bubblePool.clear();
        }
        update(dt) {
          let isStoreShow = Config.FULL_MODE;
          if (!isStoreShow) {
            return;
          }
          if (this.bubbleList.length > 0) {
            for (let i = 0; i < this.bubbleList.length;) {
              let bubble = this.bubbleList[i];
              if (bubble.getPosition().y > view.getVisibleSize().height / 2) {
                this.removeBubble(bubble);
              } else {
                i++;
              }
            }
          }
          if (this.canCreateBubble) {
            this.createBubbleWithDelay(RewardManager.instance.getConfig().ad.drift_bubble.show.show_delay_not_recieved);
          }
        }
        onGetRewardEvent(...params) {
          if (params[0] === ParamGetReward.GET_FROM_DRIFT) {
            let config = RewardManager.instance.getConfig().ad.drift_bubble.show;
            let delay = params[1] ? config.show_delay_recieved : config.show_delay_not_recieved;
            this.createBubbleWithDelay(delay);
          }
        }
        createBubble() {
          let bubble = this.bubblePool.get();
          if (!bubble) {
            bubble = instantiate(this.prfbDriftBubble);
          }
          bubble.on(Node.EventType.TOUCH_START, () => {
            this.removeBubble(bubble);
          }, this);
          this.node.addChild(bubble);
          let winSize = view.getVisibleSize();
          let rand = Math.random() - 0.5;
          let x = 0;
          if (rand > 0) {
            x = (winSize.width / 2 - bubble.getComponent(UITransform).contentSize.width / 2) * (rand + 0.5);
          } else {
            x = (winSize.width / 2 - bubble.getComponent(UITransform).contentSize.width / 2) * (rand - 0.5);
          }
          let y = 0 - winSize.height / 2;
          bubble.setPosition(x, y, 0);
          this.bubbleList.push(bubble);
          bubble.getComponent(DriftBubble).startMove();
        }
        createBubbleWithDelay(delay) {
          this.scheduleOnce(this.createBubble, delay);
          this.canCreateBubble = false;
        }
        removeBubble(bubble) {
          bubble.off(Node.EventType.TOUCH_START);
          bubble.getComponent(DriftBubble).stopMove();
          let index = this.bubbleList.indexOf(bubble);
          this.bubbleList.splice(index, 1);
          if (this.bubblePool.size() >= this.poolSizeLimit) {
            bubble.destroy();
            return;
          }
          this.bubblePool.put(bubble);
          this.canCreateBubble = true;
        }
      }, _descriptor = _applyDecoratedDescriptor(_class2.prototype, "prfbDriftBubble", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/union-fetch-agent.ts", ['cc', './config.ts', './game-data-manager.ts', './reward-manager.ts', './time-agent.ts', './request-manager.ts', './log-util.ts', './config-agent.ts', './data-agent.ts', './storage-manager.ts'], function (exports) {
  var cclegacy, Config, GameDataManager, RewardManager, TimeAgent, ReqeustManager, LogUtil, ConfigAgent, ConfigType, DataType, DataAgent, StorageManager;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      RewardManager = module.RewardManager;
    }, function (module) {
      TimeAgent = module.TimeAgent;
    }, function (module) {
      ReqeustManager = module.ReqeustManager;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      ConfigAgent = module.ConfigAgent;
      ConfigType = module.ConfigType;
    }, function (module) {
      DataType = module.DataType;
      DataAgent = module.DataAgent;
    }, function (module) {
      StorageManager = module.StorageManager;
    }],
    execute: function () {
      cclegacy._RF.push({}, "304fey0KSBBIYSZl9zAnjMK", "union-fetch-agent", undefined);
      class UnionFetchAgent {
        /*
        需要notify的数据（一般是bundle），再保存到数据后，再notify
        主包里面使用的数据，直接init即可
        */
        static fetchUnionData() {
          const uid = StorageManager.instance.getUid();
          return new Promise((resolve, reject) => {
            ReqeustManager.instance.post(`/union/fetch/${uid}?debug=${Config.DEBUG}`, {
              code: Config.GAME_CODE,
              version: Config.GAME_VERSION
            }).then(data => {
              if (data['ret'] == 0) {
                // parse preset data
                const presetData = data['preset'];
                if (presetData) {
                  const presetPayload = presetData['payload'];
                  if (Array.isArray(presetPayload) && presetPayload.length > 0) {
                    for (const item of presetPayload) {
                      const category = item['category'];
                      const config = item;
                      ConfigAgent.saveRawConfig(category, config);
                      if (category == ConfigType.Main) {
                        RewardManager.instance.initConfig(ConfigAgent.getConfig(ConfigType.Main));
                      }
                    }
                  }
                }

                // parse game data
                const playerData = data['player'];
                if (playerData) {
                  if (playerData['now']) {
                    const serverTime = playerData['now'];
                    if (!!serverTime && serverTime > 0) {
                      TimeAgent.instance.setServerTime(serverTime);
                    }
                    const savePlayerData = {
                      sid: playerData['sid'] || '',
                      major: playerData['tokenMajor'] || 0,
                      minor: playerData['tokenMinor'] || 0
                    };
                    if (playerData[DataType.Game]) {
                      const gameData = JSON.parse(playerData[DataType.Game]);
                      GameDataManager.instance.initDataFromServer(gameData, savePlayerData);
                      DataAgent.saveData(DataType.Game, gameData);
                    }
                    if (playerData[DataType.Gain]) {
                      const gainData = JSON.parse(playerData[DataType.Gain]);
                      DataAgent.saveData(DataType.Gain, gainData);
                    }
                    DataAgent.saveData(DataType.Player, savePlayerData);
                  }
                }
              }
              resolve();
            }).catch(error => {
              LogUtil.error('error fetchUnionData:', error);
              // slient
              resolve();
            });
          });
        }
      }
      exports('UnionFetchAgent', UnionFetchAgent);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/VBWBHDOLKCQNA.ts", ['cc', './SVDMRMIFJDYHRX.ts', './AQKTRMDQJQQBTDC.ts', './PQBRALKRA.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, AQKTRMDQJQQBTDC, PQBRALKRA;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      PQBRALKRA = module.PQBRALKRA;
    }],
    execute: function () {
      cclegacy._RF.push({}, "9e5aae5JT9Ew7oPh05vlmZo", "VBWBHDOLKCQNA", undefined);
      class VBWBHDOLKCQNA extends SVDMRMIFJDYHRX {
        TGQXAKDAHFFVG() {}
        QIZLFVUQ() {}

        /**
         * bi日志统计。注意，使用前的所有事件名和属性名必须找我们登记。
         * @param NUZZOGPJXH 事件名token
         * @param XPQDBGOMWCUIFIW 属性集（可选），这里属性值只支持：字符串、数字、布尔
         */
        OASGKQN(NUZZOGPJXH, XPQDBGOMWCUIFIW = null) {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          let commonEventValue = {
            "event_name": NUZZOGPJXH
          };
          if (XPQDBGOMWCUIFIW != null) {
            commonEventValue["properties"] = XPQDBGOMWCUIFIW;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().OASGKQN(commonEventValue);
        }

        /**
         * @param GZVOGYPEIBFU 事件名
         * @param XPQDBGOMWCUIFIW 属性集（可选）, 这里属性值支持  "revenue" 传 "revenue" 作为key(收益)  "currency" 传 "currency" 作为key(货币单位) "orderId" 传 "orderId" 作为key(订单号)
         */
        AOCSJNKXYWTDOOV(GZVOGYPEIBFU, XPQDBGOMWCUIFIW = null) {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().PQGKDUTERGR(1, GZVOGYPEIBFU, XPQDBGOMWCUIFIW);
        }

        /**
         * @param GZVOGYPEIBFU 事件名
         * @param XPQDBGOMWCUIFIW 属性集（可选）
         */
        ZMEFLJD(GZVOGYPEIBFU, XPQDBGOMWCUIFIW = null) {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().PQGKDUTERGR(2, GZVOGYPEIBFU, XPQDBGOMWCUIFIW);
        }

        /**
         * @param GZVOGYPEIBFU 事件名
         * @param XPQDBGOMWCUIFIW 属性集（可选）
         */
        DDNQLMDLUZVDJNUD(GZVOGYPEIBFU, XPQDBGOMWCUIFIW = null) {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().PQGKDUTERGR(3, GZVOGYPEIBFU, XPQDBGOMWCUIFIW);
        }
      }
      exports('VBWBHDOLKCQNA', VBWBHDOLKCQNA);
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/version-example.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './version-manager.ts', './front-line.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Label, _decorator, Component, VersionManager, FrontLine;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Label = module.Label;
      _decorator = module._decorator;
      Component = module.Component;
    }, function (module) {
      VersionManager = module.VersionManager;
    }, function (module) {
      FrontLine = module.FrontLine;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _class, _class2, _descriptor, _descriptor2;
      cclegacy._RF.push({}, "7b92djg4ItEu5Z33L4fqi6D", "version-example", undefined);
      const {
        ccclass,
        property
      } = _decorator;

      /**
       * 版本信息显示组件示例
       * 展示如何使用VersionManager和FrontLine的getVersion方法
       */
      let VersionExample = exports('VersionExample', (_dec = ccclass('VersionExample'), _dec2 = property(Label), _dec3 = property(Label), _dec(_class = (_class2 = class VersionExample extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "versionLabel", _descriptor, this);
          _initializerDefineProperty(this, "statusLabel", _descriptor2, this);
        }
        onLoad() {
          this.displayVersionInfo();
        }

        /**
         * 显示版本信息
         */
        displayVersionInfo() {
          // 方法1：使用VersionManager（推荐）
          const versionInfo = VersionManager.getVersionInfo();
          console.log('VersionExample: 版本信息', versionInfo);
          if (this.versionLabel) {
            this.versionLabel.string = `版本: ${VersionManager.formatVersion(versionInfo.version)}`;
          }
          if (this.statusLabel) {
            const status = versionInfo.isHotUpdated ? '热更新版本' : '本地版本';
            this.statusLabel.string = `状态: ${status}`;
          }

          // 方法2：使用FrontLine的getVersion方法
          const frontLine = this.node.getComponent(FrontLine);
          if (frontLine) {
            const frontLineVersion = frontLine.getVersion();
            console.log('VersionExample: FrontLine版本号', frontLineVersion);
          }

          // 示例：版本比较
          this.compareVersionExample();
        }

        /**
         * 版本比较示例
         */
        compareVersionExample() {
          const currentVersion = VersionManager.getCurrentVersion();
          const testVersions = ['1.0.0', '1.0.1', '1.1.0', '2.0.0'];
          console.log('VersionExample: 版本比较示例');
          testVersions.forEach(testVersion => {
            const result = VersionManager.compareVersions(currentVersion, testVersion);
            let comparison = '';
            if (result < 0) comparison = '小于';else if (result > 0) comparison = '大于';else comparison = '等于';
            console.log(`当前版本 ${currentVersion} ${comparison} ${testVersion}`);
          });
        }

        /**
         * 检查新版本示例
         */
        async checkNewVersionExample() {
          console.log('VersionExample: 开始检查新版本...');
          try {
            const hasNewVersion = await VersionManager.checkForNewVersion('https://example.com/version.manifest');
            if (hasNewVersion) {
              console.log('VersionExample: 发现新版本');
              if (this.statusLabel) {
                this.statusLabel.string = '状态: 发现新版本';
              }
            } else {
              console.log('VersionExample: 已是最新版本');
              if (this.statusLabel) {
                this.statusLabel.string = '状态: 已是最新版本';
              }
            }
          } catch (error) {
            console.error('VersionExample: 检查新版本失败', error);
            if (this.statusLabel) {
              this.statusLabel.string = '状态: 检查失败';
            }
          }
        }

        /**
         * 获取详细版本信息
         */
        getDetailedVersionInfo() {
          const versionInfo = VersionManager.getVersionInfo();
          console.log('VersionExample: 详细版本信息');
          console.log('- 版本号:', versionInfo.version);
          console.log('- 是否热更新:', versionInfo.isHotUpdated);
          console.log('- 更新时间:', versionInfo.updateTime ? new Date(versionInfo.updateTime).toLocaleString() : '无');
          console.log('- 版本格式验证:', VersionManager.isValidVersion(versionInfo.version));

          // 显示在界面上
          if (this.versionLabel) {
            const formattedVersion = VersionManager.formatVersion(versionInfo.version);
            const updateTime = versionInfo.updateTime ? new Date(versionInfo.updateTime).toLocaleString() : '无';
            this.versionLabel.string = `${formattedVersion}\n更新时间: ${updateTime}`;
          }
        }

        /**
         * 按钮点击事件示例
         */
        onRefreshVersionClick() {
          console.log('VersionExample: 刷新版本信息');
          this.displayVersionInfo();
        }
        onCheckNewVersionClick() {
          console.log('VersionExample: 检查新版本');
          this.checkNewVersionExample();
        }
        onShowDetailedInfoClick() {
          console.log('VersionExample: 显示详细信息');
          this.getDetailedVersionInfo();
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "versionLabel", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "statusLabel", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/version-manager.ts", ['cc'], function (exports) {
  var cclegacy, native, sys;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
      native = module.native;
      sys = module.sys;
    }],
    execute: function () {
      cclegacy._RF.push({}, "928f0ELgzVDB6i2AUIwxibV", "version-manager", undefined);

      /**
       * 版本管理工具类
       * 用于管理热更新后的版本信息
       */
      class VersionManager {
        /**
         * 获取当前版本号
         * 优先从热更新后的version.manifest文件读取，如果不存在则从本地读取
         */
        static getCurrentVersion() {
          try {
            // 获取可写路径下的version.manifest文件路径
            const storagePath = native.fileUtils.getWritablePath() + this.STORAGE_FOLDER_NAME;
            const versionManifestPath = storagePath + '/version.manifest';
            console.log(`VersionManager: 尝试读取热更新版本文件 ${versionManifestPath}`);

            // 检查热更新版本文件是否存在
            if (native.fileUtils.isFileExist(versionManifestPath)) {
              const fileContent = native.fileUtils.getStringFromFile(versionManifestPath);
              if (fileContent) {
                const manifestData = JSON.parse(fileContent);
                const version = manifestData.version;
                console.log(`VersionManager: 热更新版本号 ${version}`);

                // 保存到本地存储
                this.saveVersionToStorage(version);
                return version;
              }
            }

            // 如果热更新版本不存在，尝试从本地存储读取
            const storedVersion = this.getVersionFromStorage();
            if (storedVersion) {
              console.log(`VersionManager: 从本地存储读取版本号 ${storedVersion}`);
              return storedVersion;
            }

            // 如果都没有，返回默认版本
            console.log(`VersionManager: 使用默认版本号 ${this.DEFAULT_VERSION}`);
            return this.DEFAULT_VERSION;
          } catch (error) {
            console.error('VersionManager: 获取版本号失败', error);
            return this.DEFAULT_VERSION;
          }
        }

        /**
         * 检查是否有新版本可用
         * @param remoteVersionUrl 远程版本文件URL
         * @returns Promise<boolean> 是否有新版本
         */
        static async checkForNewVersion(remoteVersionUrl) {
          try {
            const currentVersion = this.getCurrentVersion();
            console.log(`VersionManager: 当前版本 ${currentVersion}，检查远程版本...`);

            // 这里可以实现远程版本检查逻辑
            // 由于需要网络请求，这里只是示例框架
            // 实际实现可以使用XMLHttpRequest或fetch

            return false; // 暂时返回false，表示没有新版本
          } catch (error) {
            console.error('VersionManager: 检查新版本失败', error);
            return false;
          }
        }

        /**
         * 比较两个版本号
         * @param versionA 版本A
         * @param versionB 版本B
         * @returns number 比较结果：-1表示A<B，0表示A=B，1表示A>B
         */
        static compareVersions(versionA, versionB) {
          const vA = versionA.split('.');
          const vB = versionB.split('.');
          for (let i = 0; i < Math.max(vA.length, vB.length); i++) {
            const a = parseInt(vA[i] || '0');
            const b = parseInt(vB[i] || '0');
            if (a < b) return -1;
            if (a > b) return 1;
          }
          return 0;
        }

        /**
         * 获取版本信息对象
         * @returns 包含版本信息的对象
         */
        static getVersionInfo() {
          const version = this.getCurrentVersion();
          const storagePath = native.fileUtils.getWritablePath() + this.STORAGE_FOLDER_NAME;
          const versionManifestPath = storagePath + '/version.manifest';
          const isHotUpdated = native.fileUtils.isFileExist(versionManifestPath);
          return {
            version,
            isHotUpdated,
            updateTime: isHotUpdated ? this.getLastUpdateTime() : undefined
          };
        }

        /**
         * 保存版本号到本地存储
         */
        static saveVersionToStorage(version) {
          try {
            sys.localStorage.setItem(this.VERSION_KEY, version);
            console.log(`VersionManager: 版本号已保存到本地存储 ${version}`);
          } catch (error) {
            console.error('VersionManager: 保存版本号到本地存储失败', error);
          }
        }

        /**
         * 从本地存储读取版本号
         */
        static getVersionFromStorage() {
          try {
            return sys.localStorage.getItem(this.VERSION_KEY);
          } catch (error) {
            console.error('VersionManager: 从本地存储读取版本号失败', error);
            return null;
          }
        }

        /**
         * 获取最后更新时间
         */
        static getLastUpdateTime() {
          try {
            const timestamp = sys.localStorage.getItem('hot_update_timestamp');
            return timestamp ? parseInt(timestamp) : undefined;
          } catch (error) {
            console.error('VersionManager: 获取最后更新时间失败', error);
            return undefined;
          }
        }

        /**
         * 格式化版本号显示
         * @param version 版本号
         * @returns 格式化后的版本号字符串
         */
        static formatVersion(version) {
          return `v${version}`;
        }

        /**
         * 验证版本号格式
         * @param version 版本号
         * @returns 是否为有效的版本号格式
         */
        static isValidVersion(version) {
          const versionPattern = /^\d+\.\d+\.\d+$/;
          return versionPattern.test(version);
        }
      }
      exports('VersionManager', VersionManager);
      VersionManager.STORAGE_FOLDER_NAME = 'front_line';
      VersionManager.VERSION_KEY = 'current_version';
      VersionManager.DEFAULT_VERSION = '1.0.0';
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/victory-popup.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './ui-view.ts', './ui-manager.ts', './string-util.ts', './game-data-manager.ts', './reward-type-define.ts', './reward-manager.ts', './ui-config.ts', './res-util.ts', './mount-manager.ts', './config.ts', './ad-manager.ts', './audio-manager.ts', './game-constants.ts', './log-util.ts', './bridge-util.ts', './report-agent.ts', './mount-point.ts', './game-data-type-define.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Label, Node, Sprite, _decorator, ParticleSystem2D, assetManager, SpriteFrame, director, UIView, UIManager, StringUtil, GameDataManager, ItemType, RewardManager, UIID, ResUtil, MountManager, Config, AdManager, AudioManager, AudioUrl, LogUtil, BridgeUtil, VibrationEffect, ReportAgent, CustomReportEvent, PageName, BtnName, MountPoint, SgState;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Label = module.Label;
      Node = module.Node;
      Sprite = module.Sprite;
      _decorator = module._decorator;
      ParticleSystem2D = module.ParticleSystem2D;
      assetManager = module.assetManager;
      SpriteFrame = module.SpriteFrame;
      director = module.director;
    }, function (module) {
      UIView = module.UIView;
    }, function (module) {
      UIManager = module.UIManager;
    }, function (module) {
      StringUtil = module.StringUtil;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      ItemType = module.ItemType;
    }, function (module) {
      RewardManager = module.RewardManager;
    }, function (module) {
      UIID = module.UIID;
    }, function (module) {
      ResUtil = module.ResUtil;
    }, function (module) {
      MountManager = module.MountManager;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      AdManager = module.AdManager;
    }, function (module) {
      AudioManager = module.AudioManager;
    }, function (module) {
      AudioUrl = module.AudioUrl;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      BridgeUtil = module.BridgeUtil;
      VibrationEffect = module.VibrationEffect;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
      PageName = module.PageName;
      BtnName = module.BtnName;
    }, function (module) {
      MountPoint = module.MountPoint;
    }, function (module) {
      SgState = module.SgState;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _dec6, _dec7, _dec8, _dec9, _dec10, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4, _descriptor5, _descriptor6, _descriptor7, _descriptor8, _descriptor9;
      cclegacy._RF.push({}, "74ee9Max55JT6LGYRB339nR", "victory-popup", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let VictoryPopup = exports('VictoryPopup', (_dec = ccclass('VictoryPopup'), _dec2 = property(Label), _dec3 = property(Label), _dec4 = property(Node), _dec5 = property(Label), _dec6 = property(Label), _dec7 = property(Label), _dec8 = property(Sprite), _dec9 = property(Node), _dec10 = property(Node), _dec(_class = (_class2 = class VictoryPopup extends UIView {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "lblScore", _descriptor, this);
          _initializerDefineProperty(this, "lblBestScore", _descriptor2, this);
          _initializerDefineProperty(this, "minorToken", _descriptor3, this);
          _initializerDefineProperty(this, "lblTokenAmount", _descriptor4, this);
          _initializerDefineProperty(this, "lblFragmentAmount", _descriptor5, this);
          _initializerDefineProperty(this, "lblGetBtn", _descriptor6, this);
          _initializerDefineProperty(this, "sprdTool", _descriptor7, this);
          _initializerDefineProperty(this, "closeBtn", _descriptor8, this);
          _initializerDefineProperty(this, "celabrate", _descriptor9, this);
          this.url = '';
          this.toolId = void 0;
          this.tokenId = void 0;
          this.tokenAmount = void 0;
          this.fragmentAmount = void 0;
        }
        onOpen(fromUI, ...args) {
          AudioManager.instance.playEffect(AudioUrl.SHOW_VICTORY);
          if (GameDataManager.instance.data.firstGameAction.victory_popup) {
            GameDataManager.instance.data.firstGameAction.victory_popup = false;
            ReportAgent.reportCustomEvent(CustomReportEvent.USER_LIFECYCLE_MILESTONE, {
              action: 'victory_first'
            });
          }

          // page action report
          ReportAgent.reportCustomEvent(CustomReportEvent.PAGE_BUTTON_ACTION, {
            page: PageName.LevelWin,
            btn: BtnName.Close,
            action: 'show'
          });
          ReportAgent.reportCustomEvent(CustomReportEvent.PAGE_BUTTON_ACTION, {
            page: PageName.LevelWin,
            btn: BtnName.Get,
            action: 'show'
          });
          this.scheduleOnce(() => {
            this.celabrate.active = true;
            this.celabrate.getComponent(ParticleSystem2D).resetSystem();
          }, 0.3);
          this.closeBtn.active = false;
          this.scheduleOnce(() => {
            this.closeBtn.active = true;
          }, 1);
          BridgeUtil.vibrate(30, VibrationEffect.CLICK);
          let data = args[0];
          let score = data.score;
          let gdMgr = GameDataManager.instance;
          this.lblScore.string = StringUtil.timeFormat(score, false);
          this.lblBestScore.string = StringUtil.timeFormat(gdMgr.data.bestTime, false);

          // token
          // 是否激励用户
          let showMajor = Config.FULL_MODE;
          this.minorToken.active = !showMajor;
          this.tokenId = ItemType.MinorToken;
          this.tokenAmount = RewardManager.instance.getRewardAmountWithItemId(this.tokenId);
          this.lblTokenAmount.string = showMajor ? `${gdMgr.getCurrency()}${this.tokenAmount}` : `x${this.tokenAmount}`;
          if (GameDataManager.instance.sg.state === SgState.Started) {
            this.lblFragmentAmount.node.parent.active = false;
          }
          ReportAgent.reportCustomEvent(CustomReportEvent.AD_EVENT_DISTRIBUTED, {
            reward_page_show: 'victory_reward'
          });
          let multiple = RewardManager.instance.getConfig().ad.reward_multiple;
          this.lblGetBtn.string = multiple == 1 ? `Get` : `Get*${multiple}`;

          // tool or fragment
          this.toolId = ItemType.Fragment;
          let bundleSg = assetManager.getBundle('bundle-sg');
          bundleSg.load('texture/common/icon-fragment-b/spriteFrame', SpriteFrame, (err, frame) => {
            this.sprdTool.spriteFrame = frame;
            ResUtil.assignWith(frame, this.node, true);
          });
        }
        onClose() {
          GameDataManager.instance.saveData(true);
        }
        onCloseBtn() {
          this.onClickBtn();
          ReportAgent.reportCustomEvent(CustomReportEvent.PAGE_BUTTON_ACTION, {
            page: PageName.LevelWin,
            btn: BtnName.Close,
            action: 'click'
          });
          if (GameDataManager.instance.sg.state === SgState.Started) {
            let isOpenInter = false;
            let config = RewardManager.instance.getConfig();
            console.log(`config: ${config}`);
            if (config) {
              let info = config.ad.inter.page.victory_reward;
              console.log(`info: ${JSON.stringify(info)}`);
              GameDataManager.instance.data.interAdWeight += info.weight;
              isOpenInter = info.is_play;
            }
            console.log(`isOpenInter: ${isOpenInter}`);
            if (isOpenInter) {
              AdManager.instance.openInterstitialAd('victory_reward', null);
            }
          }
          this.doGetReward(false);
        }
        onGetBtn() {
          this.onClickBtn();
          ReportAgent.reportCustomEvent(CustomReportEvent.PAGE_BUTTON_ACTION, {
            page: PageName.LevelWin,
            btn: BtnName.Get,
            action: 'click'
          });
          ReportAgent.reportCustomEvent(CustomReportEvent.AD_EVENT_DISTRIBUTED, {
            reward_page_click: 'victory_reward'
          });
          AdManager.instance.openVideoAd('VictoryPopup', (entry, success) => {
            console.log(`openVideoAd-entry:${entry}-success:${success}`);
            if (success) {
              console.log(`openVideoAd-success 1111`);
              this.doGetReward(true);
            }
          });
        }
        doGetReward(isAd = false) {
          let multiple = isAd ? RewardManager.instance.getConfig().ad.reward_multiple : 1;
          UIManager.instance.close(this);
          if (GameDataManager.instance.sg.state === SgState.Started) {
            // sg album disable, fragment disable
            UIManager.instance.open(UIID.RewardGetPopup, {
              token_amount: this.tokenAmount * multiple,
              fragment_amount: 0
            });
          }
        }
        backToStart() {
          UIManager.instance.closeAll();
          if (GameDataManager.instance.sg.state === SgState.Started) {
            director.loadScene('map-sg');
          }
        }
        showPictureObtainPopup() {
          let picInfo = GameDataManager.instance.data.selectedSgPicture;
          if (!picInfo) {
            this.backToStart();
            return;
          }
          let sprB = MountManager.instance.notify(MountPoint.NativeNotifyLoadPicture, {
            infoList: [picInfo],
            type: 4
          })[0];
          LogUtil.log(`getOriginalSpf-urlB:${sprB}`);
          UIManager.instance.open(UIID.PictureObtainPopup, {
            albumId: null,
            picInfo: picInfo,
            showCloseBtn: true,
            isCloseDirectly: false
          });
        }
        onClickBtn() {
          AudioManager.instance.playEffect(AudioUrl.BTN_CLICK);
          BridgeUtil.vibrate(30, VibrationEffect.TICK);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "lblScore", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "lblBestScore", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "minorToken", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "lblTokenAmount", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor5 = _applyDecoratedDescriptor(_class2.prototype, "lblFragmentAmount", [_dec6], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor6 = _applyDecoratedDescriptor(_class2.prototype, "lblGetBtn", [_dec7], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor7 = _applyDecoratedDescriptor(_class2.prototype, "sprdTool", [_dec8], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor8 = _applyDecoratedDescriptor(_class2.prototype, "closeBtn", [_dec9], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor9 = _applyDecoratedDescriptor(_class2.prototype, "celabrate", [_dec10], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/WBKIRV.ts", ['cc'], function (exports) {
  var cclegacy;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }],
    execute: function () {
      cclegacy._RF.push({}, "7a206rrF+lP77sKs0uxtOQJ", "WBKIRV", undefined);
      /**
       * @author : jinshui
       * @date   : 2024/6/3 0003 22:23
       */

      class WBKIRV {}
      exports('WBKIRV', WBKIRV);
      class KOOVAFDJSB {}
      exports('KOOVAFDJSB', KOOVAFDJSB);
      KOOVAFDJSB.WTPEMNO = "init";
      KOOVAFDJSB.IUVEANIFARSRGVJN = "videoTouchAction";
      KOOVAFDJSB.LHAKYKQVTTJC = "isReadyVideoAd";
      KOOVAFDJSB.WUMMTYU = "openVideoAd";
      KOOVAFDJSB.PYQUCSIIH = "isReadyInterstitialAd";
      KOOVAFDJSB.XOUECKSDJND = "openInterstitialAd";
      KOOVAFDJSB.JLRWRON = "openBannerAd";
      KOOVAFDJSB.WCTLPPBLHMRT = "closeBannerAd";
      KOOVAFDJSB.WBZHMHO = "isReadyAppOpenAd";
      KOOVAFDJSB.UENVUHZR = "openAppOpenAd";
      KOOVAFDJSB.OASGKQN = "commonEventReport";
      KOOVAFDJSB.PQGKDUTERGR = "logThirdEvent";
      KOOVAFDJSB.EBZYRKYXFPTJCTAV = "showMediationDebugger";
      KOOVAFDJSB.MRVQRTO = "openAppInGp";
      KOOVAFDJSB.COUYOLVIRRJBJ = "openWebOnBrowser";
      KOOVAFDJSB.ZZASVTSP = "queryCommonData";
      KOOVAFDJSB.SGSRFUYPNBYVAVKD = "countryLanguageCode";
      KOOVAFDJSB.JVXAKJXPKZRFU = "countryCode";
      KOOVAFDJSB.OEASROCHK = "ipCountryCode";
      KOOVAFDJSB.QUDSVNDFTRJ = "isNetworkAvailable";
      KOOVAFDJSB.NHSMDBRFZHTIBM = "IDFA";
      KOOVAFDJSB.YMWMKBGRWOKXYJ = "deviceID";
      KOOVAFDJSB.OCRYJGTMMSYJCC = "attribution";
      KOOVAFDJSB.SGBOHXNFGG = "setLogcatEnable";
      KOOVAFDJSB.BJYHQFJF = "getCpConfig";
      KOOVAFDJSB.RFFCNTYYDMN = "requestHttp";
      KOOVAFDJSB.UZSJLDEBYEZI = "showNewbyearIconAd";
      KOOVAFDJSB.BLERBUWYZ = "hideNewbyearIconAd";
      KOOVAFDJSB.GMKDDMWDSNPUI = "isBillingInitSuccess";
      KOOVAFDJSB.MSNKSNM = "launchBillingFlow";
      KOOVAFDJSB.RRUWUVYQ = "consumeBillingIapPurchase";
      KOOVAFDJSB.NMZERFYOQXXOW = "contactService";
      KOOVAFDJSB.QQCBWIIBSGJMZXXV = "getFaqUrl";
      class PSWZDFV {}
      exports('PSWZDFV', PSWZDFV);
      PSWZDFV.GGOEUNELMFVB = "onTheme";
      PSWZDFV.NPQULXODN = "onSplashStart";
      PSWZDFV.ARRVSYWBB = "onSplashClick";
      PSWZDFV.RYODTT = "onSplashClose";
      PSWZDFV.UUPFZKPXSEPHGAUI = "onVideoStart";
      PSWZDFV.NUVJWDOUNYDWG = "onVideoClose";
      PSWZDFV.WASOVBLBVPPJBHMG = "onVideoClick";
      PSWZDFV.GKDTHXPMZJTYHU = "onVideoComplete";
      PSWZDFV.TGDSIXDAK = "onInterstitialStart";
      PSWZDFV.NQRUAAO = "onInterstitialClick";
      PSWZDFV.ZORHXXXEEY = "onInterstitialClose";
      PSWZDFV.KVAVBPMGBHGOW = "onCustomPushMsg";
      PSWZDFV.MMLLYDABTL = "onCustomRequestMsg";
      PSWZDFV.XWFUQTQPSCVLJYL = "onAdRevenue";
      PSWZDFV.XWBOGKTXZNC = "onLaunchAppCallBack";
      PSWZDFV.XXGFAIDUZP = "onBannerStart";
      PSWZDFV.WXLRAMSMF = "onBannerClick";
      PSWZDFV.UVFJIQCIL = "onBannerClose";
      PSWZDFV.TRCAMWXHVKVILMO = "onInviteCode";
      PSWZDFV.DHLOALGFTSBMQN = "onCpClient";
      PSWZDFV.LQOAQXAMP = "onResponseMsg";
      PSWZDFV.GBWCLMQUYDVKUKG = "onIconAdImpression";
      PSWZDFV.MLFWMEZHCWEUHV = "onIconAdClick";
      PSWZDFV.WQVUMO = "onBillingIapItemDetails";
      PSWZDFV.ONGWOOBCA = "onBillingIapUnconsumedItemUpdated";
      PSWZDFV.GVZGWMMHXJEWOSEP = "onBillingSubscribeItemDetails";
      PSWZDFV.UVNOCVGJE = "onBillingSubscribeUpdated";
      PSWZDFV.EDCXLSSJLQY = "onUrl";
      PSWZDFV.TNYZKNTMXF = "onMessageCount";
      PSWZDFV.XPKYYNPOMINMUX = "postNotificationCustomData";
      class PDWTAEXGRLKYCOL {}
      exports('PDWTAEXGRLKYCOL', PDWTAEXGRLKYCOL);
      PDWTAEXGRLKYCOL.LQOPZECGDFETBH = "a2g";
      PDWTAEXGRLKYCOL.NOVARZNASXIXIL = "invite";
      PDWTAEXGRLKYCOL.EBRVJXLSPJUZ = "video";
      PDWTAEXGRLKYCOL.QAWGKUNMWHJHXKY = "interstitial";
      PDWTAEXGRLKYCOL.XMJPJJJEHC = "banner";
      PDWTAEXGRLKYCOL.AQSQVVWGMOVHR = "splash";
      PDWTAEXGRLKYCOL.CZLGMGUCADMLDG = "userInfo";
      PDWTAEXGRLKYCOL.JEKILZGLT = "gameTool";
      PDWTAEXGRLKYCOL.QQUEEYIFYIE = "events";
      PDWTAEXGRLKYCOL.CEZHDRFCMQDJNJEA = "special";
      PDWTAEXGRLKYCOL.NFEEMYOAWPHOKYKV = "theme";
      PDWTAEXGRLKYCOL.JDWTMRORCA = "config";
      PDWTAEXGRLKYCOL.XFPIWEXSB = "customHttp";
      PDWTAEXGRLKYCOL.QGCJSY = "newbyear";
      PDWTAEXGRLKYCOL.YHMSAUTGPWRWUI = "mobplubs";
      PDWTAEXGRLKYCOL.ZVTVOUVPFTQBZVBN = "billing";
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/welcome-hf-A.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './front-line.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, ProgressBar, Label, _decorator, Component, profiler, sys, director, FrontLine, FrontLineEvent, HOT_UPDATE_TIMESTAMP, HOT_UPDATE_TIME_COST;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      ProgressBar = module.ProgressBar;
      Label = module.Label;
      _decorator = module._decorator;
      Component = module.Component;
      profiler = module.profiler;
      sys = module.sys;
      director = module.director;
    }, function (module) {
      FrontLine = module.FrontLine;
      FrontLineEvent = module.FrontLineEvent;
      HOT_UPDATE_TIMESTAMP = module.HOT_UPDATE_TIMESTAMP;
      HOT_UPDATE_TIME_COST = module.HOT_UPDATE_TIME_COST;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _class, _class2, _descriptor, _descriptor2, _descriptor3;
      cclegacy._RF.push({}, "e4aea4Ab2BI2K7U5K18jWoJ", "welcome-hf-A", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let WelcomeHfA = exports('WelcomeHfA', (_dec = ccclass('WelcomeHfA'), _dec2 = property(ProgressBar), _dec3 = property(Label), _dec4 = property(Label), _dec(_class = (_class2 = class WelcomeHfA extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "progressBar", _descriptor, this);
          _initializerDefineProperty(this, "lblProgress", _descriptor2, this);
          _initializerDefineProperty(this, "lblLoading", _descriptor3, this);
          this.HOT_UPDATE_THRESHOLD = 5 * 60 * 1000;
        }
        // 5分钟内的更新认为是刚更新过

        onLoad() {
          profiler.hideStats();
          this.progressBar.progress = 0;
          this.lblProgress.string = '0%';
          console.log('OjaiTest-welcome-hf-onloaded');
          // 检查是否刚进行过热更新
          if (this.isRecentlyUpdated()) {
            console.log('OjaiTest-检测到最近刚进行过热更新，直接进入游戏');
            this.enterNext();
            return;
          }

          // 获取并记录当前版本号
          const frontLine = this.node.getComponent(FrontLine);
          if (frontLine) {
            frontLine.logCurrentVersion();
          }

          // 发起热更新检查
          this.startHotUpdate();
        }
        start() {
          this.updateLoadingLabel();
        }
        onEnable() {
          this.node.on(FrontLineEvent.UPDATE_PROGRESS, this.updateProgress, this);
          this.node.on(FrontLineEvent.UPDATE_SUCCESS, this.onUpdateSuccess, this);
          this.node.on(FrontLineEvent.UPDATE_FAILED, this.onUpdateFailed, this);
          this.node.on(FrontLineEvent.ALREADY_UP_TO_DATE, this.onAlreadyUpToDate, this);
          this.node.on(FrontLineEvent.UPDATE_ERROR, this.onUpdateError, this);
        }
        onDisable() {
          this.node.off(FrontLineEvent.UPDATE_PROGRESS, this.updateProgress, this);
          this.node.off(FrontLineEvent.UPDATE_SUCCESS, this.onUpdateSuccess, this);
          this.node.off(FrontLineEvent.UPDATE_FAILED, this.onUpdateFailed, this);
          this.node.off(FrontLineEvent.ALREADY_UP_TO_DATE, this.onAlreadyUpToDate, this);
          this.node.off(FrontLineEvent.UPDATE_ERROR, this.onUpdateError, this);
        }

        /**
         * 检查是否最近刚进行过热更新
         */
        isRecentlyUpdated() {
          const lastUpdateTime = sys.localStorage.getItem(HOT_UPDATE_TIMESTAMP);
          if (!lastUpdateTime) {
            return false;
          }
          const timestamp = parseInt(lastUpdateTime);
          const currentTime = Date.now();
          const timeDiff = currentTime - timestamp;
          console.log(`OjaiTest-距离上次更新时间: ${timeDiff}ms`);
          return timeDiff < this.HOT_UPDATE_THRESHOLD;
        }

        /**
         * 记录热更新时间
         */
        recordUpdateTime() {
          sys.localStorage.setItem(HOT_UPDATE_TIMESTAMP, Date.now().toString());
          console.log('OjaiTest-记录热更新时间');
        }

        /**
         * 开始热更新流程
         */
        startHotUpdate() {
          const frontLine = this.node.getComponent(FrontLine);
          if (!frontLine) {
            console.error('OjaiTest-FrontLine组件未找到');
            this.enterNext();
            return;
          }

          // only update from 1.0.0 to 1.0.1
          if (frontLine.getVersion() != 'v1.0.0') {
            this.enterNext();
            return;
          }
          let startTime = Date.now();
          console.log('OjaiTest-开始热更新检查');
          frontLine.start((success, message) => {
            if (success) {
              console.log('OjaiTest-热更新成功');
              let endTime = Date.now();
              console.log(`OjaiTest-热更新成功，耗时：${endTime - startTime}ms`);
              sys.localStorage.setItem(HOT_UPDATE_TIME_COST, ((endTime - startTime) / 1000).toFixed(2));
            } else {
              console.log('OjaiTest-热更新失败', message);
              this.enterNext();
            }
          });
        }

        /**
         * 更新进度回调
         */
        updateProgress(progress) {
          this.progressBar.progress = progress;
          this.lblProgress.string = `${Math.floor(progress * 100)}%`;
        }

        /**
         * 热更新成功回调
         */
        onUpdateSuccess() {
          console.log('OjaiTest-热更新成功，准备重启游戏');
          this.recordUpdateTime();
          // 重启游戏，会重新回到这个场景
          // 注意：game.restart() 会在 front-line.ts 的 onUpdateSuccess 中被调用
        }

        /**
         * 热更新失败回调
         */
        onUpdateFailed() {
          console.log('OjaiTest-热更新失败，继续进入游戏');
          this.enterNext();
        }

        /**
         * 已经是最新版本回调
         */
        onAlreadyUpToDate() {
          console.log('OjaiTest-已经是最新版本，直接进入游戏');
          this.enterNext();
        }

        /**
         * 热更新错误回调
         */
        onUpdateError() {
          console.log('OjaiTest-热更新出错，继续进入游戏');
          this.enterNext();
        }

        /**
         * 进入游戏主场景
         */
        enterNext() {
          console.log('OjaiTest-进入下一个场景');
          // 根据配置决定进入哪个场景
          director.loadScene('welcome-hf-B');
        }

        /**
         * 开始显示hello world动画，每隔1秒增加一个点，最多3个点，然后循环
         */
        updateLoadingLabel() {
          //每隔1s 变化一个点 需要循环
          let dotCount = 0;
          this.schedule(() => {
            // 生成对应数量的点
            let suffix = '.'.repeat(dotCount);
            const text = 'Loading' + suffix;
            this.lblLoading.string = text;

            // 增加点数，最多3个，然后循环重置
            dotCount = (dotCount + 1) % 4;
          }, 1);
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "progressBar", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "lblProgress", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "lblLoading", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/welcome-hf-B.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './front-line.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, ProgressBar, Label, _decorator, Component, sys, director, FrontLineEvent, FrontLine;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      ProgressBar = module.ProgressBar;
      Label = module.Label;
      _decorator = module._decorator;
      Component = module.Component;
      sys = module.sys;
      director = module.director;
    }, function (module) {
      FrontLineEvent = module.FrontLineEvent;
      FrontLine = module.FrontLine;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class, _class2, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "47ecangTVxCa7EltStD+FU7", "welcome-hf-B", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      const HOT_UPDATE_TIME_COST = exports('HOT_UPDATE_TIME_COST', 'hot_update_time_cost');
      let WelcomeHfB = exports('WelcomeHfB', (_dec = ccclass('WelcomeHfB'), _dec2 = property(ProgressBar), _dec3 = property(Label), _dec4 = property(Label), _dec5 = property(Label), _dec(_class = (_class2 = class WelcomeHfB extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "progressBar", _descriptor, this);
          _initializerDefineProperty(this, "lblProgress", _descriptor2, this);
          _initializerDefineProperty(this, "lblLoading", _descriptor3, this);
          _initializerDefineProperty(this, "lblVersion", _descriptor4, this);
          this.HOT_UPDATE_TIMESTAMP = 'hot_update_timestamp';
          this.HOT_UPDATE_THRESHOLD = 5 * 60 * 1000;
        }
        // 5分钟内的更新认为是刚更新过

        onLoad() {
          this.progressBar.progress = 0;
          this.lblProgress.string = '0%';
          console.log('OjaiTest-welcome-hf-onloaded');
          // 检查是否刚进行过热更新
          if (this.isRecentlyUpdated()) {
            console.log('OjaiTest-检测到最近刚进行过热更新，直接进入游戏');
            this.enterGame();
            return;
          }
          this.updateVersion();

          // 发起热更新检查
          this.startHotUpdate();
        }
        start() {
          this.updateLoadingLabel();
        }
        onEnable() {
          this.node.on(FrontLineEvent.UPDATE_PROGRESS, this.updateProgress, this);
          this.node.on(FrontLineEvent.UPDATE_SUCCESS, this.onUpdateSuccess, this);
          this.node.on(FrontLineEvent.UPDATE_FAILED, this.onUpdateFailed, this);
          this.node.on(FrontLineEvent.ALREADY_UP_TO_DATE, this.onAlreadyUpToDate, this);
          this.node.on(FrontLineEvent.UPDATE_ERROR, this.onUpdateError, this);
        }
        onDisable() {
          this.node.off(FrontLineEvent.UPDATE_PROGRESS, this.updateProgress, this);
          this.node.off(FrontLineEvent.UPDATE_SUCCESS, this.onUpdateSuccess, this);
          this.node.off(FrontLineEvent.UPDATE_FAILED, this.onUpdateFailed, this);
          this.node.off(FrontLineEvent.ALREADY_UP_TO_DATE, this.onAlreadyUpToDate, this);
          this.node.off(FrontLineEvent.UPDATE_ERROR, this.onUpdateError, this);
        }

        /**
         * 检查是否最近刚进行过热更新
         */
        isRecentlyUpdated() {
          const lastUpdateTime = sys.localStorage.getItem(this.HOT_UPDATE_TIMESTAMP);
          if (!lastUpdateTime) {
            return false;
          }
          const timestamp = parseInt(lastUpdateTime);
          const currentTime = Date.now();
          const timeDiff = currentTime - timestamp;
          console.log(`OjaiTest-距离上次更新时间: ${timeDiff}ms`);
          return timeDiff < this.HOT_UPDATE_THRESHOLD;
        }

        /**
         * 记录热更新时间
         */
        recordUpdateTime() {
          sys.localStorage.setItem(this.HOT_UPDATE_TIMESTAMP, Date.now().toString());
          console.log('OjaiTest-记录热更新时间');
        }

        /**
         * 开始热更新流程
         */
        startHotUpdate() {
          let startTime = Date.now();
          console.log('OjaiTest-开始热更新检查');
          const frontLine = this.node.getComponent(FrontLine);
          if (!frontLine) {
            console.error('OjaiTest-FrontLine组件未找到');
            this.enterGame();
            return;
          }
          frontLine.start((success, message) => {
            if (success) {
              console.log('OjaiTest-热更新成功');
              let endTime = Date.now();
              console.log(`OjaiTest-热更新成功，耗时：${endTime - startTime}ms`);
              sys.localStorage.setItem(HOT_UPDATE_TIME_COST, ((endTime - startTime) / 1000).toFixed(2));
              this.updateVersion();
            } else {
              console.log('OjaiTest-热更新失败', message);
              this.enterGame();
            }
          });
        }

        /**
         * 更新进度回调
         */
        updateProgress(progress) {
          this.progressBar.progress = progress;
          this.lblProgress.string = `${Math.floor(progress * 100)}%`;
        }

        /**
         * 热更新成功回调
         */
        onUpdateSuccess() {
          console.log('OjaiTest-热更新成功，准备重启游戏');
          this.recordUpdateTime();
          // 重启游戏，会重新回到这个场景
          // 注意：game.restart() 会在 front-line.ts 的 onUpdateSuccess 中被调用
        }

        /**
         * 热更新失败回调
         */
        onUpdateFailed() {
          console.log('OjaiTest-热更新失败，继续进入游戏');
          this.enterGame();
        }

        /**
         * 已经是最新版本回调
         */
        onAlreadyUpToDate() {
          console.log('OjaiTest-已经是最新版本，直接进入游戏');
          this.enterGame();
        }

        /**
         * 热更新错误回调
         */
        onUpdateError() {
          console.log('OjaiTest-热更新出错，继续进入游戏');
          this.enterGame();
        }

        /**
         * 进入游戏主场景
         */
        enterGame() {
          console.log('OjaiTest-进入游戏主场景');
          // 根据配置决定进入哪个场景
          director.loadScene('welcome');
        }

        /**
         * 开始显示hello world动画，每隔1秒增加一个点，最多3个点，然后循环
         */
        updateLoadingLabel() {
          //每隔1s 变化一个点 需要循环
          let dotCount = 0;
          this.schedule(() => {
            // 生成对应数量的点
            let suffix = '.'.repeat(dotCount);
            const text = 'Loading' + suffix;
            this.lblLoading.string = text;

            // 增加点数，最多3个，然后循环重置
            dotCount = (dotCount + 1) % 4;
          }, 1);
        }
        updateVersion() {
          let frontLine = this.node.getComponent(FrontLine);
          if (frontLine) {
            this.lblVersion.string = frontLine.getVersion();
          }
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class2.prototype, "progressBar", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class2.prototype, "lblProgress", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class2.prototype, "lblLoading", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class2.prototype, "lblVersion", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class2)) || _class));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/welcome.ts", ['./rollupPluginModLoBabelHelpers.js', 'cc', './config-agent.ts', './progress-bar-ctrl.ts', './game-res-manager.ts', './data-agent.ts', './game-data-manager.ts', './mount-point.ts', './mount-manager.ts', './bridge-manager.ts', './log-util.ts', './connect-agent.ts', './i18n-agent.ts', './config.ts', './report-agent.ts', './graph-manager.ts', './union-fetch-agent.ts', './progress-effect.ts', './game-data-type-define.ts', './time-agent.ts', './ui-manager.ts'], function (exports) {
  var _applyDecoratedDescriptor, _initializerDefineProperty, cclegacy, Sprite, Node, _decorator, Component, profiler, director, screen, view, ResolutionPolicy, UIOpacity, tween, Vec3, assetManager, ConfigAgent, ConfigType, ProgressBarCtrl, GameResManager, DataAgent, DataType, GameDataManager, MountPoint, MountManager, BridgeManager, LogUtil, ConnectAgent, i18nAgent, i18n, Config, ReportAgent, CustomReportEvent, GraphManager, UnionFetchAgent, ProgressEffect, SgState, TimeAgent, UIManager;
  return {
    setters: [function (module) {
      _applyDecoratedDescriptor = module.applyDecoratedDescriptor;
      _initializerDefineProperty = module.initializerDefineProperty;
    }, function (module) {
      cclegacy = module.cclegacy;
      Sprite = module.Sprite;
      Node = module.Node;
      _decorator = module._decorator;
      Component = module.Component;
      profiler = module.profiler;
      director = module.director;
      screen = module.screen;
      view = module.view;
      ResolutionPolicy = module.ResolutionPolicy;
      UIOpacity = module.UIOpacity;
      tween = module.tween;
      Vec3 = module.Vec3;
      assetManager = module.assetManager;
    }, function (module) {
      ConfigAgent = module.ConfigAgent;
      ConfigType = module.ConfigType;
    }, function (module) {
      ProgressBarCtrl = module.ProgressBarCtrl;
    }, function (module) {
      GameResManager = module.GameResManager;
    }, function (module) {
      DataAgent = module.DataAgent;
      DataType = module.DataType;
    }, function (module) {
      GameDataManager = module.GameDataManager;
    }, function (module) {
      MountPoint = module.MountPoint;
    }, function (module) {
      MountManager = module.MountManager;
    }, function (module) {
      BridgeManager = module.BridgeManager;
    }, function (module) {
      LogUtil = module.LogUtil;
    }, function (module) {
      ConnectAgent = module.ConnectAgent;
    }, function (module) {
      i18nAgent = module.i18nAgent;
      i18n = module.i18n;
    }, function (module) {
      Config = module.Config;
    }, function (module) {
      ReportAgent = module.ReportAgent;
      CustomReportEvent = module.CustomReportEvent;
    }, function (module) {
      GraphManager = module.GraphManager;
    }, function (module) {
      UnionFetchAgent = module.UnionFetchAgent;
    }, function (module) {
      ProgressEffect = module.ProgressEffect;
    }, function (module) {
      SgState = module.SgState;
    }, function (module) {
      TimeAgent = module.TimeAgent;
    }, function (module) {
      UIManager = module.UIManager;
    }],
    execute: function () {
      var _dec, _dec2, _dec3, _dec4, _dec5, _class2, _class3, _descriptor, _descriptor2, _descriptor3, _descriptor4;
      cclegacy._RF.push({}, "a9c69fLvMRDMJtwp/Vxiu1h", "welcome", undefined);
      const {
        ccclass,
        property
      } = _decorator;
      let welcome = exports('welcome', (_dec = ccclass('welcome'), _dec2 = property(Sprite), _dec3 = property(ProgressBarCtrl), _dec4 = property(ProgressEffect), _dec5 = property(Node), _dec(_class2 = (_class3 = class welcome extends Component {
        constructor(...args) {
          super(...args);
          _initializerDefineProperty(this, "sprBg", _descriptor, this);
          _initializerDefineProperty(this, "progressBar", _descriptor2, this);
          _initializerDefineProperty(this, "progressBarSg", _descriptor3, this);
          _initializerDefineProperty(this, "logoSg", _descriptor4, this);
          this._isSgLoading = false;
          this._isSgLoadComplete = false;
        }
        onLoad() {
          this.adapt();
        }
        async start() {
          Config.firstSetFlagTime = Date.now();
          profiler.hideStats();
          this.loadDataFromLocal();
          this.updateDisplay();
          LogUtil.log('welcome');
          director.preloadScene('map');
          this.progressBar.setConfig(this.onProgressComplete.bind(this), 45, 80);
          await i18nAgent.loadLangJson();
          BridgeManager.instance.setupNativeEventListner(async () => {
            // init
            let time0 = TimeAgent.instance.getTime();
            this.reportLoading("init", "start", time0);
            ConnectAgent.init();
            GraphManager.instance.init();
            let time1 = TimeAgent.instance.getTime();
            this.reportLoading("init", "end", time0, time1);

            // load_bundle
            this.reportLoading("load_bundle", "start", time1);
            await this.loadBundles();
            i18nAgent.setLangCode(Config.LANG_CODE);
            // i18nAgent.setLangCode('ja');
            LogUtil.log('welcome i18n:', i18n.t('welcome'));
            this.lockProgress(35);
            let time2 = TimeAgent.instance.getTime();
            this.reportLoading("load_bundle", "end", time1, time2);

            // fetch_data
            this.reportLoading("fetch_data", "start", time2);
            await UnionFetchAgent.fetchUnionData();
            Config.INIT_FETCH_DATA = true;
            this.notifyAfterFetchData();
            this.lockProgress(65);
            await this.loadSg();
            let time3 = TimeAgent.instance.getTime();
            this.reportLoading("fetch_data", "end", time2, time3);
            this.lockProgress(80);
            // proload
            this.reportLoading("proload", "start", time3);
            await this.preload();
            this.lockProgress(100);
            let time4 = TimeAgent.instance.getTime();
            this.reportLoading("proload", "end", time3, time4);
          });
        }
        adapt() {
          // 根据设备类型设置适配模式
          const winSize = screen.windowSize;
          const screenRatio = winSize.width / winSize.height;
          const designSize = view.getDesignResolutionSize();
          const designRatio = designSize.width / designSize.height;
          if (screenRatio <= 1) {
            if (screenRatio <= designRatio) {
              view.setDesignResolutionSize(designSize.width, designSize.height, ResolutionPolicy.FIXED_WIDTH);
              LogUtil.log('Device: iPhone, using FIXED_WIDTH mode');
            } else {
              view.setDesignResolutionSize(designSize.width, designSize.height, ResolutionPolicy.FIXED_HEIGHT);
              LogUtil.log('Device: iPad, using FIXED_HEIGHT mode');
            }
          } else {
            view.setDesignResolutionSize(designSize.width, designSize.height, ResolutionPolicy.FIXED_HEIGHT);
            LogUtil.log('Device: iPad, using FIXED_HEIGHT mode');
          }
        }
        notifyAfterFetchData() {
          MountManager.instance.notify(MountPoint.RemoteWebConfigUpdated, ConfigAgent.getConfig(ConfigType.Web));
          MountManager.instance.notify(MountPoint.RemoteStoreDataUpdated, DataAgent.getData(DataType.Gain));
        }
        loadDataFromLocal() {
          GameDataManager.instance.loadFromLocal();
        }
        lockProgress(progress) {
          this.progressBarSg.node.active && this.progressBarSg.toProgress(progress, this.onProgressComplete.bind(this));
          if (progress < 100) {
            this.progressBar.lock(progress);
          } else {
            this.progressBar.unlock();
          }
        }
        updateDisplay() {
          let isSg = true;
          let progressOpacity = this.progressBar.getComponent(UIOpacity);
          progressOpacity.opacity = 0;
          this.progressBarSg.node.active = isSg;
          this.progressBarSg.progress = 0;
          let bgLight = this.logoSg.getChildByName('BgLight');
          tween(bgLight).by(10, {
            eulerAngles: new Vec3(0, 0, 360)
          }).repeatForever().start();
        }
        async loadBundles() {
          const bundles = ['bundle-beyond', 'bundle-sg'];
          const promises = [];
          for (let i = 0; i < bundles.length; i++) {
            const bundleName = bundles[i];
            const promise = new Promise((resolve, reject) => {
              assetManager.loadBundle(bundleName, (err, bundle) => {
                if (err) {
                  console.error('load bundle error:', bundleName, err);
                  resolve();
                  return;
                }
                resolve();
                LogUtil.log('load bundle success:', bundleName);
              });
            });
            promises.push(promise);
          }
          await Promise.all(promises);
          LogUtil.log('all bundles loaded');
        }
        onProgressComplete() {
          LogUtil.log('onProgressComplete');
          ReportAgent.reportCustomEvent(CustomReportEvent.HOME_START_GAME);
          GameDataManager.instance.sg.state = SgState.Started;
          director.loadScene('map-sg');
          if (GameDataManager.instance.data.firstGameAction.start_game) {
            GameDataManager.instance.data.firstGameAction.start_game = false;
            ReportAgent.reportCustomEvent(CustomReportEvent.USER_LIFECYCLE_MILESTONE, {
              action: 'star_first'
            });
          }
          if (GameDataManager.instance.data.firstGameAction.loading) {
            GameDataManager.instance.data.firstGameAction.loading = false;
            ReportAgent.reportCustomEvent(CustomReportEvent.USER_LIFECYCLE_MILESTONE, {
              action: 'loading_first'
            });
          }
        }

        // async loadData() {
        //     const payload = await DataAgent.fetchData();
        //     if (!payload) {
        //         LogUtil.error('welcome loadData error: payload is null');
        //         return;
        //     }

        //     LogUtil.log('welcome loadData payload:', JSON.stringify(payload));

        //     const playerData = {
        //         sid: payload['sid'] || '',
        //         major: payload['tokenMajor'] || 0,
        //         minor: payload['tokenMinor'] || 0
        //     }

        //     try {
        //         if (payload[DataType.Game]) {
        //             GameDataManager.instance.initData(JSON.parse(payload[DataType.Game]), playerData);
        //         }

        //     } catch (error) {
        //         console.error('welcome error1:', error);
        //     }

        //     try {
        //         if (payload[DataType.Gain]) {
        //             MountManager.instance.notify(MountPoint.RemoteStoreDataUpdated, JSON.parse(payload[DataType.Gain]));
        //         }
        //     } catch (error) {
        //         console.error('welcome error2:', error);
        //     }

        // }

        async preload() {
          try {
            await GameResManager.instance.preload();
          } catch (error) {
            LogUtil.error('welcome preload error:', error);
          }
        }
        async loadSg() {
          try {
            console.log('loadSg--start');
            let gdMgr = GameDataManager.instance;
            let time0 = TimeAgent.instance.getTime();
            this.reportLoading("load_sg", "start", time0);
            let cacheSize = 8;
            let needNum_n = cacheSize - gdMgr.sg.unselectedNormalPicInfoList.length;
            needNum_n = Math.min(needNum_n, 4);
            let count_n = 0;
            let list = [];
            if (needNum_n > 0) {
              let list_n = gdMgr.getUncachedPictureList(needNum_n, false);
              if (list_n.length < needNum_n) {
                let promiseFetch = MountManager.instance.notify(MountPoint.RemoteFetchIllustration, {
                  total: 10,
                  adCount: 0
                })[0];
                if (promiseFetch instanceof Promise) {
                  await promiseFetch;
                }
                list_n = gdMgr.getUncachedPictureList(needNum_n, false);
              }
              list = list.concat(list_n);
              if (Config.DEBUG) {
                count_n = list_n.length;
                UIManager.instance.showToast(`Welcome-LoadSg:n-${count_n}`);
              }
            }
            let needNum_s = cacheSize - gdMgr.sg.unselectedSpecialPicInfoList.length - needNum_n;
            needNum_s = Math.min(needNum_s, 4);
            let count_s = 0;
            if (needNum_s > 0) {
              let list_s = gdMgr.getUncachedPictureList(needNum_s, true);
              if (list_s.length < needNum_s) {
                let promiseFetch = MountManager.instance.notify(MountPoint.RemoteFetchIllustration, {
                  total: 10,
                  adCount: 0
                })[0];
                if (promiseFetch instanceof Promise) {
                  await promiseFetch;
                }
                count_s = list_s.length;
              }
              list = list.concat(list_s);
              if (Config.DEBUG) {
                list_s = gdMgr.getUncachedPictureList(needNum_s, true);
                UIManager.instance.showToast(`Welcome-LoadSg:s-${count_s}`);
              }
            }
            let promisePreload = MountManager.instance.notify(MountPoint.NativeNotifyLoadPicture, {
              infoList: list,
              type: 2,
              taskId: `welcome-pics`
            })[0];
            await promisePreload;
            this._isSgLoadComplete = true;
            console.log('loadSg--end');
            let time1 = TimeAgent.instance.getTime();
            this.reportLoading("load_sg", "end", time0, time1);
          } catch (error) {
            this._isSgLoadComplete = true;
            LogUtil.error('welcome loadSg:', error);
          }
        }

        // private timeCount: number = 0;
        // async updateForFlagChanged() {
        //     let time = 5;
        //     let preloadTime = RewardManager.instance.getConfig().sg.preload_time;
        //     ++this.timeCount;
        //     LogUtil.log('updateForFlagChanged: timeCount:' + this.timeCount);
        //     if (this.timeCount >= time + preloadTime) {
        //         this.onSgProcessComplete();
        //         return;
        //     }

        //     if (Config.ENABLE_SG) {
        //         if (!this._isSgLoading) {
        //             this._isSgLoading = true;
        //             this.loadSg();
        //         }

        //         if (this._isSgLoadComplete) {
        //             this.onSgProcessComplete();
        //         }
        //     } else if (Config.isFlagChanged) {
        //         if (Config.getRFlag()) {
        //             if (!this._isSgLoading) {
        //                 this._isSgLoading = true;
        //                 this.loadSg();
        //             }

        //             if (this._isSgLoadComplete) {
        //                 this.onSgProcessComplete();
        //             }
        //         } else {
        //             if (this.timeCount >= time) {
        //                 this.onSgProcessComplete();
        //             }
        //         }
        //     }

        // }

        // onSgProcessComplete() {
        //     if (this.progressBar.getCurrentLock() >= 80) {
        //         this.unschedule(this.updateForFlagChanged);
        //         // this.progressBar.unlock();
        //         this.progressBarSg.toProgress(100, this.onProgressComplete.bind(this));

        //     }
        // }

        reportLoading(stepId, action, startTime, endTime = null) {
          let dur = endTime ? endTime - startTime : 0;
          ReportAgent.reportCustomEvent(CustomReportEvent.LOADING, {
            loading_step_id: "init",
            loading_step_action: "start",
            loading_step_time: dur / 1000,
            user_type: GameDataManager.instance.localData.lastRFlag ? 1 : 2
          });
        }
      }, (_descriptor = _applyDecoratedDescriptor(_class3.prototype, "sprBg", [_dec2], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor2 = _applyDecoratedDescriptor(_class3.prototype, "progressBar", [_dec3], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor3 = _applyDecoratedDescriptor(_class3.prototype, "progressBarSg", [_dec4], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      }), _descriptor4 = _applyDecoratedDescriptor(_class3.prototype, "logoSg", [_dec5], {
        configurable: true,
        enumerable: true,
        writable: true,
        initializer: function () {
          return null;
        }
      })), _class3)) || _class2));
      cclegacy._RF.pop();
    }
  };
});

System.register("chunks:///_virtual/YJPHBDNICBXPNH.ts", ['cc', './SVDMRMIFJDYHRX.ts', './AQKTRMDQJQQBTDC.ts', './PQBRALKRA.ts', './PZCMUYBUB.ts', './WBKIRV.ts'], function (exports) {
  var cclegacy, SVDMRMIFJDYHRX, AQKTRMDQJQQBTDC, PQBRALKRA, PZCMUYBUB, KOOVAFDJSB;
  return {
    setters: [function (module) {
      cclegacy = module.cclegacy;
    }, function (module) {
      SVDMRMIFJDYHRX = module.SVDMRMIFJDYHRX;
    }, function (module) {
      AQKTRMDQJQQBTDC = module.AQKTRMDQJQQBTDC;
    }, function (module) {
      PQBRALKRA = module.PQBRALKRA;
    }, function (module) {
      PZCMUYBUB = module.PZCMUYBUB;
    }, function (module) {
      KOOVAFDJSB = module.KOOVAFDJSB;
    }],
    execute: function () {
      cclegacy._RF.push({}, "edb6fhUzM5JkpnrwdQDBhz1", "YJPHBDNICBXPNH", undefined);
      class YJPHBDNICBXPNH extends SVDMRMIFJDYHRX {
        TGQXAKDAHFFVG() {}
        QIZLFVUQ() {}
        SDFLIQOQYBBXD(AFCDCGSWUQHRUY) {
          return PZCMUYBUB.MSCGDWEHBPVJEQE().SDFLIQOQYBBXD(AFCDCGSWUQHRUY);
        }
        EBZYRKYXFPTJCTAV() {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().EBZYRKYXFPTJCTAV();
        }
        QUDSVNDFTRJ() {
          if (PQBRALKRA.OTORTMMYVD) {
            return true;
          }
          let data = AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().ZZASVTSP(KOOVAFDJSB.QUDSVNDFTRJ);
          return Boolean(data);
        }
        MRVQRTO(AFCDCGSWUQHRUY) {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().MRVQRTO(AFCDCGSWUQHRUY);
        }
        COUYOLVIRRJBJ(KSRMVHKTWUAYRHY) {
          if (PQBRALKRA.OTORTMMYVD) {
            return;
          }
          AQKTRMDQJQQBTDC.MSCGDWEHBPVJEQE().COUYOLVIRRJBJ(KSRMVHKTWUAYRHY);
        }
      }
      exports('YJPHBDNICBXPNH', YJPHBDNICBXPNH);
      cclegacy._RF.pop();
    }
  };
});

(function(r) {
  r('virtual:///prerequisite-imports/main', 'chunks:///_virtual/main'); 
})(function(mid, cid) {
    System.register(mid, [cid], function (_export, _context) {
    return {
        setters: [function(_m) {
            var _exportObj = {};

            for (var _key in _m) {
              if (_key !== "default" && _key !== "__esModule") _exportObj[_key] = _m[_key];
            }
      
            _export(_exportObj);
        }],
        execute: function () { }
    };
    });
});